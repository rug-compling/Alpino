%%           -*-Mode: prolog;-*-

:- expects_dialect(sicstus).

:- discontiguous
    grammar_rule/3.

:- use_module(library(lists)).     % append in valence principle 

%% top_cat: top category for single utterances (not used by robustness)
%%      typically includes punctuation at the end. Typically consists
%%      of start + punctuation.
%%
%% start: top category for single utterance, but without punctuation at
%%        end
%%
%% max:   top category, also used by robustness. Typically does not
%%        include punctuation at the end
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Structures  %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% HEAD + EXTRAPOSED structures

%% to have a "structure" that every rule inherits from.
structure.

hd_extra_structure(H,Extra,M) :-
    H:exs <=> _,
    H:ccat0 <=> Cat,
    unify_mods(Extra),
    projected_hd_structure(H,[],[],[],[],[],[],[],[Extra],[],[],M,Cat).

hd_m_extra_structure(H,Extra,M) :-
    H:mexs <=> _,
    H:ccat0 <=> Cat,
    unify_mods(Extra),
    projected_hd_structure(H,[],[],[],[],[],[],[],[],[Extra],[],M,Cat).

%% HEAD + COMPLEMENT structures
hd_comp_structure(H,Cmp,M) :-
    H:sc <=> _,
    H:ccat0 <=> Cat,
    projected_hd_structure(H,[Cmp],[],[],[],[],[],[],[],[],[],M,Cat).

%% directly select two complements (for absolute-met construction)
hd_comp2_structure(H,Cmp1,Cmp2,M) :-
    H:sc <=> _,
    H:ccat0 <=> Cat,
    projected_hd_structure(H,[Cmp1,Cmp2],[],[],[],[],[],[],[],[],[],M,Cat).
  
%% HEAD + PARTICLE structures
hd_part_structure(H,Prt,M) :-
    H:parts <=> _,
    H:ccat0 <=> Cat,
    unify_mods(Prt),
    projected_hd_structure(H,[],[Prt],[],[],[],[],[],[],[],[],M,Cat).

%% HEAD MODIFIER structures
%% dt is constructed lexically by means of mods/cmods features
hd_mod_structure(H,Mod,M) :-
    H:ccat0 <=> Cat,
    H:cmods <=> _,
    H:mods <=> _,
    unify_mods(Mod),
    Mod:sc =?> [],
    Mod:e_deps =?> [],
    Mod:slash =?> [],
    %% this forbids extraction from modifier pp's
    %% and modifier sbar's
    projected_hd_structure(H,[],[],[Mod],[],[],[],[],[],[],[],M,Cat).

%% HEAD PREDM structures
hd_predm_structure(H,Mod,M) :-
    H:ccat0 <=> Cat,
    hd_predm_structure(H,Mod,M,Cat).

hd_predm_structure(H,Mod,M,Cat) :-
    H:predms <=> _,
    H:cpredms <=> _,
    unify_mods(Mod),
    Mod:sc =?> [],
    Mod:slash =?> [],
    Mod:e_deps =?> [],
    projected_hd_structure(H,[],[],[],[],[],[],[],[],[],[Mod],M,Cat).
    
hd_rel_structure(H,Rel,M) :-
    %% this rules out things like 'de vrouw dat ik ken'
    %% but not 'de vrouw hoe ik ken'
    Rel:agr <?=?> H:agr,
    Rel:hstem <?=?> H:hstem,
    Rel:nform <?=?> H:nform,

    %% this rules out things like 'overal die ik ken'
    Notmploc => (loc;non_adv;str_er),
    if_defined(H:tmploc,Tmploc,Notmploc),
    Rel:tmploc <=> Tmploc,

    %% apart from that, it's just a hd-mod-struct
    hd_mod_structure(H,Rel,M).

%% HEAD FILLER structures
%% two different structures, since
%%    Piet zei Jan dat ik moest kopen
%%    Wat zei Jan dat ik moest kopen
%% receive quite different dependency structures
projected_hd_filler_structure(H,Slash,M) :-
    H:slash <=> _,
    H:ccat0  <=> Cat,
    projected_hd_filler_structure(H,Slash,M,Cat).

projected_hd_filler_structure(H,Slash,M,Cat) :-
    projected_hd_structure(H,[],[],[],[],[],[Slash],[],[],[],[],M,Cat),
    if_defined(Slash:exs,Exs,[]),
    if_defined(H:iexs,Exs,[]),
    if_defined(Slash:mexs,Mexs,[]),
    is_defined(H:imexs,Bool1),
    (   Bool1 = yes,
        H:imexs <=> Mexs
    ;   Bool1 = no,
        alpino_wappend:unify_inout(Mexs)
    ).

finish_mexs(Cat) :-
    if_defined(Cat:mexs,Mexs,[]),
    alpino_wappend:unify_inout(Mexs).

non_projected_hd_filler_structure(H,Slash,M) :-
    H:slash <=> _,
    H:ccat0 <=> Cat,
    non_projected_hd_filler_structure(H,Slash,M,Cat).

non_projected_hd_filler_structure(H,Slash,M,Cat) :-
    non_projected_hd_structure(H,[],[],[Slash],[],[],[],M,Cat),
    if_defined(Slash:exs,Exs,[]),
    if_defined(H:iexs,Exs,[]),
    if_defined(Slash:mexs,Mexs,[]),
    is_defined(H:imexs,Bool1),
    (   Bool1 = yes,
        H:imexs <=> Mexs
    ;   Bool1 = no,
        alpino_wappend:unify_inout(Mexs)
    ).

%% NUCL_TAG
xy_dep_dt(Nucl,Tag,M,Cat,NuclAtt,TagAtt) :-
    assign_new_cat(M,Cat),
    xy_dep_dt(Nucl,Tag,M,NuclAtt,TagAtt).

xy_dep_dt(Nucl,Tag,M,NuclAtt,TagAtt) :-
    alpino_data:dt(Nucl,NuclDt),
    alpino_data:dt(Tag,TagDt),
    alpino_data:dt(M,MDt),
    MDt:NuclAtt <=> NuclDt,
    MDt:TagAtt <=> TagDt,
    initialize_dt([NuclAtt,TagAtt],M),
    MDt:stype => declarative,
    MDt:hwrd => [].

xy_dep_dt_nostype(Nucl,Tag,M,Cat,NuclAtt,TagAtt) :-
    assign_new_cat(M,Cat),
    xy_dep_dt_nostype(Nucl,Tag,M,NuclAtt,TagAtt).

xy_dep_dt_nostype(Nucl,Tag,M,NuclAtt,TagAtt) :-
    alpino_data:dt(Nucl,NuclDt),
    alpino_data:dt(Tag,TagDt),
    alpino_data:dt(M,MDt),
    MDt:NuclAtt <=> NuclDt,
    MDt:TagAtt <=> TagDt,
    initialize_dt([NuclAtt,TagAtt],M),
    MDt:hwrd => [].

xy_dep_structure(Nucl,Tag,M,Cat,NuclAtt,TagAtt) :-
    non_hd_structure([Nucl,Tag],M,Cat),
    xy_dep_dt(Nucl,Tag,M,NuclAtt,TagAtt).

xy_dep_nostype_structure(Nucl,Tag,M,Cat,NuclAtt,TagAtt) :-
    non_hd_structure([Nucl,Tag],M,Cat),
    xy_dep_dt_nostype(Nucl,Tag,M,NuclAtt,TagAtt).

dp_dp_structure(L,R,M) :-
    non_hd_structure([L,R],M,du),
    alpino_data:dt(L,LDt),
    alpino_data:dt(R,RDt),
    alpino_data:dt(M,MDt),
    MDt:dp <=> [LDt,RDt],
    MDt:stype => declarative,
    initialize_dt([dp],M),
    MDt:hwrd => [].

dp_dp_structure(L,R,Q,M) :-
    non_hd_structure([L,R,Q],M,du),
    alpino_data:dt(L,LDt),
    alpino_data:dt(R,RDt),
    alpino_data:dt(Q,QDt),
    alpino_data:dt(M,MDt),
    MDt:dp <=> [LDt,RDt,QDt],
    MDt:stype => declarative,
    initialize_dt([dp],M),
    MDt:hwrd => [].

unify_except_dt(M0,M) :-
    unify_except_l(M0,M,[dt,ccat0,ccat,cmods,mods,capps,apps,cdets,dets,
                         cpredms,predms]).

unify_dt(M0,M) :-
    unify_paths([dt,ccat0,ccat,cmods,mods,capps,apps,cdets,dets,
                         cpredms,predms],M0,M).

dp_tag_dp_structure(L,TAG,R,M) :-
    unify_except_dt(M0,M),
    dp_dp_structure(L,R,M0),
    TAG => tag,
    TAG:np => no,
    nucl_tag_structure(M0,TAG,M).

dlink_nucl_structure(Comp,VP,Sbar) :-
    Comp:ccat0 <=> Cat,
    non_projected_hd_structure(Comp,[VP],[],[],[],[],[],Sbar,Cat),
    VP:dt:stype <=> Sbar:dt:stype,
    xy_dep_dt_nostype(Comp,VP,Sbar,dlink,nucl).

cmp_body_structure(Comp,VP,Sbar) :-
    Comp:ccat0 <=> Cat,
    cmp_body_structure(Comp,VP,Sbar,Cat).

cmp_body_structure(Comp,VP,Sbar,Cat) :-
    VP:haswh =?> no,
    non_projected_hd_structure(Comp,[VP],[],[],[],[],[],Sbar,Cat),
    xy_dep_dt(Comp,VP,Sbar,cmp,body).

nucl_tag_structure(Nucl,Tag,M) :-
    xy_dep_structure(Nucl,Tag,M,du,nucl,tag).

nucl_sat_structure(Nucl,Sat,M) :-
    xy_dep_structure(Nucl,Sat,M,du,nucl,sat).

nucl_sat_tag_structure(Nucl,Sat,TAG,M) :-
    unify_except(M0,M,dt:tag),
    nucl_sat_structure(Nucl,Sat,M0),
    TAG => tag,
    TAG:dt <=> M:dt:tag,
    unify_mods(TAG).

%%% HD DET
hd_det_structure(Det,N,NP) :-
    N:ccat0 <=> Cat,
    hd_det_structure(Det,N,NP,Cat).

hd_det_structure(Det,N,NP,Cat) :-
    unify_mods(Det),
    Det:sc =?> [],
    projected_hd_structure(N,[],[],[],[Det],[],[],[],[],[],[],NP,Cat).

%%% HD APP
hd_app_structure(N0,N2,N) :-
    N0:ccat0 <=> Cat,
    hd_app_structure(N0,N2,N,Cat).

hd_app_structure(N0,N2,N,Cat) :-
    N0:capps <=> _,
    N0:apps <=> _,
    unify_mods(N2),
    projected_hd_structure(N0,[],[],[],[],[N2],[],[],[],[],[],N,Cat).

%% HEADED structures
hd_structure(H,M,Cat) :-                    %% unary rules,
    projected_hd_structure(H,[],[],[],[],[],[],[],[],[],[],M,Cat).

hd_structure(H,M) :-
    H:ccat0 <=> Cat,
    hd_structure(H,M,Cat).

%% "projected_hd"
%% Head: syntactic head and semantic head
%% "chain rule"                        
projected_hd_structure(H,Cmps,Prts,Adjs,Dets,Apps,Fils,Misc,Exs,MExs,Predms,M,Cat) :-
    structure(H,Cmps,Prts,Adjs,Dets,Apps,Fils,Misc,Exs,MExs,Predms,M),
    hd_dt_principle(Cat,H,M,Adjs,Dets,Apps,Predms).

%% Head: only syntactic head;
%% "non chain rule"
non_projected_hd_structure(H,Cmps,Prts,Fils,Misc,Exs,MExs,M,Cat) :-
    structure(H,Cmps,Prts,[],[],[],Fils,Misc,Exs,MExs,[],M),
    non_hd_dt_principle(M,Cat),
    unify_mods(H).

%% PERCOLATION of DT for "projected" heads, i.e. where the DT
%% of the mother equals the DT of the head
hd_dt_principle(Cat,H,M,Adjs,Dets,Apps,Predms) :-
    H:dt     <=>  M:dt,
    H:ccat   <=> M:ccat,
    H:dets   <=> M:dets,
    H:predms <=> M:predms,
    H:apps   <=> M:apps,
    H:mods   <=> M:mods,
    adjunct_principle(H,Adjs,M),
    predm_principle(H,Predms,M),
    appos_principle(H,Apps,M),
    dets_principle(H,Dets,M),
    M:ccat0 ==> Cat.

adjunct_principle(H,Adjs,M) :-
    percolate_principle(cmods,H,Adjs,M).

predm_principle(H,Adjs,M) :-
    percolate_principle(cpredms,H,Adjs,M).

dets_principle(H,Adjs,M) :-
    percolate_principle(cdets,H,Adjs,M).

appos_principle(H,Adjs,M) :-
    percolate_principle(capps,H,Adjs,M).

percolate_principle(Att0,H,Adjs,M) :-
    H:Att0 <=> HeadMods,
    dts(Adjs,AdjsDts),
    M:Att0 <=> MotherMods,
    append(AdjsDts,HeadMods,MotherMods).

%% PERCOLATION of DT for structures without such a
%% projected head
non_hd_dt_principle(M,Cat) :-
    assign_new_cat(M,Cat),
    assign_new_percolation(M,cmods,  mods,  mod),
    assign_new_percolation(M,capps,  apps,  app),
    assign_new_percolation(M,cdets,  dets,  det),
    assign_new_percolation(M,cpredms,predms,predm).

assign_new_cat(M,Cat) :-
    M:dt => dt,
    M:ccat0 ==> Cat,
    M:ccat <=> M:dt:cat.

assign_new_percolation(M,Att0,Att,AttDt) :-
    M:dt => dt,
    M:Att0 => [],
    M:Att <=> M:dt:AttDt.

%% STRUCTURES without a head
non_hd_structure(Ds,M,Cat) :-
    H => no_cat,
    non_hd_dt_principle(M,Cat),
    structure(H,[],[],[],[],[],[],Ds,[],[],[],M),
    unify_mods_list(Ds).

unify_mods_list([]).
unify_mods_list([H|T]) :-
    unify_mods(H),
    unify_mods_list(T).

structure(H,Cmps,Prts,Adjs,Dets,Apps,Fils,Misc,Exs,MExs,Predms,M) :-
    structure,
    head_feature_principle(H,M),
    dip_tags_principle(H,M),
    valence_principle(H,Cmps,Prts,M),
    filler_principle(H,Fils,M),
				% NB: exs and mexs of fillers is ignored
                                % these are inherited separately
    extraposition_principle(H,[Cmps,Prts,Adjs,Dets,Apps,MExs,Misc,Predms],
			    Exs,M),
    m_extraposition_principle(H,[Cmps,Prts,Adjs,Dets,Apps,Exs,Misc,Predms],
			      MExs,M).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% PRINCIPLES %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dip_tags_principle(H,M) :-
    if_defined(H:tags,Tags,[]),
    if_defined(M:tags,Tags,[]).

extraposition_principle(H,Dtrs,Exs,M) :-
    all_all_exs(Dtrs,ExtraExs,[]),
    all_exs(Exs,[],[]),		% we could also inherit these, but this only
				% yields further spurious parses
    if_defined(H:exs,HeadExs,[]),
    if_defined(M:exs,MotherExs,[]),
    alpino_wappend:wappend(HeadExs,ExtraExs,MidExs),
    alpino_wappend:wappend(Exs,MotherExs,MidExs).

m_extraposition_principle(H,Dtrs,MExs,M) :-
    all_all_mexs(Dtrs,ExtraExs,[]),
    all_mexs(MExs,ExsExs,[]),  % for:
                               % omdat ik het lied zing van de zanger en de zangeres die hier optraden
    if_defined(H:mexs,HeadExs,[]),
    alpino_wappend:wappend(HeadExs,ExtraExs,MotherExs0),
    select_all_mexs(MExs,MotherExs0,MotherExs1),
    alpino_wappend:wappend(MotherExs1,ExsExs,MotherExs),
    is_defined(M:mexs,Bool),
    (   Bool = yes,
        M:mexs <=> MotherExs
    ;   Bool = no,
        alpino_wappend:unify_inout(MotherExs)
    ).

select_all_mexs([],M,M).
select_all_mexs([HCat|T],M0,M) :-
    H => mexs_cat,
    H:mods<=> [MODDT],
    HCat:dt <=> MODDT,
    H:agr <?=?> HCat:agr,
    H:tmploc <?=?> HCat:tmploc,
    H:sel <?=?> HCat:sel,
    H:hstem <?=?> HCat:hstem,
    H:nform <?=?> HCat:nform,
    H:cat <=> HCat,
    alpino_wappend:wwselect(H,M0,M1),
    select_all_mexs(T,M1,M).

all_all_exs([],E,E).
all_all_exs([H|T],E0,E) :-
    all_exs(H,E0,E1),
    all_all_exs(T,E1,E).

all_exs([],E,E).
all_exs([H|T],E0,E) :-
    if_defined(H:exs,E1,[]),
    alpino_wappend:wappend(E1,E2,E0),
    all_exs(T,E2,E).

all_all_mexs([],E,E).
all_all_mexs([H|T],E0,E) :-
    all_mexs(H,E0,E1),
    all_all_mexs(T,E1,E).

all_mexs([],E,E).
all_mexs([H|T],E0,E) :-
    if_defined(H:mexs,E1,[]),
    alpino_wappend:wappend(E1,E2,E0),
    all_mexs(T,E2,E).

valence_principle(H,Cmps,Prts,M) :-
    if_defined(H:sc,HeadSc,[]),
    if_defined(M:sc,MotherSc,[]),
    append(Cmps,MotherSc,HeadSc),
    if_defined(H:parts,HeadPrts,[]),
    if_defined(M:parts,MotherPrts,[]),
    append(Prts,MotherPrts,HeadPrts).

filler_principle(H,Slash,M) :-
    if_defined(H:slash,HeadSlash,[]),
    if_defined(M:slash,MotherSlash,[]),
    append(Slash,MotherSlash,HeadSlash).

head_feature_principle(H,M) :-
    head_features(Atts),
    default_head_features(HeadDefaults),
    default_features(Defaults),
    unify_paths(Atts,H,M),
    unify_head_defaults(HeadDefaults,H,M),
    unify_defaults(Defaults,M),
    e_agr(H,M).

e_agr(H,M) :-
    is_defined(H:e_agr,No),
    is_defined(M:e_agr,Yes),
    e_agr1(No,Yes,M).

e_agr1(no,Yes,M):-
    e_agr2(Yes,M).
e_agr1(yes,_,_).

e_agr2(yes,M) :-
    M:e_agr <=> M:dt:num.
e_agr2(no,_).

%% add defaults for (some) head features that are undefined on the
%% head, but defined on the mother.
%% head features, but assign default value to mother if head cannot have this feature
default_head_features([d(meas,no),
		       d(wh,nwh),
		       d(redrel,no),
		       d(cform,base),
		       d(pred,npred),
		       d(me_adj,no),
		       d(e_deps,[]),
                       d(amount,no),
		       d(prs,thi),
		       d(can_postn,no),
		       d(can_postn_with_cform,no),
                       d(can_postv,no),
                       d(adj_can_postv,no),
		       d(can_nominalize,no),
		       d(can_marked_attr,no),
		       d(hstem,[]),
		       m_path(e_agr,agr)
		      ]).

%% assign default value to mother
default_features([d(lex,no)]).

head_features([agr,e_agr,subj,prep,preptype,adv,question,pron,
	       tense,vform,adj_agr,hdet,fixed_dep,pp_role,
	       case,aform, modf,pro,wkpro,pcat,amount,allows_drop,
	       subn,inv,tpart,modifies_a,avform,sel,haswh,can_mod,
	       nform,wh_reltmploc,vframe,sv1_mod,subadv,cleft,veps,vhasmod,
	       app,hebben_zijn,compar_form,neclass,can_postv,adj_can_postv,
	       vslash,ctype,deverbal,ppost,passive,nagr,nhstem,nnform,ndt,
	       tmploc,ld_pc,vtype,pro_deps,sv1,rightx,pp_er,
               allows_root_imp,has_obcomp,modifies_v
	      ]).

%% if head does not have this feature, then assign default value to
%% mother by setting that value to Mother:Path
unify_head_default(m_path(Att,Path),Hd,Mother) :-
    is_defined(Hd:Att,Bool),
    unify_head_default(Bool,Mother,Path,Att).

unify_head_default(d(Att,Feature),Hd,Mother) :-
    Val => Feature, %% for booleans this is necc
    if_defined(Hd:Att,HeadVal,Val),
    Mother:Att <?=?> HeadVal.

unify_head_default(no,Mother,Path,Att) :-
    Mother:Path <?=?> Mother:Att.
unify_head_default(yes,_,_,_).

unify_head_defaults([],_,_).
unify_head_defaults([Hd|T],H,M) :-
    unify_head_default(Hd,H,M),
    unify_head_defaults(T,H,M).

unify_default(d(Att,Feature),Mother) :-
    Mother:Att =?> Feature.

unify_defaults([],_).
unify_defaults([Hd|T],M) :-
    unify_default(Hd,M),
    unify_defaults(T,M).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% ABBREVIATIONS for Categories %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pp_modifier(PP) :-
    PP => pp,
    PP:wh => nwh,
    PP:pp_role => pp_obj1,
    PP:nnform => ~refl,
    PP:ld_pc => (n_pp;mod_pp;pred_pp),
    PP:slash => [],
    PP:e_deps => [].

pp_predm(PP) :-
    max_pred(PP),
    PP:wh => nwh,
    PP:pcat => (als_pred;pp_pred).

wh_pp_predm(PP) :-
    max_pred(PP),
    PP:wh => ywh,
    PP:pcat => als_pred.

redrel_modifier(Sbar) :-
    Sbar => redrel,
    %%    Sbar:tmploc => ~str_er & ~wk_er & ~postp,
    %% In 1936 herbezette Duitsland het Rijnland , waar de geallieerden niet op reageerden .
    Sbar:tmploc => ~wk_er & ~postp,
    Sbar:e_deps => [],
    Sbar:sub_wh => ywh,
    Sbar:sub_wh => nq,
    Sbar:haswh => nwh,
    Sbar:dt:whd => [],
    Sbar:relhd <=> Sbar:dt:rhd.

nwh_np_arg(NP) :-
    np_arg(NP),
    NP:wh => nwh.

np_arg(NP) :-
    NP => np,
    NP:e_deps => [],
    unify_mods(NP),
    NP:pred => npred,
    NP:nform => (norm;meas_mod),
    NP:case => (dat;acc;obl).

np_me_arg(NP) :-
    nwh_np_arg(NP),
    NP:wkpro => ~weakpro,
    NP:subn => (sub_noun;sub_num;sub_tmp).

gen_np_arg(NP) :-
    np_arg(NP0),
    unify_except(NP0,NP,case),
    NP:redrel => no,
    NP:case => gen.

ap_arg(AP) :-
    AP => a,
    AP:sc => [],
    AP:e_deps => [].

nwh_ap_arg(AP) :-
    ap_arg(AP),
    AP:wh => nwh.

predm_adj(ADJ) :-
    ap_arg(ADJ),
    ADJ:wh => nwh,
    ADJ:adv => padv,
    ADJ:aform => nattr.

wh_predm_adj(ADJ) :-
    ap_arg(ADJ),
    ADJ:wh => ywh,
    ADJ:wh_reltmploc => ~hoe_hoe,
    ADJ:adv => padv,
    ADJ:aform => nattr.

max(X) :-
    X:slash =?> [],
    X:tags =?> [],
    X:e_deps =?> [],
    X:exs =?> [],
    X:sc =?> [],
    X:iexs =?> [],
    X:imexs =?> [].

max_imp(X) :-
    X => imp,
    max(X).

max_pred(X) :-
    X => pred,
    max(X).

max_modifier(X) :-
    X => modifier,
    max(X).

max_redrel(X) :-
    redrel_modifier(X),
    max(X).

max_ap(X) :-
    ap_arg(X),
    max(X),
    X:wh => nwh,
    X:deverbal => no,
    X:aform => nattr.

max_nadv_ap(X) :-
    max_ap(X),
%    X:agr => het & indef & sg, % not -e suffix
%    for -ende this is ok.
    X:adv => (nadv;padv).   % those that can't promote into N or ADV

max_predm(ADV) :-
    ADV => predm_adv,
    max(ADV).

max_pp(PP) :-
    PP => pp,
    PP:ld_pc => (n_pp;mod_pp;pred_pp),
    PP:pp_role => pp_obj1,
    PP:wh => nwh,
    PP:nnform => ~refl,
    max(PP).

max_vp(X) :-
    X0 => vp,
    max(X0),
    unify_except(X0,X,e_deps), % allow e_deps for vp
    X:vform => (om;te),
    no_missing_subj(X).

max_np(X) :-
    X => np,
    max(X),
    X:wh => nwh,
    X:case => ~gen,
    X:wkpro => ~weakpro,
    X:nform => (norm;meas_mod),
    X:bmeas => no,
    X:pred => npred.

max_pers_pn(X) :-
    max_pn(X),
    X:neclass => 'PER'.

max_pn(X) :-
    X => pn,
    max(X).

max_sv1(SV1) :-
    SV1 => sv1,
    SV1:haswh => no,
    SV1:can_be_max => yes,
    max(SV1).

max_sbar(X) :-
    X => sbar,
    X:ctype => ~c_van,
    X:e_deps => [],
    max(X).

max_root(X) :-
    X => root,
    %% X:needs_dip => no, often the quote is the previous sentence (or next)
    max(X).

max_advp(X) :-
    X => adv,
    X:wk => no,
    X:tmploc => ~tmp_n & ~meas_n & ~hoe_hoe & ~str_er & ~wk_er & ~hoe_hoe,
    X:wh_reltmploc => ~hoe_hoe,
    max(X).

optcomma(OPTCOMMA) :-
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    comma(COMMA).

optcomma_dash(OPTCOMMA) :-
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    comma_dash(COMMA).

optcomma_end(OPTCOMMA) :-
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    comma_end(COMMA).

comma_end(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => (komma;schuin_streep;uitroep;vraag;punt;ligg_streep).

comma(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => (komma;schuin_streep).

optcomma_hellip(OPTCOMMA) :-
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    comma_hellip(COMMA).

comma_hellip(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => (komma;hellip;schuin_streep).

hellip(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => hellip.

haak_open(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => haak_open.

haak_sluit(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => haak_sluit.

comma_dash(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => (komma;ligg_streep;schuin_streep).

dash(COMMA) :-
    COMMA => punct,
    COMMA:puncttype => ligg_streep.

comma_dubb(COMMA):-
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;schuin_streep).

dubb(DUBB) :-
    DUBB => punct,
    DUBB:puncttype => dubb_punt.

optdubb(OPTDUBB) :-
    OPTDUBB => optpunct,
    OPTDUBB:cat <=> DUBB,
    dubb(DUBB).

optend_punct(OPTPunct) :-
    optend_punct(OPTPunct,_).

optend_punct(OPTPunct,Type) :-
    OPTPunct => optpunct,
    OPTPunct:cat <=> Punct,
    end_punct(Punct,Type).

end_punct(Punct) :-
    end_punct(Punct,_).

end_punct(Punct,Type) :-
    Punct => punct,
    Punct:puncttype <=> Type,
    Punct:puncttype => (punt;uitroep;vraag;dubb_punt;punt_komma;hellip;komma).

optend_mod_punct(OPTPunct) :-
    OPTPunct => optpunct,
    OPTPunct:cat <=> Punct,
    Punct => punct,
    Punct:puncttype => (uitroep;vraag;hellip).

ql(PUNCT) :-
    PUNCT => punct,
    PUNCT:puncttype => aanhaal_links.

qr(PUNCT) :-
    PUNCT => punct,
    PUNCT:puncttype => aanhaal_rechts.

optql(OPTQL) :-
    OPTQL => optpunct,
    OPTQL:cat <=> Punct,
    ql(Punct).

optqr(OPTQL) :-
    OPTQL => optpunct,
    OPTQL:cat <=> Punct,
    qr(Punct).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% GRAMMAR RULES %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% VERBAL projections %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% EPS1 EPS2 feature for verbal projections solely used to reduce spurieus
%% ambiguities.
%% EPS1:
%% NEPS:    the verb-phrase ends with a lexical verb, so we can select
%%            anything to the right.
%% YEPS:    the verb-phrase ends with a gap. So we should not select modifier
%%          to the right that could be selected to the left also.
%%
%% EPS2:
%% YEPS:    as above, but in addition the verb-phrase has not selected any
%%          arguments to the left. So we should not now select an argument
%%          to the right that could also go left.
%% NEPS:    not so
%% EPS3:    yes: projection solely consisting of vgapped verb-cluster
%%
%% HASPRE   as for adjecives and nouns. The idea is to split the spline
%%          up in two parts. The lower part selects modifiers to the left,
%%          the higher part to the right. 
%% YPRE:    this node dominates modifiers to its left. 
%%
%% NPRE:    not so
%% HASPRE2  no: should not directly dominate sc element to the right
%%          yes: dominates sc element to the right

%% vc --> vb
grammar_rule(vc_vb,V1,[V]) :-
    V => vb,
    V:cj => ncj,  % rule out spurious [vc en vc] vs [vb en vb]
    V1:vbc => no,
    V1 => vc,
    V:inv => no,
    V:adj_agr => indef & sg & het,
    V:eps1 <=> V1:eps1,
    V:eps2 <=> V1:eps2,
    V:eps2 <=> V1:eps3,
    V1:pspslash => [],
    hd_structure(V,V1).

%% vc --> MOD vb
%% only in topic
%% "niet uit te sluiten valt dat ..."
%% "niet te verwachten valt dat .."
%% "niet te hopen is .."
grammar_rule(vc_mod_vb,V1,[MOD,V]) :-
    V => vb,
    V:vform => (pass_te;        % te slapen probeert hij niet
                                % *niet te slapen probeert hij
		inf;    	% helemaal geloven kun je zo'n verhaal niet
				% nauwkeurig gecontroleerd heb ik zijn verhaal
                psp),           % niet ontkend kan worden dat ...
    MOD => adv,
    MOD:redrel => no,
    MOD:wh => nwh,
    MOD:tmploc => ntmploc,
    MOD:modifies_v => yes,
    V:cj => ncj,  % rule out spurious [vc en vc] vs [vb en vb]
    V1 => vc,
    V1:cj => ~ncj, 
    V1:vbc => no,
    V:inv => no,
    V:adj_agr => indef & sg & het,
    V:eps1 <=> V1:eps1,
    V:eps2 <=> V1:eps2,
    V1:pspslash => [],
    V1:sel => to_topic,
    hd_mod_structure(V,MOD,V1).

%% vb --> v
grammar_rule(vb_v,V1,[V]) :-

    V => v,
    V:inv => no,
    V:cj => ncj,  % rule out spurious [vb en vb] vs [v en v]
    V1 => vb,
    V1:vbc => yes,
    V:eps1 <=> V1:eps1,
    V:eps2 <=> V1:eps2,
    V:eps3 <=> V1:eps3,
    hd_structure(V,V1).    


%% needed for: 'op te bellen zou zijn'
%%             'op gebeld zou zijn' 
grammar_rule(vb_part_v,VP, [Part, Inf]) :-
    VP => vb, Part => part, Inf => v,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> Inf:eps3,
    hd_part_structure(Inf,Part,VP).	



%% vproj --> vc
grammar_rule(vproj_vc,VP,[V]) :-
    vproj_vc_structure(VP,V).

vproj_vc_structure(VP,V) :-
    VP => vproj,
    V => vc,
    VP:sc <=> Sc,
    Nvc /=> vc,
    when(nonvar(Sc),
	 ( Sc = []
	 ; Sc = [Nvc|_]
	   )),
    VP:vc => yes,
    V:sel => no,
    V:fixed_dep => no,
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    VP:eps3 <=> V:eps3,
    VP:mf => [],
    VP:tags => [],
    V:pspslash => [],
    hd_structure(V,VP),
    
    V:dt => dt,
    V:vslash <=> Empty,
    NonEmpty => vslash,
    V:dt:cat <=> CAT,
    when(nonvar(Empty),
	 (   Empty = [],
	     dif(CAT,smain), dif(CAT,sv1)
	 ;   Empty = NonEmpty, dif(CAT,ssub)
	 )).


%% combination of:
%% vproj_vc
%% vp_arg_v(np)
%% vp_v_m_extra_pp [except vproj instead of vpx]
%% approximation of the real thing (that gives too many false hits)

%% how much would we loose if the same approximation was enforced
%% for relative clauses?

grammar_rule(vp_np_v_pp, VP, [ NP0, V, OPTCOMMA, Extra ]) :-
    vp_v_m_extra_pp_structure(VP,VP1,OPTCOMMA,Extra),
    NP0 => np,
    NP => np,
    NP0:sel <=> NP:sel,
    hd_m_extra_structure(NP0,Extra,NP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_np_structure(VP,NP,VP1),
    V:eps1 => no.

grammar_rule(vp_pp_v_pp, VP, [ PP0, V, OPTCOMMA, Extra ]) :-
    vp_v_m_extra_pp_structure(VP,VP1,OPTCOMMA,Extra),
    PP0 => pp,
    PP => pp,
    hd_m_extra_structure(PP0,Extra,PP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_pp_structure(VP,PP,VP1),
    V:eps1 => no.

grammar_rule(vp_np_v_sbar, VP, [ NP0, V, OPTCOMMA, Extra ]) :-
    vp_v_m_extra_sbar_structure(VP,VP1,OPTCOMMA,Extra),
    NP0 => np,
    NP => np,
    NP0:sel <=> NP:sel,
    hd_m_extra_structure(NP0,Extra,NP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_np_structure(VP,NP,VP1),
    V:eps1 => no.

%%% toen heb ik de kleding besteld , bestemd voor Rome
grammar_rule(vp_np_v_ap, VP, [ NP0, V, COMMA, Extra1 ]) :-
    Extra1 => a,
    Extra1:tmploc => ~wk_er & ~str_er & ~tmp & ~tmp_n & ~ld_dir & ~me, 
    unify_except_l(Extra1,Extra,[hstem,agr,tmploc]),
    vp_v_m_extra_ap_structure(VP,VP1,COMMA,Extra),
    NP0 => np,
    NP => np,
    NP0:sel <=> NP:sel,
    hd_m_extra_structure(NP0,Extra,NP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_np_structure(VP,NP,VP1),
    V:eps1 => no.

vp_v_m_extra_ap_structure(VP, V, COMMA, Extra  ) :-
    VP => vproj,
    VP:rightx => yes,
    V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    max_nadv_ap(Extra0),
    unify_except(Extra0,Extra,adv),
    Extra:adv => ~oadv & ~detadv,
    Extra:can_postn_with_cform => yes,
    Extra:can_postn => yes,
    comma(COMMA).

grammar_rule(vp_pred_v_pp, VP, [ NP0, V, OPTCOMMA, Extra ]) :-
    vp_v_m_extra_pp_structure(VP,VP1,OPTCOMMA,Extra),
    NP0 => pred,
    NP => pred,
    NP0:sel <=> NP:sel,
    hd_m_extra_structure(NP0,Extra,NP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_pred_structure(VP,NP,VP1),
    V:eps1 => no.

grammar_rule(vp_pred_v_sbar, VP, [ NP0, V, OPTCOMMA, Extra ]) :-
    vp_v_m_extra_sbar_structure(VP,VP1,OPTCOMMA,Extra),
    NP0 => pred,
    NP => pred,
    NP0:sel <=> NP:sel,
    hd_m_extra_structure(NP0,Extra,NP),
    vproj_vc_structure(VP1,V),
    vp_arg_v_pred_structure(VP,NP,VP1),
    V:eps1 => no.

vp_v_m_extra_pp_structure(VP, V, OPTCOMMA, Extra  ) :-
    VP => vproj,
    VP:rightx => yes,
    V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    pp_modifier(Extra),
    Extra:pp_er => no,
%    Extra:sel => to_right,
    optcomma(OPTCOMMA).

vp_v_m_extra_sbar_structure(VP, V, OPTCOMMA, Extra  ) :-
    VP => vproj,
    VP:rightx => yes,
    V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    max_sbar(Extra),
    Extra:ctype => (c_compare_np;c_alsof;c_mod_np),
    optcomma(OPTCOMMA).

%%%%%
%%%%%
%%%  NP V en NP
%%% combination of NP --> NP en NP
%%%                VP --> NP VP
%%%

%% cdb/289 cdb/854 cdb/1313 cdb/3287 cdb/4191 cdb/4945 cdb/5645 cdb/6069 cdb/6401
%%%% should be combined with extraposition of pp too:
%%%% cdb/2544 "omdat er geen geld meer is voor de scholen maar wel veel geld voor wapens"
%%%% left NP sometimes already conjunction cdb/7076
grammar_rule(vp_np_v_en_np,VP, [NP, V, OPTCOMMA, CLIST]) :-
    optcomma(OPTCOMMA),
    vp_arg_v_np_structure(VP,NPS,V1),
    vproj_vc_structure(V1,V),

    %% do this only for VPs at edge of surface V
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,
    NPS:cj => ~no_crd,

    start_coord_name_en_structure(np,NPS,NP,CLIST),
    CLIST:cform <=> CFORM,
    dif(CFORM,om),
    CLIST:within_word => no.

%    CLIST:etc => no.

%% cdb/359 cdb/5689
grammar_rule(vp_pred_v_en_pred,VP, [NP, V, OPTCOMMA, CLIST]) :-
    optcomma(OPTCOMMA),
    vp_arg_v_pred_structure(VP,NPS,V1),
    vproj_vc_structure(V1,V),

    %% do this only for VPs at edge of surface V
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,

    NPS:cj => ~no_crd,
    start_coord_name_en_structure(pred,NPS,NP,CLIST),
    CLIST:within_word => no.
%    CLIST:etc => no.

grammar_rule(vp_pp_v_en_pp,VP, [NP, V, OPTCOMMA, CLIST]) :-
    optcomma(OPTCOMMA),
    vp_arg_v_pp_structure(VP,NPS,V1),
    vproj_vc_structure(V1,V),

    %% do this only for VPs at edge of surface V
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,

    NPS:cj => ~no_crd,
    start_coord_name_en_structure(pp,NPS,NP,CLIST),
    CLIST:within_word => no.
%    CLIST:etc => no.



no_vslash(VP) :-
    VP:vslash => [],
    VP:subj => np.
    %% VP:subj:prs => ~invje.  % ??? ... maar betalen zul je!

%% vp --> vpx
grammar_rule(vp_vpx,VP,[V]) :-
    VP => vp,
    V => vpx,
    V:cj => ncj,
    no_vslash(V),
    VP:mf <=> V:mf,
    hd_structure(V,VP). 

%% vpx --> vproj
grammar_rule(vpx_vproj,VP,[V]) :-
    VP => vpx,
    V => vproj,
    VP:eps3 <=> V:eps3,
    V:mf <=> VP:mf,
    VP:rightm => no, % should not have right modifier spur.amb.
    hd_structure(V,VP). 

/*
grammar_rule(vpx_vproj_extra_np,VP,[V,OPTCOMMA,NP]) :-
    optcomma(OPTCOMMA),
    VP => vpx,
    VP:vform => fin,
    V => vproj,
    V:mf <=> VP:mf,
    V:eps2 => no,
    V:rightx => no,
    VP:rightm => no, % should not have right modifier spur.amb.
    NP => np,
    NP:sel => to_left, % !
    NP:redrel => no,
    hd_comp_structure(V,NP,VP).
*/

%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% VP rules %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%

%% vp/v --> vproj/v
grammar_rule(v2_vp_vproj,VP,[V]) :-
    VP => v2_vp,
    V => vpx,
    V:e_deps => [],
    VP:mf <=> V:mf,
    V:vform => fin,
    hd_structure(V,VP).

grammar_rule(v2_vp_dubb_vproj,VP,[OPT,V]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    dubb(OPT),
    VP => v2_vp,
    V => vpx,
    V:e_deps => [],
    VP:mf <=> V:mf,
    V:vform => fin,
    hd_structure(V,VP). 

%% vp --> om vproj
grammar_rule(vp_om_vpx,VP,[Comp,V]):-
    VP => vp,
    VP:vform => om,
    VP:tags <=> V:tags,
    VP:subj <=> V:subj,  % added Aug 29, 2017...
    Comp => comp,
    V => vpx,
    VP:mf <=> V:mf,
    no_vslash(V),
    VP:pro_deps <=> V:pro_deps,  % added GvN to obtain control in "beloof om"..
    V:e_deps => [],
    cmp_body_structure(Comp,V,VP).

grammar_rule(mod_om_vpx,VP,[Comp,V]):-
    VP => modifier,
    VP:mcat => mcat_vp,
    VP:wh => nwh,
    VP:eps => no,
    V:subj <=> NP,


    % unrealized NP:
    NP:mexs => [],
    NP:hstem => [],
    NP:nform => norm,
    NP:subn => sub_noun,
    NP:case => (obl;acc;nom),  % don't use obj2 here
    NP:dt => [], % !
    NP:allows_drop => yes,

    Comp => comp,
    Comp:e_deps => [],
    V => vpx,
    V:vform => (~inf & ~psp), %% cf sbar(vpx) below which can be raised into mod
    no_vslash(V),
    V:e_deps => [],
    cmp_body_structure(Comp,V,VP).

%% rel --> om vproj/NP
%% een boek om te zoenen
%% niemand om mee te spelen
%%
%% todo: mf value?
grammar_rule(rel_om_vpx,REL,[Comp,V]):-
    REL => rel,
    REL:relform => relform_inf,
    REL:tmploc => non_adv,
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_om,
    V0 => vpx,
    V => vpx,
    V0:haswh => no,
    no_vslash(V),
    unify_except(V0,V,slash),
    cmp_body_structure(Comp,V0,REL),
    V:e_deps => [],
    V:slash <=> [NP],
    NP => np,
    NP:allows_drop => yes,
    NP:dt => [].

%% geen touw aan vast te knopen
%% geen beweging in te krijgen
%% geen land mee te bezeilen
%% 
%% nooit bij stilgestaan dat ...
%% nooit over nagedacht ...
%%
%% nooit bij stilstaan !
%% niet aan denken !
%%
%% om -> max_xp(om_rel) and rel_om_vpx
grammar_rule(max_xp(vpx),Max,[Ecomp,V]) :-
    Max => max,
    Max:max_type => t_xp,
    V => vpx,
    V:haswh => no,
    V:vform => (pass_te;psp;inf),
    no_vslash(V),
    V:e_deps => [],
    V:slash <=> [NP],
    Ecomp => ecomp,
    NP => np,
    NP:e_deps => [],
    NP:nform => er,
    NP:pred => npred,
    NP:allows_drop => yes,
    NP:dt => [], %!
    unify_mods(NP),
    unify_except(V,V1,slash),
    V1:subj <=> Subj,
    Subj:hstem => [],
    Subj:dt => [],
    hd_structure(V1,Max).

%% dat is om te lezen
grammar_rule(pred_inf_rel,PRED,[REL]) :-
    REL => rel,
    REL:relform => relform_inf,
    REL:tmploc => non_adv,
    PRED => pred,
    PRED:pcat => om_pred,
    PRED:redrel => no,
    hd_structure(REL,PRED).

%% vproj --> ARG vproj
grammar_rule(vp_arg_v(np),VP, [Arg, V] ) :-
    vp_arg_v_np_structure(VP,Arg,V).

%% vproj --> ARG hellip vproj
%% ik kocht ... kaartjes voor Hors Satan !
grammar_rule(vp_hellip_arg_v(np),VP, [Punct, Arg, V] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    hellip(Punct),
    vp_arg_v_np_structure(VP,Arg,V).

grammar_rule(vp_arg_comma_v(np),VP, [Arg, COMMA, V] ) :-
    vp_arg_v_np_structure(VP,Arg,V),
    Arg:redrel => yes,
    comma_hellip(COMMA).

vp_arg_v_np_structure(VP,Arg,V) :-
    Arg => np,
    vp_arg_v_structure(V,Arg,VP),
    VP:hasmod <=> V:hasmod,
    VP:eps1 <=> V:eps1.
    %% unify_mods(Arg), wrong for er_er subcat frame

grammar_rule(vp_arg_v(pred),VP, [Arg, V] ) :-
    vp_arg_v_pred_structure(VP,Arg,V).

grammar_rule(vp_hellip_arg_v(pred),VP, [Punct, Arg, V] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    hellip(Punct),
    vp_arg_v_pred_structure(VP,Arg,V).

vp_arg_v_pred_structure(VP,Arg,V) :-
    Arg => pred,
    unify_mods(Arg),
    vp_arg_v_structure(V,Arg,VP),
    VP:hasmod <=> V:hasmod,
    VP:eps1 <=> V:eps1.

grammar_rule(vp_arg_v(pp),VP, [Arg, V] ) :-
    vp_arg_v_pp_structure(VP,Arg,V).

grammar_rule(vp_hellip_arg_v(pp),VP, [Punct, Arg, V] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    hellip(Punct),
    vp_arg_v_pp_structure(VP,Arg,V).

vp_arg_v_pp_structure(VP,Arg,V) :-
    Arg => pp,
    vp_arg_v_structure(V,Arg,VP),
    V:hasmod <=> Arg:vhasmod,
    V:vc <=> Arg:vc,
    VP:eps1 <=> Arg:veps:out,
    V:eps1 <=> Arg:veps:in.

grammar_rule(vp_arg_v(adv),VP, [Arg, V] ) :-
    vp_arg_v_adv_structure(VP,Arg,V).

grammar_rule(vp_hellip_arg_v(adv),VP, [Punct, Arg, V] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    hellip(Punct),
    vp_arg_v_adv_structure(VP,Arg,V).

vp_arg_v_adv_structure(VP,Arg,V) :-
    Arg => adv,
    Arg:hstem <=> HSTEM,
    Tmploc => (loc;ld_dir;me),
    Arg:tmploc <=> NormTmploc,
    when( ?=(HSTEM,graag),
	  ( HSTEM == graag
	    ;
	    Tmploc = NormTmploc
	    )
	),
    vp_arg_v_structure(V,Arg,VP),
    VP:hasmod <=> V:hasmod,
    VP:eps1 <=> V:eps1.

grammar_rule(vp_arg_v(fixed_pred),VP, [Arg, V] ) :-
    Arg => fixed_part,
    Arg:cat => pred,
    vp_arg_v_structure(V,Arg,VP),
    VP:hasmod <=> V:hasmod,
    VP:eps1 <=> V:eps1.

vp_arg_v_structure(V,Arg,VP) :-
    VP => vproj, V => vproj,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:vc <=> V:vc,
    V:haspre => yes,
    add_mf(VP,Arg,V),
    Arg:sel =?> to_left,
    allow_wh_in_situ(Arg,VP),
    hd_comp_structure(V,Arg,VP). 

vp_v_arg_structure(V,Arg,VP,OPTCOMMA) :-
    VP => vproj, V => vproj,
    optcomma(OPTCOMMA),
    VP:rightx => yes,
    VP:eps3 <=> V:eps3,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:haspre2 => yes,
    VP:mf <=> V:mf,
    hd_comp_structure(V,Arg,VP).

grammar_rule(vp_v_komma_arg(np_heavy),VP, [V, OPTCOMMA, Arg] ) :-
%    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Arg => np,
    Arg:sel => to_right,
    Arg:redrel => yes,
    Arg:nform => (norm;meas_mod),
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA ),
    allow_wh_in_situ(Arg,VP),
    V:eps2 => no.

grammar_rule(vp_v_komma_arg(pred_heavy),VP, [V, OPTCOMMA, Arg] ) :-
%    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Arg => pred,
    Arg:sel => to_right,
    Arg:redrel => yes,
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA),
    allow_wh_in_situ(Arg,VP),
    V:eps2 => no.

grammar_rule(vp_v_komma_arg(pred_als),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => pred,
    Arg:sel => to_right,
    Arg:redrel => no,
    Arg:pcat => (zoals_pred;als_pred),
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA),
    allow_wh_in_situ(Arg,VP),
    V:eps2 => no.

grammar_rule(vp_v_komma_arg(adv),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => adv,
    Arg:sel => to_right,
    Arg:redrel => yes,
    Arg:tmploc => (loc;ld_dir;me),
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA),
    V:eps2 => no.

grammar_rule(vp_v_komma_arg(pp),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => pp,
    Arg:sel => to_right,
    Arg:slash => [],		% added GvN
				% daar(i) heb ik niet aan(i) gedacht
				% *daar(i) heb ik niet gedacht aan(i)
    Arg:pp_er => no,           % *ik heb niet gedacht daaraan
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA),
    allow_wh_in_situ(Arg,VP),
    V:eps2 => no.

grammar_rule(vp_v_komma_arg(vp),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => vp,
    Arg:haswh => no,
    Arg:sel => to_right,
    Arg:vform => (om;te),
    Arg:tags => [],  % perhaps inherit?
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA).

grammar_rule(vp_v_komma_arg(sbar),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => sbar,
    Arg:tags => [],  % perhaps inherit?
    Arg:sel => to_right,
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA).

% for er_er only
grammar_rule(vp_v_komma_arg(rel),VP, [V, OPTCOMMA, Arg] ) :-
    Arg => rel,
    Arg:sel => to_right,
    vp_v_arg_structure(V,Arg,VP,OPTCOMMA).

%% vc --> part vc
grammar_rule(vc_part_vc,VP, [Part, Inf]) :-
    VP => vc, Part => part, Inf => vc,
    Inf:vbc => yes,  % Inf must not be vc->vb, otherwise particle should
                      % attach to vb directly
    Inf:vslash => [],
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> Inf:eps3,
    VP:pspslash <=> Inf:pspslash,
    hd_part_structure(Inf,Part,VP).	

%% introduce psp left of verb-cluster, keep track of it using
%% the feature pspslash.
%% DONE: add the possibility that 'te-V passives' go here too:
%% dat ik zou moeten zijn op te bellen
%% "that i should must be up to call" = that I should be able to be phoned
%%        op te bellen zou moeten zijn
%%        te bereiken zou moeten zijn
%%        zou moeten zijn te bereiken
%% DONE: aan-het-inf as well!
%% dat ik aan het slapen was

grammar_rule(v_psp_v,VP, [Psp, V]) :-

    % Noord-Nederlands
    % VP => vproj,
    % VP:mf => [],
    % VP:tags => [],

    % Vlaams:
    VP => vc,
    VP:pspslash => [],
    VP:psprule => yes,

    Psp => vb, V => vc,
    VP:eps1 => no,
    VP:eps2 => no,
    Psp:vslash => [],
    Psp:inv => no,
    Psp:vform => (psp;aan_het;uit;pass_te;op),
    V:pspslash => vc,
    V:pspslash:sel => to_left,
    Psp:vform <=>       V:pspslash:vform,
    Psp:tpart <=>       V:pspslash:tpart,
    Psp:sc <=>          V:pspslash:sc,
    Psp:dt <=>          V:pspslash:dt,
    Psp:hebben_zijn <=> V:pspslash:hebben_zijn,
    Psp:slash <=>       V:pspslash:slash,
    Psp:subj <=>        V:pspslash:subj,
    Psp:e_deps <=>      V:pspslash:e_deps,
    Psp:pro_deps <=>    V:pspslash:pro_deps,
    Psp:parts <=>       V:pspslash:parts,
    Psp:apps <=>        V:pspslash:apps,
    Psp:capps <=>       V:pspslash:capps,
    Psp:dets <=>        V:pspslash:dets,
    Psp:cdets <=>       V:pspslash:cdets,
    Psp:mods <=>        V:pspslash:mods,
    Psp:cmods <=>       V:pspslash:cmods,
    Psp:predms <=>      V:pspslash:predms,
    Psp:cpredms <=>     V:pspslash:cpredms,
    Psp:passive <=>     V:pspslash:passive,
    Psp:ccat0 <=>       V:pspslash:ccat0,
    Psp:ccat <=>        V:pspslash:ccat,
    Psp:parts => [],
    V:ccat0 <=> Cat,
    projected_hd_structure(V,[],[],[],[],[],[],[Psp],[],[],[],VP,Cat).

/*
%% vc/psp --> v
%% v_v_v except the argument v has been moved upward:
%% dat ik de trein gemist wil hebben
%% that I the train missed want have = that I want to have missed the train
grammar_rule(v_v_pspgap,VP,[V]) :-
    VP => vc, V => v, Inf => vc,
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    Inf:vslash => [],
    Inf:vform => (psp;aan_het;uit;pass_te;op),
    V:vslash => [],
    V:inv => no,
    Inf:exs => [],
    Inf:mexs => [],
    hd_comp_structure(V,Inf,VP),
    VP:pspslash:sel => to_left,
    VP:pspslash <=> Inf.
*/
%% changed V => v into V => vb for
%% "omdat ik hem iets te eten voorzet"
%% remove V:vslash => [] for
%% "ik zet hem iets te eten voor"
grammar_rule(v_v_pspgap,VP,[V]) :-
    VP => vc, V => vb, Inf => vc,
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    Inf:vslash => [],
    Inf:vform => (psp;aan_het;uit;pass_te;op),
%    V:vslash => [],
    V:inv => no,
    Inf:exs => [],
    Inf:mexs => [],
    hd_comp_structure(V,Inf,VP),
    VP:pspslash:sel => to_left,
    VP:pspslash <=> Inf.

%% vc --> v vc
grammar_rule(v_v_v,VP, [V, Inf] ) :-	
    VP => vc, V => v, Inf => vc,
    VP:eps1 => no,
    VP:eps2 => no,
    V:psprule <=> Inf:psprule,  % prevent spur amb in
                                % "er moet meer gelachen worden"
    Inf:vslash => [],
    Inf:sel => to_right,
    Inf:vform => ~fin,
    V:inv => no,
    VP:pspslash <=> Inf:pspslash,
    hd_comp_structure(V,Inf,VP).

%% de invloed die ik heb ( gehad )
grammar_rule(v_v_bracketed_v,VP, [V, OPEN, Inf, CLOSE] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    VP => vc, V => v, Inf => vc,
    VP:eps1 => no,
    VP:eps2 => no,
    V:psprule <=> Inf:psprule,  % prevent spur amb in
                                % "er moet meer gelachen worden"
    Inf:vslash => [],
    Inf:sel => to_right,
    V:inv => no,
    Inf:vform => ~fin,
    VP:pspslash <=> Inf:pspslash,
    hd_comp_structure(V,Inf,VP).

grammar_rule(v_bracketed_v_v,VP, [OPEN, V, CLOSE, Inf] ) :-	
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    VP => vc, V => v, Inf => vc,
    VP:eps1 => no,
    VP:eps2 => no,
    Inf:vslash => [],
    Inf:sel => to_right,
    V:inv => no,
    Inf:vform => ~fin,
    VP:pspslash <=> Inf:pspslash,
    hd_comp_structure(V,Inf,VP).

%% "modal inversion"
%% omdat ik slapen[+inf,+lex] wil[+modal,+fin]
%% *omdat ik zou slapen willen ==> head must be finite verb
%% *omdat ik kunnen slapen wil ==> directly select vb...; complicated since
%%                                 subcat has vc of course.
%%                                 [ vb: dat ik jou opbellen moet ]
%%
grammar_rule(modal_inv,VP,[InfVb,V]) :-
    VP => vc, V => v, InfVb => vb,
    Inf => vc,
    unify_vc_vb(InfVb,Inf),
    VP:eps1 => no,
    VP:eps2 => no,
    Inf:vslash => [],
    VP:pspslash => [],
    hd_comp_structure(V,Inf,VP),
    %% special for this rule:
    Inf:vform => inf,
    InfVb:inv => no,
    V:inv => no,
    InfVb:adj_agr => indef & sg & het,
    V:vslash => [],
    V:vform => fin.


%% vb[ahi] --> aan_het vb[inf]
%% I'm unsure about this. There appears to be a possibility to have
%% *some* arguments selected inside the aan-het-vp. But mostly that
%% sounds very awkward. If the rule were to be vp --> aan_het vproj
%% then, in addition to the overgeneration problem, we'd also need
%% a vproj --> vp[aan_het] vproj rule, since normal vp's go to the right
%% only, whereas aan-het vp's prefer to go to the left (perhaps this
%% indicates their nominal nature, or their raising nature?).
%% %%In addition, there is
%% %%"dat ik de kinderen op aan het bellen ben"
%% %%which we currently cannot handle.
%% NOW WE DO!

grammar_rule(aan_het_v,VP, [Aanhet, Inf] ) :-
    Aanhet => aan_het_comp, 
    aan_het_structure(VP,Aanhet,Inf),
    VP:vform => aan_het.

grammar_rule(aan_het_n_v,VP, [Aanhet, N, Inf] ) :-
    Aanhet => aan_het_comp, 
    aan_het_structure(VP0,Aanhet,Inf),
    VP0:vform => aan_het,
    VP0:parts => [],  % **dat ik op aan het de klanten bellen ben
    np_n_structure(NP,N),
    N:lex => yes,
    VP => v,
    hd_comp_structure(VP0,NP,VP).

aan_het_structure(VP,Aanhet,Inf) :-
    structure,
    VP => v, Inf => vb,
    unify_mods(Aanhet),
    unify_vb_v(VP0,Inf),
    unify_except_l(VP0,VP,[ccat0,ccat,dt,vform]),
    Inf:vform => inf,
    xy_dep_dt(Aanhet,Inf,VP,ahi,cmp,body),
    VP:dt:mod => [],
    VP:dt:app => [],
    VP:dt:det => [],
    VP:dt:predm => [],
    Inf:ccat0 <=> Inf:ccat.

grammar_rule(op_v,VP, [Aanhet, Inf] ) :-
    VP => v, Aanhet => op_comp, Inf => vb,
    VP:vform => op,
    comp_v_structure(VP,Aanhet,Inf).
    
grammar_rule(uit_v,VP, [Aanhet, Inf] ) :-
    Aanhet => uit_comp,
    aan_het_structure(VP,Aanhet,Inf),
    Inf:parts => [],
    VP:vform => uit.

%    VP => v, Aanhet => uit_comp, Inf => vb,
%    VP:vform => uit,
%    comp_v_structure(VP,Aanhet,Inf).

comp_v_structure(VP,Aanhet,Inf) :-
    structure,
    unify_mods(Aanhet),
    unify_mods(Inf),
    unify_vb_v(VP0,Inf),
    unify_except_l(VP0,VP,[ccat0,ccat,dt,vform,cmods,mods,capps,apps,
                           cdets,dets,cpredms,predms]),
    Inf:vform => inf,
    Inf:sc => [],
    Inf:slash => [],
    Inf:parts => [],
    xy_dep_dt(Aanhet,Inf,VP,ahi,cmp,body),
    non_hd_dt_principle(VP,ahi).

%% vproj --> MOD vproj
grammar_rule(vp_mod_v, VP, [ Mod, COMMA, V ] ) :-
    optcomma(COMMA),
    vp_mod_v_structure(VP,Mod,V),
    VP:hasmod => yes,
    V:realized_comma <=> COMMA:realized,
    Mod:sel => to_left.

grammar_rule(vp_c_mod_c_v, VP, [ CommaL, Mod, CommaR, V ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    comma(CommaL),
    optcomma(CommaR),
    vp_mod_v_structure(VP,Mod,V).

%% cdbl 4646
grammar_rule(vp_c_rootbar_c_v, VP, [ CommaL, Mod, CommaR, V ] ) :-
    comma(CommaL),
    comma(CommaR),
    Mod => rootbar,
    vp_mod_xp_v_structure(VP,Mod,V).

%% cdbl 1279
%% om , hoe kan het ook anders , ...
%% om , ik kan het niet anders zeggen , ...
grammar_rule(vp_c_whq_c_v, VP, [ CommaL, Mod, CommaR, V ] ) :-
    comma(CommaL),
    comma(CommaR),
    max_root(Mod),
    Mod:needs_dip => no,
    vp_mod_xp_v_structure(VP,Mod,V).

/* should be tag-nucl???
%% we moeten , jawel , arriveren
grammar_rule(vp_c_tag_c_v, VP, [ CommaL, Mod, CommaR, V ] ) :-
    comma(CommaL),
    comma(CommaR),
    Mod => tag,
    Mod:adv => no,  % use ordinary rules for adverbs
    vp_mod_xp_v_structure(VP,Mod,V).
*/

vp_mod_xp_v_structure(VP,Mod,V) :-
    VP => vproj, V => vproj, 
    add_mf(VP,Mod,V),
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    VP:eps3 <=> V:eps3,
    VP:haspre => yes,
    V:haspre => yes,
    V:haspre2 => no,
    Mod:modifies_v =?> yes,
    hd_mod_structure(V,Mod,VP).

vp_mod_v_structure(VP,Mod,V) :-
    Mod => modifier,
    vp_mod_xp_v_structure(VP,Mod,V),
    allow_wh_in_situ(Mod,VP).

%% vproj --> PREDM vproj
vp_predm_v_structure(VP,Mod,V) :-
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    VP:eps3 <=> V:eps3,
    VP:haspre => yes,
    V:haspre => yes,
    V:haspre2 => no,
    add_mf(VP,Mod,V),
    VP:hasmod => yes,
    hd_predm_structure(V,Mod,VP).

vp_predm_comma_v_structure(VP,Mod,CommaR, V) :-
    VP => vproj, V => vproj, 
    optcomma(CommaR),
    CommaR:realized <=> V:realized_comma,
    vp_predm_v_structure(VP,Mod,V).

vp_comma_predm_comma_structure(VP,CommaL,Mod,CommaR,V) :-
    VP => vproj, V => vproj, 
    comma(CommaL),
    optcomma(CommaR),
    VP:realized_comma => yes, % don't use this if komma consumable by mother
    V:realized_comma <=> CommaR:realized,
    vp_predm_v_structure(VP,Mod,V).

vp_bracketed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optend_mod_punct(END),
    VP => vproj, V => vproj, 
    optcomma(CommaR),
    V:realized_comma <=> CommaR:realized,
    vp_predm_v_structure(VP,Mod,V).

vp_dashed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => ligg_streep,
    CLOSE => punct, CLOSE:puncttype => ligg_streep,
    optend_mod_punct(END),
    VP => vproj, V => vproj, 
    optcomma(CommaR),
    V:realized_comma <=> CommaR:realized,
    vp_predm_v_structure(VP,Mod,V).

grammar_rule(vp_predm_v, VP, [ Mod, CommaR, V ] ) :-
    Mod => predm_adv,
    vp_predm_comma_v_structure(VP,Mod,CommaR,V).

grammar_rule(vp_predm_adj_v, VP, [ Mod, CommaR, V ] ) :-
    predm_adj(Mod),
    vp_predm_comma_v_structure(VP,Mod,CommaR,V).

grammar_rule(vp_predm_pp_v, VP, [ Mod, CommaR, V ] ) :-
    pp_predm(Mod),
    vp_predm_comma_v_structure(VP,Mod,CommaR,V).

grammar_rule(vp_predm_v_comma, VP, [ CommaL, Mod, CommaR, V ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Mod => predm_adv,
    vp_comma_predm_comma_structure(VP,CommaL,Mod,CommaR,V).

grammar_rule(vp_predm_adj_v_comma, VP, [ CommaL, Mod, CommaR, V ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    predm_adj(Mod),
    vp_comma_predm_comma_structure(VP,CommaL,Mod,CommaR,V).
    
grammar_rule(vp_predm_pp_v_comma, VP, [ CommaL, Mod, CommaR, V ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    pp_predm(Mod),
    vp_comma_predm_comma_structure(VP,CommaL,Mod,CommaR,V).

grammar_rule(vp_bracketed_predm_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    Mod => predm_adv,
    vp_bracketed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).

grammar_rule(vp_bracketed_predm_adj_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    predm_adj(Mod),
    vp_bracketed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).

grammar_rule(vp_bracketed_predm_pp_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    pp_predm(Mod),
    vp_bracketed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).
    
grammar_rule(vp_dashed_predm_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    Mod => predm_adv,
    vp_dashed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).

grammar_rule(vp_dashed_predm_adj_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    predm_adj(Mod),
    vp_dashed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).

grammar_rule(vp_dashed_predm_pp_v, VP, [OPEN,Mod,END,CLOSE,CommaR,V ] ) :-
    pp_predm(Mod),
    vp_dashed_predm_v_structure(VP,OPEN,Mod,END,CLOSE,CommaR,V).
    
grammar_rule(vp_v_predm_pp, VP, [ V, PP ] ) :-
    VP => vproj, V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:haspre => no,
    VP:mf <=> V:mf,
    V:eps1 => no,
    VP:rightx => yes,
    pp_predm(PP),
    hd_predm_structure(V,PP,VP).

grammar_rule(vp_v_predm_ap, VP, [ V, ADJ ] ) :-
    VP => vproj, V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:haspre => no,
    VP:mf <=> V:mf,
    V:eps1 => no,
    VP:rightx => yes,
    predm_adj(ADJ),
    ADJ:avform => ~avform_ppart,  %% too many false hits
    hd_predm_structure(V,ADJ,VP).

grammar_rule(vp_v_predm_adv, VP, [ V, COMMA, ADJ ] ) :-
    optcomma(COMMA),
    VP => vproj, V => vproj,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
    VP:haspre => no,
    VP:mf <=> V:mf,
    V:eps1 => no,
    VP:rightx => yes,
    ADJ => predm_adv,
    hd_predm_structure(V,ADJ,VP).

%% vproj --> vproj MOD
%% two separate rules; otherwise variant with komma can't be used
%% in sentences such as:
%% de tarieven moeten omlaag , volgend jaar
grammar_rule(vp_v_mod, VP, [ V, Mod ] ) :-
    VP => vproj, V => vproj, Mod => modifier,
    VP:rightx => yes,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:eps3 <=> V:eps3,
%    VP:haspre => no,
    haspreno(VP),
    VP:mf <=> V:mf,
    Mod:wh => nwh,
    Mod:eps <=> V:eps1,  % if Mod can go the left too, then Mod:eps should not
                         % allow this for modifiers that can go both ways
    Mod:sel => to_right,
    Mod:modifies_v => yes,
    hd_mod_structure(V,Mod,VP).

grammar_rule(vpx_v_mod, VP, [ V, Mod ] ) :-
    VP => vpx, V => vpx, Mod => modifier,
    VP:rightx => yes,
    V:rightm => yes,  % spur amb
    VP:mf <=> V:mf,
    V:cj => ncj,
    allow_wh_in_situ(Mod,VP),
    Mod:sel => to_right,
    Mod:modifies_v => yes,
    hd_mod_structure(V,Mod,VP).

grammar_rule(vp_v_extra, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => comparativep,
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:rightx => yes,
    Extra:compar_form => ~cf_e_als,
    VP:mf <=> V:mf,
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_extra_pred, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => pred,
    V:cj => ncj,
    VP:rightx => yes,
    VP:eps3 <=> V:eps3,
    Extra:pcat => als_pred,
    VP:mf <=> V:mf,
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_extra_pp, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => pp,
    V:cj => ncj,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,
    VP:mf <=> V:mf,
    Extra:slash => [],
    Extra:sel => to_right,
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_extra_rel, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => rel,
    VP:eps3 <=> V:eps3,
    VP:rightm => no, %% hack to reduce ambiguities
    VP:mf <=> V:mf,
    VP:rightx => yes,
    V:cj => ncj,
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_bracketed_extra_rel, VP, [ V, OPEN, Extra, OPTPUNCT, CLOSE ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vpx, V => vpx, Extra => rel,
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    VP:mf <=> V:mf,
    VP:rightx => yes,
    optend_mod_punct(OPTPUNCT),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_sbar, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => sbar,
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:mf <=> V:mf,
    VP:rightx => yes,
    VP:rightm => no, %% hack to reduce ambiguities
    Extra:slash => [],
    Extra:tags => [],  % perhaps inherit
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_inf, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, 
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:mf <=> V:mf,
    VP:rightm => no, %% hack to reduce ambiguities
    VP:rightx => yes,
    mod_vp(Extra),
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vp_v_m_extra, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, Extra => rel,
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:mf <=> V:mf,
    VP:rightx => yes,
    VP:rightm => no, %% hack to reduce ambiguities
    optcomma(OPTCOMMA),
    hd_m_extra_structure(V,Extra,VP).

%% ?? is this worth it
grammar_rule(vp_v_m_extra_vp, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx, V => vpx, 
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:rightx => yes,
    mod_om_vp(Extra),
    VP:mf <=> V:mf,
    VP:rightm => no, %% hack to reduce ambiguities
    optcomma(OPTCOMMA),
    hd_m_extra_structure(V,Extra,VP).

mod_om_vp(Extra) :-
    mod_vp(Extra),
    Extra:vform => om,
    Extra:ctype => c_om.

mod_vp(Extra) :-
    Extra => vp,
    Extra:tags => [], % perhaps inherit
    Extra:slash => [],
    Extra:haswh => no,
    Extra:vform => (om;te),
    no_missing_subj(Extra).

no_missing_subj(Extra) :-
    Extra:subj <=> SubjNP,        % unrealized SubjNP:
    SubjNP:mexs => [],
    SubjNP:hstem => [],
    SubjNP:nform => norm,
    SubjNP:subn => sub_noun,
    SubjNP:case => (obl;acc;nom),  % don't use obj2 here
    SubjNP:dt => [], % !
    SubjNP:allows_drop => yes.

grammar_rule(vp_v_bracketed_m_extra, VP, [V,OPEN,Extra,OPTPUNCT,CLOSE]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vpx, V => vpx, Extra => rel,
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:rightx => yes,
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    VP:mf <=> V:mf,
    optend_mod_punct(OPTPUNCT),
    hd_m_extra_structure(V,Extra,VP).

%% ?? is this worth it
grammar_rule(vp_v_bracketed_m_extra_vp, VP, [V,OPEN,Extra,OPTPUNCT,CLOSE]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vpx, V => vpx, 
    VP:eps3 <=> V:eps3,
    V:cj => ncj,
    VP:rightx => yes,
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optend_mod_punct(OPTPUNCT),

    mod_om_vp(Extra), 
    
    VP:mf <=> V:mf,
    hd_m_extra_structure(V,Extra,VP).

%% vproj --> vproj , MOD
grammar_rule(vp_v_komma_mod, VP, [ V, COMMA, Mod ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vproj, V => vproj, Mod => modifier,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,
    VP:mf <=> V:mf,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:haspre => no,
    comma(COMMA),
    Mod:wh => nwh,
    Mod:modifies_v => yes,
    hd_mod_structure(V,Mod,VP).

%% vproj --> vproj , MOD
grammar_rule(vpx_v_komma_mod, VP, [ V, COMMA, Mod ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vpx, V => vpx, Mod => modifier,
    V:cj => ncj,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,
    VP:mf <=> V:mf,
    comma(COMMA),
    V:rightm => yes,
    Mod:wh => nwh,
    Mod:modifies_v => yes,
    hd_mod_structure(V,Mod,VP).

grammar_rule(vp_v_komma_predm, VP, [ V, COMMA, Mod ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    VP => vproj, V => vproj,
    VP:eps3 <=> V:eps3,
    VP:rightx => yes,
    predm_adj(Mod),
    VP:mf <=> V:mf,
    VP:eps1 => no,
    VP:eps2 => no,
    VP:haspre => no,
    comma(COMMA),
    hd_predm_structure(V,Mod,VP).

%% main clause syntax 
%%  v/v   --> []
grammar_rule(vgap,V,[call(get_val(IDENTIFIER,VSLASH))]) :-
    structure,
    V => v,
    V:eps1 => yes,
    V:eps2 => yes,
    V:eps3 => yes,
    V:vform => fin,
    V:psprule => no,

    %%% all information "from inside the V" should be unified
    %%% through vslash
    %%% all information "that is filled in outside of the V (later)"
    %%% is copied through the get_val/put_val mechanism
    %%% pfff
    
    V:vslash:vslashid <=> IDENTIFIER,
    V:vslash:vslashlix <=> VSLASH:dt:lix,
    V:vslash:vslashhwrd <=> VSLASH:dt:hwrd,
    V:vslash:vslashfwrd <=> VSLASH:dt:fwrd,
    V:vslash:vslashcrd <=> VSLASH:dt:crd,
    V:vslash:vslashcnj <=> VSLASH:dt:cnj,
%    V:vslash:vslashsvp <=> VSLASH:dt:svp,
%    V:vslash:vslashsubj <=> VSLASH:subj,

    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (   PG == generate,
	V:exs => [],
	V:mexs => []
    ;   PG == parse,
	V:vslash:exs <=> V:exs,
	V:vslash:mexs <=> V:mexs
    ),

    unify_vslash(VSLASH,V).

unify_vslash(VSLASH,V) :-
    VSLASH => v,
    V => v,

    VSLASH:subj <=> V:subj,
    VSLASH:e_deps <=> V:e_deps,
    VSLASH:parts <=> V:parts,
    VSLASH:slash <=> V:slash,
    VSLASH:sc <=> V:sc,

    VSLASH:vframe <=> V:vframe,
    VSLASH:vtype <=> V:vtype,
    VSLASH:cleft <=> V:cleft,  % never was here ?

    VSLASH:dt <=> V:dt,
    VSLASH:ccat0 <=> V:ccat0,
    VSLASH:ccat <=> V:ccat,    
    VSLASH:mods <=> V:mods,
    VSLASH:cmods <=> V:cmods,
    VSLASH:predms <=> V:predms,
    VSLASH:cpredms <=> V:cpredms,
    VSLASH:apps <=> V:apps,
    VSLASH:capps <=> V:capps,
    VSLASH:dets <=> V:dets,
    VSLASH:cdets <=> V:cdets.

v2_structure(Vmain,VP,Sv1,IDENTIFIER,VSLASH) :-
    structure,
    Vmain => v,
    Vmain:vslash => [],
    Vmain:vform => fin,
    VP => v2_vp,
    VP:haswh <?=?> Sv1:haswh,
    Vmain:subj <=> Subj,
    Subj => np,
    Subj:prs <=> Vmain:inv_agr,

    Vmain:subj <=> VP:subj,
    Vmain:slash <=> VP:slash,
    
    VP:vslash:vslashid <=> IDENTIFIER,
    VP:vslash:vslashhwrd <=> VSLASH:dt:hwrd,
    VP:vslash:vslashfwrd <=> VSLASH:dt:fwrd,
    VP:vslash:vslashcrd <=> VSLASH:dt:crd,
    VP:vslash:vslashcnj <=> VSLASH:dt:cnj,
%    VP:vslash:vslashsvp <=> VSLASH:dt:svp,
%    VP:vslash:vslashsubj <=> VSLASH:subj,

    %% to forbid "raap je troep op en je spullen op"
    %% which also leads to 2nd phase failure
    Vmain:parts <=> VP:vslash:vslashparts,
    
    Vmain:cj <=> VP:vslash:cj,
    Vmain:inv => yes,
    unify_vslash(VSLASH,Vmain),
    valence_principle(VP,[],[],Sv1),
    filler_principle(VP,[],Sv1),
    head_feature_principle(Vmain,Sv1),
    hd_dt_principle(sv1,VP,Sv1,[],[],[],[]).

%% sv1 --> vmain vp
grammar_rule(imp,Sv1,[Vmain,call(put_val(IDENTIFIER,VSLASH)),VP]) :-
    Vmain:imper => no,
    Sv1:dt:stype => (ynquestion;declarative;whquestion;topic_drop),
    imp_structure(Sv1,Vmain,VP,IDENTIFIER,VSLASH).

imp_structure(Sv1,Vmain,VP,IDENTIFIER,VSLASH) :-
    Sv1 => sv1,
    v2_structure(Vmain,VP,Sv1,IDENTIFIER,VSLASH),
    VP:tags <=> Sv1:tags,
    Vmain:e_deps <=> [],
    Vmain:exs => [],
    Vmain:mexs => [],
    
    Sv1:iexs <=> VP:vslash:exs,

    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (   PG == generate,
	Sv1:iexs => []
    ;   PG == parse,
	Sv1:imexs <=> VP:vslash:mexs

    ).


%% special case of imp rule above: this one for true imperatives
grammar_rule(imp_imp, Imp, [ Vmain, call(put_val(IDENTIFIER,VSLASH)), VP ]):-
    Imp => imp,
    Imp:dt:stype => imparative,
    v2_structure(Vmain,VP,Imp,IDENTIFIER,VSLASH1),
    Vmain:tense => present,
    Vmain:imper => yes,
    unify_except(VSLASH1,VSLASH,sc),
    VSLASH1:sc <=> Sc0,
    VSLASH:sc <=> Sc,
    VSLASH:exs => [],
    VSLASH:mexs => [],
    VP:vslash:exs => [],
    VP:vslash:mexs => [],
    Vmain:e_deps <=> [],
    VP:tags <=> Imp:tags,
    VP:haswh => no,
    Vmain:subj <=> Subj,
    Subj:case => nom,
    Subj:agr => sg,
    Subj:e_agr <=> Subj:agr,
    Subj:prs => invje,
    Subj:nform => (norm;meas_mod),
    Subj:allows_drop => yes,
    Subj:dt => [],
    alpino_wappend:wappend(Sc,[Subj],Sc0).


%% In Google, type de volgende zoekopdracht in

grammar_rule(imp_mod_imp,ImpMother,[Mod, Imp]) :-
    max_pp(Mod),
    Mod:sel => ~to_topic,
    Mod:pp_er => no,
    Imp => imp,
    ImpMother => imp,
    hd_mod_structure(Imp,Mod,ImpMother).

%% tel uit je winst
%% leg neer die bal
%% spreek uit Djoomoo
grammar_rule(imp_part_imp,Imp, [Vmain0, Part, call(put_val(IDENTIFIER,VSLASH)), VP ]):-
    Vmain0 => v,
    Vmain => v,
    unify_except(Vmain0,Vmain,parts),
    Part => part,
    hd_part_structure(Vmain0,Part,Vmain),
    Imp => imp,
    Imp:dt:stype => imparative,
    v2_structure(Vmain,VP,Imp,IDENTIFIER,VSLASH1),
    Vmain:tense => present,
    Vmain:imper => yes,
    unify_except(VSLASH1,VSLASH,sc),
    VSLASH1:sc <=> Sc0,
    VSLASH:sc <=> Sc,
    VSLASH:exs => [],
    VSLASH:mexs => [],
    VP:vslash:exs => [],
    VP:vslash:mexs => [],
    Vmain:e_deps <=> [],
    VP:tags <=> Imp:tags,
    VP:haswh => no,
    Vmain:subj <=> Subj,
    Subj:case => nom,
    Subj:agr => sg,
    Subj:e_agr <=> Subj:agr,
    Subj:prs => invje,
    Subj:nform => (norm;meas_mod),
    Subj:allows_drop => yes,
    Subj:dt => [],
    alpino_wappend:wappend(Sc,[Subj],Sc0).

% %% spoken language only?
% %% topic-drop
% %% kan ik niet
% %% weet ik 
% %% zeg ik niet
% %% heeft niemand last van
grammar_rule(topic_drop,ROOT,[EmptyTopic,Ques]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    EmptyTopic => etopic,
    Ques:iexs => [],
    Ques:imexs => [],
    Topic => np,
    Topic:allows_drop => yes,
    Topic:dt => [], % !
    Topic:nform => (norm;er),   % BUT: kan best zijn dat ...
                                %      *regent
    Topic:agr <=> Topic:e_agr,
    Topic:prs => (fir;thi),  % OK: vroeg me af of hij zou komen
                       %       kan me niet voorstellen dat ...
    Topic:case => (nom;acc),
                 % ok: "Piet?  Geef ik boeken.
                 % but the same dep.str. is assigned anyway
                 % using trans. frame...
    Ques => sv1,
    Ques:haswh => no,
    ROOT => max,
    ROOT:max_type => t_topic_drop,
    ROOT:sv1 => yes,
    ROOT:dt:stype => topic_drop,
%    ROOT:puncttype => ~vraag,   % vindt u niet erg ?
%    unify_mods(Ques),
    projected_hd_filler_structure(Ques,Topic,ROOT,sv1).
%% error: variable slash in weakening; therefore explicit empty topic
%% element.

grammar_rule(etopic,EmptyTopic,[]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    structure,
    EmptyTopic => etopic.

grammar_rule(ecomp,EmptyComp,[]) :-
    structure,
    EmptyComp => ecomp.

%% root --> WH v1
%% root --> topic v1 (local) 
grammar_rule(non_wh_topicalization(np),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => np,
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(non_wh_topicalization(pred),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => pred,
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(non_wh_topicalization(pp),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => pp,
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(non_wh_topicalization(sbar),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => sbar,
%    Topic:ctype => ~c_of_short, % ! reduce weird ambiguities
% must be allowed for
% cdb4269 cdb2976
% 'wat voor affiniteit kon hij niet uitleggen'
% 'hoeveel precies wisten we niet'
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(non_wh_topicalization(adv),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => adv,
    Topic:tmploc => (loc;ld_dir;me),
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(non_wh_topicalization(vp),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => vp,
    Topic:vform => (om;te),
    Topic:tags => [],
    Topic:haswh => no,
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

%% maybe: only allow rel/vp modifier extraction from topic?
grammar_rule(non_wh_topicalization(modifier),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => modifier,
    Topic:modifies_v => yes,
    Topic:mcat => ~mcat_imp,  %  * wil ik komen kom ik
    ROOT => root,
    ROOT1 => root,
    unify_except(ROOT,ROOT1,allows_root_imp),
    non_wh_topic_structure(Ques,Topic,ROOT1,OPTCOMMA).

grammar_rule(non_wh_topicalization(vc),ROOT,[Topic,OPTCOMMA,Ques]) :-
    Topic => vc,
    no_vslash(Topic),
    Topic:vform => (psp;aan_het;uit;op;wk_te;te;inf;pass_te),
    Topic:pspslash => [],
    Topic:parts => [],
    non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

%% aldus verklaarde de hoofdofficier
grammar_rule(non_wh_topicalization_dip,ROOT,[ZO,Q]) :-
    ROOT => root,
    ROOT:allows_root_imp => no,
    ROOT:needs_dip => yes,
    ZO => dip_adv,
    unify_mods(ZO),
    Q => sv1,
    Q:slash <=> [SLASH],
    Q:haswh => no,
    Q:iexs => [],
    Q:imexs => [],
    max_sbar(SLASH),
    SLASH:ctype => c_dat,
    SLASH:exs =?> [],
    SLASH:mexs =?> [],
    ZO:dt <=> SLASH:dt,
    projected_hd_filler_structure(Q,SLASH,ROOT,smain).

%% zo klonk het; zo heette het
grammar_rule(non_wh_topicalization_dip_pred,ROOT,[ZO,Q]) :-
    ROOT => root,
    ROOT:allows_root_imp => no,
    ROOT:needs_dip => yes,
    ZO => dip_adv,
    unify_mods(ZO),
    Q => sv1,
    Q:haswh => no,
    Q:slash <=> [SLASH],
    Q:iexs => [],
    Q:imexs => [],
    SLASH => pred,
    SLASH:exs =?> [],
    SLASH:mexs =?> [],
    SLASH:e_deps =?> [],
    ZO:dt <=> SLASH:dt,
    projected_hd_filler_structure(Q,SLASH,ROOT,smain).

%% zo begon hij
grammar_rule(non_wh_topicalization_dip_mod,ROOT,[ZO,Q]) :-
    ROOT => root,
    ROOT:allows_root_imp => no,
    ROOT:needs_dip => yes,
    ZO => dip_adv,
    unify_mods(ZO),
    Q => sv1,
    Q:haswh => no,
    Q:slash <=> [SLASH],
    Q:iexs => [],
    Q:imexs => [],
    SLASH => modifier,
    SLASH:exs =?> [],
    SLASH:mexs =?> [],
    ZO:dt <=> SLASH:dt,
    projected_hd_filler_structure(Q,SLASH,ROOT,smain).

%% todo: treat iexs and exs like in hd_filler_structs...
%% for next three rules
grammar_rule(predm_topicalization,ROOT,[PREDM,OPTCOMMA,Ques]) :-
    PREDM => predm_adv,
    optcomma(OPTCOMMA),
    nwh_topicalized_predm_structure(Ques,PREDM,ROOT).

grammar_rule(predm_ap_topicalization,ROOT,[PREDM,OPTCOMMA,Ques]) :-
    predm_adj(PREDM),
    optcomma(OPTCOMMA),
    nwh_topicalized_predm_structure(Ques,PREDM,ROOT).

grammar_rule(predm_pp_topicalization,ROOT,[PP,OPTCOMMA,Ques]) :-
    pp_predm(PP),
    optcomma(OPTCOMMA),
    nwh_topicalized_predm_structure(Ques,PP,ROOT).

nwh_topicalized_predm_structure(Ques,PREDM,ROOT) :-
    ROOT => root,
    Ques => sv1,
    Ques:haswh => no,
    topicalized_predm_structure(Ques,PREDM,ROOT,smain).

topicalized_predm_structure(Ques,PREDM,ROOT,CAT) :-
    ROOT:needs_dip => no,
    ROOT:dt:stype => declarative,

    if_defined(PREDM:hstem,Hstem,none),
    ROOT:topic_hstem <=> Hstem,

    is_defined(PREDM:exs,Bool1),
    (   Bool1 == yes
    ->  unify_except(PREDM,PREDM1,exs),
        Exs <=> PREDM:exs
    ;   PREDM=PREDM1,
        Exs => []
    ),

    is_defined(PREDM1:mexs,Bool2),
    (   Bool2 == yes
    ->  unify_except(PREDM1,PREDM2,mexs),
        Mexs <=> PREDM1:mexs
    ;   PREDM1=PREDM2,
        Mexs => []
    ),
    
    Ques:iexs <=> Exs,
    Ques:imexs <=> Mexs,
    hd_predm_structure(Ques,PREDM2,ROOT,CAT).

topic_principle(_Ques,Topic,ROOT,OPTCOMMA) :-
    optcomma(OPTCOMMA),
    Topic:cj =?> ~of_crd,
    Topic:sel =?> to_topic,
    Topic:tags =?> [],
    Topic:wkpro =?> ~ntopicpro,
    ROOT => root,
    if_defined(Topic:hstem,Hstem,none),
    ROOT:topic_hstem <=> Hstem,
    ROOT:needs_dip => no,
    Topic:slash =?> [].

non_wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA) :-
    Ques => sv1,
    Ques:haswh => no,
    ROOT:question =?> no,
    ROOT:dt:stype => declarative,
    topic_principle(Ques,Topic,ROOT,OPTCOMMA),
    Topic:wh =?> nwh,
    ROOT:allows_root_imp => no,
    projected_hd_filler_structure(Ques,Topic,ROOT,smain).

grammar_rule(vast_staat,ROOT,
             [VastVmain,call(put_val(IDENTIFIER,VSLASH)),VP]) :-
    imp_structure(Sv1,Vmain,VP,IDENTIFIER,VSLASH),
    ROOT:dt:stype => declarative,
    ROOT:topic_hstem ==> none,
    VastVmain => vb,
    VastVmain:tpart => yes,
    Vmain => v,
    Vmain:slash => [],
    unify_vb_v(Vmain,VastVmain),
    Sv1:iexs => [],
    Sv1:imexs => [],
    ROOT => root,
    ROOT:allows_root_imp => no,
    ROOT:needs_dip => no,
    ROOT:dt <=> Sv1:dt,
    ROOT:question => no,
    %% which verbs allow this?
    %% Right now: 
    hd_structure(Sv1,ROOT,smain).

wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA) :-
    topic_principle(Ques,Topic,ROOT0,OPTCOMMA),
    unify_except(ROOT0,ROOT,dt:stype),
    ROOT:question =?> yes,
    ROOT:dt:stype => whquestion,
    ROOT:dt:body:stype => whquestion,
    ROOT:allows_root_imp => no,
    non_projected_hd_filler_structure(Ques,Topic,ROOT,whq),
    xy_dep_dt_nostype(Topic,Ques,ROOT,whd,body),
    Topic:wh => ywh,
    Topic:wh => yq,
    Topic:wh_reltmploc => ~hoe_hoe.

grammar_rule(wh_topicalization(np), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => sv1,
    Topic => np,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(wh_topicalization(pred), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => sv1,
    Topic => pred,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(wh_topicalization(pp), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => sv1,
    Topic => pp,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(wh_topicalization(adv), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => sv1,
    Topic => adv,
    Topic:tmploc => (loc;ld_dir;me),
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

grammar_rule(wh_topicalization(modifier), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => sv1,
    Topic => modifier,
    Topic:mcat => ~mcat_imp,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

%% wat te zeggen van die problemen?
grammar_rule(wh_topicalization(np,vp), ROOT, [Topic, OPTCOMMA, Ques]) :-
    Ques => vp,
    Ques:vform => te,
    Ques:e_deps => [],
    Topic => np,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

%% waarom een invaller gezocht?
%% waarom een invaller zoeken?
%% hoe een invaller te vinden?
grammar_rule(wh_topicalization(modifier,vp), ROOT, [Topic,OPTCOMMA,Ques]) :-
    Ques => vp,
    Ques:vform => (inf;psp;te),
    Ques:e_deps => [],
%    Ques:subj:dt => [],
    Ques:subj:allows_drop => yes, % !!
    Topic => modifier,
    wh_topic_structure(Ques,Topic,ROOT,OPTCOMMA).

%% met z'n hoevelen komen jullie?
grammar_rule(predm_ap_wh_topicalization,ROOT,[PREDM,OPTCOMMA,Ques]) :-
    optcomma(OPTCOMMA),
    wh_predm_adj(PREDM),
    predm_wh_topic_structure(ROOT,PREDM,Ques).

%% als welk personage wilt u na uw dood terugkeren?
grammar_rule(predm_pp_wh_topicalization,ROOT,[PREDM,OPTCOMMA,Ques]) :-
    optcomma(OPTCOMMA),
    wh_pp_predm(PREDM),
    predm_wh_topic_structure(ROOT,PREDM,Ques).

predm_wh_topic_structure(ROOT,PREDM,Ques) :-
    ROOT0 => root,
    ROOT => root,
    unify_except_l(ROOT0,ROOT,[ccat0,ccat,dt,cpredms,predms,
                               cdets,dets,capps,apps,cmods,mods]),
    ROOT:question =?> yes,
    ROOT:allows_root_imp => no,
    Ques => sv1,
    PREDM:wh => ywh,
    PREDM:wh => yq,
    
    topicalized_predm_structure(Ques,PREDM,ROOT0,sv1),

    unify_mods(ROOT0),
    assign_new_percolation(ROOT,cmods,  mods,  mod),
    assign_new_percolation(ROOT,capps,  apps,  app),
    assign_new_percolation(ROOT,cdets,  dets,  det),
    assign_new_percolation(ROOT,cpredms,predms,predm),
    xy_dep_dt_nostype(PREDM,ROOT0,ROOT,whq,whd,body).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% SUBSET of vp rules, for nominalization %%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nominalization_cat(N) :-
    N => n,
    N:exs => [],
    N:agr => het&sg,
    N:lex => yes,
    N:nform => norm.

grammar_rule(nominalization,N,[V]) :-
    nominalization_cat(N),
    V => vpx_noun,
    finish_mexs(V),
    hd_structure(V,N0),
    unify_except_l(N0,N1,[hstem,lex]),
    N:hstem ==> nominalization(Vstem),
    V:hstem ==> Vstem,
    overwrite(N1,N,mexs,[]). % island for relatives etc...

grammar_rule(vpx_vc_noun,VPX,[VC]) :-
    VC:cj => ncj,
    VPX => vpx_noun,
    VC => vc_noun,
    hd_structure(VC,VPX).

grammar_rule(vpnoun_v_extra, VP, [ V, Extra ] ) :-
    VP => vpx_noun, V => vpx_noun, Extra => comparativep,
    hd_extra_structure(V,Extra,VP).

grammar_rule(vpnoun_v_pp, VP, [ V, Extra ] ) :-
    VP => vpx_noun, V => vpx_noun, Extra => pp,
    Extra:slash => [],
    Extra:sel => to_right,
    hd_extra_structure(V,Extra,VP).

grammar_rule(vpnoun_v_sbar, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx_noun, V => vpx_noun, Extra => sbar,
    Extra:slash => [],
    Extra:tags => [],
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vpnoun_v_inf, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx_noun, V => vpx_noun,
    mod_vp(Extra),
    optcomma(OPTCOMMA),
    hd_extra_structure(V,Extra,VP).

grammar_rule(vpnoun_v_m_extra, VP, [ V, OPTCOMMA, Extra ] ) :-
    VP => vpx_noun, V => vpx_noun, Extra => rel,
    optcomma(OPTCOMMA),
    hd_m_extra_structure(V,Extra,VP).

grammar_rule(deverbal_vp_arg_v(np),VP, [Arg, V] ) :-
    Arg => np,
    Arg:sel => to_left,
    %% reduce ambiguities:
    Arg:subn => ~sub_def_verb & ~sub_indef_verb 
                              & ~sub_def_adj & ~sub_indef_adj
                              & ~sub_rang
                              & ~sub_det & ~sub_veel,
                        
    Arg:wh => nwh,
    Arg:pred => npred,
    VP => vc_noun,
    V => vc_noun,
    V:vc <=> VP:vc,
    VP:hasmod <=> V:hasmod,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_arg_v(fixed_pred),VP, [Arg, V] ) :-
    Arg => fixed_part,
    Arg:sel => to_left,
    Arg:cat => pred,
    VP => vc_noun,
    V => vc_noun,
    V:vc <=> VP:vc,
    VP:hasmod <=> V:hasmod,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_arg_v(pp),VP, [Arg, V] ) :-
    Arg => pp,
    Arg:sel => to_left,
    Arg:wh => nwh,
    VP => vc_noun,
    V => vc_noun,
    V:vc <=> VP:vc,
    V:vc <=> Arg:vc,
    VP:hasmod <=> V:hasmod,
    V:hasmod <=> Arg:vhasmod,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_v_arg(pp),VP, [V, Arg] ) :-
    Arg => pp,
    Arg:sel => to_right,
    Arg:slash => [],
    Arg:wh => nwh,
    VP => vc_noun,
    V => vc_noun,
    VP:haspre2 => yes,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_v_arg(sbar),VP, [V, Arg] ) :-
    Arg => sbar,
    Arg:sel => to_right,
    Arg:tags => [],
    VP => vc_noun,
    V => vc_noun,
    VP:haspre2 => yes,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_v_arg(vp),VP, [V, Arg] ) :-
    Arg => vp,
    Arg:sel => to_right,
    Arg:tags => [],
    Arg:vform => om,
    VP => vc_noun,
    V => vc_noun,
    VP:haspre2 => yes,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_arg_v(adv),VP, [Arg, V] ) :-
    Arg => adv,
    Arg:sel => to_left,
    Arg:tmploc => (loc;ld_dir;me;wk_er),
    Arg:wh => nwh,
    VP => vc_noun,
    V => vc_noun,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_arg_v(pred),VP, [Arg, V] ) :-
    Arg => pred,
    Arg:sel => to_left,
    Arg:wh => nwh,
    VP => vc_noun,
    V => vc_noun,
    hd_comp_structure(V,Arg,VP). 

grammar_rule(deverbal_vp_mod_v,VP, [MOD, V] ) :-
    MOD => modifier,
    MOD:wh => nwh,
    MOD:sel => to_left,
    MOD:mcat => ~mcat_redrel,
    VP => vc_noun,
    V => vc_noun,
    V:haspre2 => no,
    VP:hasmod => yes,
    MOD:modifies_v => yes,
    hd_mod_structure(V,MOD,VP). 

grammar_rule(deverbal_vp_v_mod,VP, [V, MOD] ) :-
    MOD => modifier,
    MOD:wh => nwh,
    MOD:sel => to_left,
    MOD:mcat => (mcat_sbar;mcat_vp),
    VP => vc_noun,
    V => vc_noun,
    VP:haspre2 => yes,
    MOD:modifies_v => yes,
    hd_mod_structure(V,MOD,VP). 

grammar_rule(deverbal_vp_predm_v,VP, [MOD, V] ) :-
    MOD => predm_adv,
    VP => vc_noun,
    V => vc_noun,
    V:haspre2 => no,
    VP:hasmod => yes,
    hd_predm_structure(V,MOD,VP). 

grammar_rule(deverbal_vp_predm_adj_v,VP, [MOD, V] ) :-
    predm_adj(MOD),
    VP => vc_noun,
    V => vc_noun,
    V:haspre2 => no,
    VP:hasmod => yes,
    hd_predm_structure(V,MOD,VP). 

grammar_rule(deverbal_vp_part_v,VP, [Part, V] ) :-
    VP => vc_noun,
    V => v_noun,
    Part => part,
    hd_part_structure(V,Part,VP). 

grammar_rule(deverbal_vc_v,VP,[V]) :-
    VP => vc_noun,
    V => v_noun,
    V:cj => ncj,
    VP:vc => yes,
    hd_structure(V,VP).

grammar_rule(deverbal_v_v_v,VP, [V, Inf] ) :-	
    VP => v_noun, V => v_noun, Inf => vc,
    V:lex => yes, % !!
    Inf:vslash => [],
    Inf:pspslash => [],
    Inf:vform => ~psp & ~aan_het & ~op & ~pass_te & ~uit,
                                % * het worden gekust is fijn
    hd_comp_structure(V,Inf,VP).

%% (het) gekust worden is lekker
grammar_rule(deverbal_v_inv_v_v,VP, [Psp, V] ) :-	
    VP => v_noun, V => v_noun, Psp => vb, Psp1 => vc,
    unify_vc_vb(Psp,Psp1),
    V:lex => yes, % !!
    Psp:vslash => [],
    Psp:vform => (aan_het;op;psp;pass_te;uit),
    hd_comp_structure(V,Psp1,VP).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% rules for DIPs %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar_rule(dip_sv1,DIPP,[DIP]) :-
    DIPP => dip,
    DIP => sv1,
    DIP:subj:allows_drop => no,
    DIP:can_be_max => yes,
    DIP:slash <=> [SbarArg],
    DIP:iexs => [],
    DIP:imexs => [],
    DIP:tags => [],
    DIP:haswh => no,
    unify_mods(DIP),
    max_sbar(SbarArg),
    SbarArg:ctype => c_dip,
    SbarArg:dt => [], % !
    projected_hd_filler_structure(DIP,SbarArg,DIPP).

grammar_rule(dip_root,DIPP,[DIP]) :-
    DIPP => dip,
    DIP => root,
    DIP:tags => [],
    DIP:needs_dip => yes,
    unify_mods(DIP),
    hd_structure(DIP,DIPP).

grammar_rule(dip_pp,DIPP,[DIP]) :-
    DIPP => dip,
    pp_modifier(DIP),
    unify_mods(DIP),
    DIP:prep ==> aldus,
    hd_structure(DIP,DIPP).

grammar_rule(sv1_dip_sv1,VP,[COMMAL,DIP,COMMAR,V]) :-
    comma(COMMAL),
    comma(COMMAR),
    LQ => no,
    sv1_dip_sv1_structure(V,DIP,VP,LQ).

grammar_rule(sv1_smain_sv1,VP,[COMMAL,MAX,COMMAR,V]) :-
    comma(COMMAL),
    comma(COMMAR),
    LQ => no,
    V => sv1,
    VP => sv1,
    VP:can_be_max => no,
    V:iexs <=> VP:iexs,
    V:imexs <=> VP:imexs,
    MAX => max,
    MAX:max_type => (t_dp;t_root),
    MAX:mod_np => no,
    unify_mods(MAX),
    xp_dip_xp_structure(V,MAX,VP,LQ).

grammar_rule(sv1_dip_sv1_q,VP,[QR,COMMAL,DIP,COMMAR,QL,V]) :-
    optcomma(COMMAL),
    optcomma(COMMAR),
    ql(QL),
    qr(QR),
    LQ => yes,
    sv1_dip_sv1_structure(V,DIP,VP,LQ).

grammar_rule(sv1_dip_sv1_ligg,VP,[COMMAL,DIP,COMMAR,V]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    COMMAL => punct,
    COMMAR => punct,
    COMMAL:puncttype => ligg_streep,
    COMMAR:puncttype => ligg_streep,
    LQ => no,
    sv1_dip_sv1_structure(V,DIP,VP,LQ).

grammar_rule(sv1_dip_sv1_haak,VP,[COMMAL,DIP,OptQm, COMMAR,V]) :-
    COMMAL => punct,
    COMMAL:puncttype => haak_open,
    COMMAR => punct,
    COMMAR:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    LQ => no,
    sv1_dip_sv1_structure(V,DIP,VP,LQ).

sv1_dip_sv1_structure(V,DIP,VP,Bool) :-
    V => sv1,
    VP => sv1,
    VP:can_be_max => no,
    V:iexs <=> VP:iexs,
    V:imexs <=> VP:imexs,
    DIP => dip,
    unify_mods(DIP),
    xp_dip_xp_structure(V,DIP,VP,Bool).

xp_dip_xp_structure(V,DIP,VP1,Bool) :-
    V:tags => [],
    VP1:tags <=> [TAG],
    TAG:dt_out <=> Result,
    TAG:lq <=> Bool,
    Result => dt,
    Result:cat ==> du,
    Result:nucl <=> TAG:dt_in,
    Result:tag <=> DIP:dt,
    initialize_dt_in(Result),
    unify_except(VP,VP1,tags),
    hd_structure(V,VP).

vp_dip_vp_structure(V,DIP,VP,Bool) :-
    VP => vproj,
    V => vproj,
    unify_mods(DIP),
    xp_dip_xp_structure(V,DIP,VP,Bool),
    VP:mf <=> V:mf,
    VP:eps1 <=> V:eps1,
    VP:eps2 <=> V:eps2,
    VP:haspre => yes,
    V:haspre => yes,
    V:haspre2 => no,
    V:vform => fin.

%% role of nucl and tag is swapped!
vp_vp_dip_structure(V,DIP,VP1) :-
    VP => vproj,
    V => vproj,
    VP:mf <=> V:mf,
    V:tags => [],
    VP1:tags <=> [TAG],
    TAG:dt_out <=> Result,
    TAG:lq => no,
    Result => dt,
    Result:cat ==> du,
    Result:tag <=> TAG:dt_in,
    Result:nucl <=> DIP:dt,
    initialize_dt_in(Result),
    unify_except_l(VP,VP1,[tags,rightx]),
    VP1:rightx => no,
    hd_structure(V,VP).

initialize_dt_in(Result) :-
    initialize_dt_dt([nucl,tag],Result),
    Result:hwrd => [],
    Result:app => [],
    Result:det => [],
    Result:mod => [],
    Result:predm => [].

%% vproj --> , sv1 , vproj
%% Ik denk , zei Jan , dat dit niet mogelijk is
%% I think, John said , that this is not possible
grammar_rule(vp_dip_vp,VP1,[QR,COMMAL,Sv1,COMMAR,OPTQL,V]) :-
    qr(QR),
    optql(OPTQL),
    comma(COMMAL),
    comma(COMMAR),
    Sv1 => dip,
    LQ => yes,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_dip_vp1,VP1,[COMMAL,Sv1,COMMAR,OPTQL,V]) :-
    optql(OPTQL),
    comma(COMMAL),
    comma(COMMAR),
    Sv1 => dip,
    LQ => no,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_tag_vp1,VP1,[COMMAL,TAG,COMMAR,V]) :-
    comma(COMMAL),
    comma(COMMAR),
    TAG => tag,
    TAG:adv => no,
    vp_dip_vp_structure(V,TAG,VP1,_).

grammar_rule(vp_vp1_tag,VP1,[V,COMMAL,TAG,COMMAR]) :-
    comma(COMMAL),
    comma(COMMAR),
    TAG => tag,
    TAG:adv => no,
    vp_dip_vp_structure(V,TAG,VP1,_).

grammar_rule(vp_dip_vp2,VP1,[QR,Sv1,OPTCOMMA,QL,V]) :-
    qr(QR),
    ql(QL),
    optcomma(OPTCOMMA),
    Sv1 => dip,
    LQ => yes,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_dip_vp_ligg,VP1,[QR,COMMAL,Sv1,COMMAR,OPTQL,V]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    qr(QR),
    optql(OPTQL),
    COMMAL => punct,
    COMMAR => punct,
    COMMAL:puncttype => ligg_streep,
    COMMAR:puncttype => ligg_streep,
    Sv1 => dip,
    LQ => yes,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_dip_vp_ligg2,VP1,[COMMAL,Sv1,COMMAR,OPTQL,V]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    optql(OPTQL),
    COMMAL => punct,
    COMMAR => punct,
    COMMAL:puncttype => ligg_streep,
    COMMAR:puncttype => ligg_streep,
    Sv1 => dip,
    LQ => no,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_dip_vp_haak,VP1,[QR,COMMAL,Sv1,OptQm,COMMAR,OPTQL,V]) :-
    qr(QR),
    optql(OPTQL),
    COMMAL => punct,
    COMMAL:puncttype => haak_open,
    COMMAR => punct,
    COMMAR:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    Sv1 => dip,
    LQ => yes,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

grammar_rule(vp_dip_vp_haak2,VP1,[COMMAL,Sv1,OptQm,COMMAR,OPTQL,V]) :-
    optql(OPTQL),
    COMMAL => punct,
    COMMAL:puncttype => haak_open,
    COMMAR => punct,
    COMMAR:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    Sv1 => dip,
    LQ => no,
    vp_dip_vp_structure(V,Sv1,VP1,LQ).

%% we moeten denk ik naar huis
%% we moeten geloof ik naar huis

grammar_rule(vp_dip_vp_no_comma, VP1,[DIP,V]) :-
    DIP => denk_ik,
    LQ => no,
    vp_dip_vp_structure(V,DIP,VP1,LQ).

dip_scope_structure(NUCL,ROOT) :-
    structure,
    unify_except_l(NUCL,ROOT,[dt,tags]),
    NUCL:tags <=> [TAG|Tags],
    ROOT:tags <=> Tags,
    alpino_data:dt(ROOT,ROOTDT),
    alpino_data:dt(NUCL,NUCLDT),
    TAG:dt_in <=> NUCLDT,
    TAG:dt_out <=> ROOTDT.

grammar_rule(dip_scope_root,ROOT,[NUCL]) :-
    ROOT => root, NUCL => root,
    dip_scope_structure(NUCL,ROOT).

grammar_rule(dip_scope_imp,ROOT,[NUCL]) :-
    ROOT => imp, NUCL => imp,
    dip_scope_structure(NUCL,ROOT).

%% voor:
%% " Dit " , zegt Piet , " komt voort uit onmacht .
%% maar maakt deze stuk:
%% " Zoiets zit er altijd in , als je begint .
%% todo: limit to cases where DIP is not on the left edge
grammar_rule(dip_scope_root_q,ROOT,[QL,NUCL,QR]) :-
    ql(QL),
    optqr(QR),
    ROOT => root, NUCL => root,
    NUCL:tags <=> [TAG|_],
    TAG:lq => yes,
    dip_scope_structure(NUCL,ROOT).

%% really, if embbeded?
grammar_rule(dip_scope_sbar,ROOT,[NUCL]) :-
    ROOT => sbar,
    dip_scope_structure(NUCL,ROOT).

%% really, if embedded?
grammar_rule(dip_scope_vp,ROOT,[NUCL]) :-
    ROOT => vp,
    dip_scope_structure(NUCL,ROOT).

%% ik zei: dat is onzin!
%% ik zei: met wie?
%% TODO: require/allow that TAG misses SBAR/NP argument!
grammar_rule(vp_vp_dip,VP,[V,COLON,NUCL]) :-
    NUCL => start,
    unify_mods(NUCL),
    comma_dubb(COLON),
    max_sbar(SBAR),
    SBAR:ctype => c_dip,
    SBAR:dt => [], % !
% no: ' Voor onze generatie is het gewoon nog traditie : vrouwen moeten met Albanezen trouwen .
    vp_v_arg_structure(V,SBAR,V1,_),
    vp_vp_dip_structure(V1,NUCL,VP),
    VP:haspre2 => yes.

grammar_rule(vp_vp_dip_q,VP,[V,COLON,QL,NUCL,OPTEND,QR]) :-
    optend_punct(OPTEND,Type),
    ql(QL),
    qr(QR),
    NUCL => start,
    NUCL:puncttype <=> Type,
    comma_dubb(COLON),
    unify_mods(NUCL),
    max_sbar(SBAR),
    SBAR:ctype => c_dip,
    SBAR:dt => [],
% no: ' Voor onze generatie is het gewoon nog traditie : vrouwen moeten met Albanezen trouwen .
    vp_v_arg_structure(V,SBAR,V1,_),
    vp_vp_dip_structure(V1,NUCL,VP).

grammar_rule(vp_vp_dip_q_nocolon,VP,[V,QL,NUCL,OPTEND,QR]) :-
    optend_punct(OPTEND),
    ql(QL),
    qr(QR),
    max_root(NUCL),  % only root; otherwise false amb
                     %               Wie schreef " Mein Kampf "
                     % however: cf cdb/3384
    unify_mods(NUCL),
    max_sbar(SBAR),
    SBAR:ctype => c_dip,
    SBAR:dt => [],
    vp_v_arg_structure(V,SBAR,V1,_),
    vp_vp_dip_structure(V1,NUCL,VP).

%% specifically for cdb corpus, where : is often treated as sentence
%% boundary:
grammar_rule(vp_vp_colon,VP,[V,COLON]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    COLON => punct,
    COLON:puncttype => dubb_punt,
    max_np(NP),
    NP:mexs => [],
    NP:hstem => [],
    NP:nform => norm,
    NP:subn => sub_noun,
    NP:case => (obl;acc;nom),  % don't use obj2 here
    NP:dt => [], % !
    NP:allows_drop => yes,
    vp_v_arg_structure(V,NP,VP,_).

%% beste luisteraars , zet uw radio maar op 3
grammar_rule(np_imp,START,[NP,COMMA,IMP,OPTPUNCT]) :-
    START => start,
    max_np(NP),
    comma(COMMA),
    max_imp(IMP),
    optend_punct(OPTPUNCT,Type),
    nucl_tag_structure(IMP,NP,START),
    Type => (hellip;uitroep;punt).

%%% ga onmiddellijk naar binnen , spelbreker
grammar_rule(imp_np,START,[IMP,COMMA,NP,OPTPUNCT]) :-
    START => start,
    max_np(NP),
    comma(COMMA),
    max_imp(IMP),
    optend_punct(OPTPUNCT,Type),
    nucl_tag_structure(IMP,NP,START),
    Type => (hellip;uitroep;punt).

%% dat is een teunisbloem denk ik
grammar_rule(start_max_denk_ik,START,[NUCL,OPTPUNCT,COMMA,TAG]) :-
    START => max,
    START:max_type => t_dp,
    NUCL => start,
    TAG => denk_ik,
    optend_punct(OPTPUNCT,Type),
    NUCL:puncttype <=> Type,
    optcomma(COMMA),
    nucl_tag_structure(NUCL,TAG,START).

%% Hij is gek ! , riep ik
grammar_rule(start_max_dip,START,[NUCL,OPTPUNCT,COMMA,TAG]) :-
    START => max,
    START:max_type => t_dp,
    comma(COMMA),
    optend_punct(OPTPUNCT,Type),
    NUCL => start,
    NUCL:puncttype <=> Type,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% " Wie ben jij ? " , vroeg ik 
grammar_rule(start_dq1_max_dip,START,[DQ1,NUCL,OPTPUNCT,DQ2,COMMA,TAG]) :-
    ql(DQ1),
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    comma(COMMA),
    optend_punct(OPTPUNCT,Type),
    NUCL => start,
    NUCL:puncttype <=> Type,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% " Wie ben jij ? " , vroeg ik 
grammar_rule(start_dq2_max_dip,START,[NUCL,OPTPUNCT,DQ2,COMMA,TAG]) :-
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    comma(COMMA),
    optend_punct(OPTPUNCT,Type),
    NUCL => start,
    NUCL:puncttype <=> Type,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% ik kom , " zei hij 
grammar_rule(start_dq3_max_dip,START,[NUCL,COMMA,DQ2,TAG]) :-
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    comma(COMMA),
    NUCL => start,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% " ik kom , " zei hij 
grammar_rule(start_dq4_max_dip,START,[DQ1,NUCL,COMMA,DQ2,TAG]) :-
    ql(DQ1),
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    comma(COMMA),
    NUCL => start,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% Wie ben jij ? vroeg hij
grammar_rule(start_max_dip_no_comma,START,[NUCL,PUNCT,TAG]) :-
    START => max,
    START:max_type => t_dp,
    end_punct(PUNCT,Type),
    NUCL => start,
    NUCL:puncttype <=> Type,
    Type => ~komma, % reduce spur. amb.
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% " Wie ben jij ? " vroeg hij
grammar_rule(start_dq1_max_dip_no_comma,START,[DQ1,NUCL,PUNCT,DQ2,TAG]) :-
    ql(DQ1),
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    optend_punct(PUNCT,Type),
    Type => ~komma,  % use q4 rule
    NUCL => start,
    NUCL:puncttype <=> Type,
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% Wie ben jij ? " vroeg hij
grammar_rule(start_dq2_max_dip_no_comma,START,[NUCL,PUNCT,DQ2,TAG]) :-
    qr(DQ2),
    START => max,
    START:max_type => t_dp,
    optend_punct(PUNCT,Type),
    NUCL => start,
    NUCL:puncttype <=> Type,
    Type => ~komma,  % use q3 rule
    TAG => dip,
    nucl_tag_structure(NUCL,TAG,START).

%% Kok : " ik hou er mee op "
grammar_rule(np_dip,MAX,[NP,DUBB,XP,OPTEND]) :-
    optend_punct(OPTEND,Type),
    MAX => start,
    max_np(NP),
    NP:redrel => no,
    NP:subn => (sub_name;sub_noun),
    dubb(DUBB),
    XP => start,
    XP:puncttype <=> Type,
    nucl_tag_structure(XP,NP,MAX).

grammar_rule(np_quoted_dip,MAX,[NP,DUBB,DQ1,XP,OPTEND,DQ2]) :-
    optend_punct(OPTEND,Type),
    MAX => start,
    max_np(NP),
    NP:redrel => no,
    NP:subn => (sub_name;sub_noun),
    dubb(DUBB),
    XP => start,
    XP:puncttype <=> Type,
    ql(DQ1),
    qr(DQ2),
    nucl_tag_structure(XP,NP,MAX).

%% Lachend : " ik hou er mee op "
grammar_rule(ap_dip,MAX,[AP,DUBB,XP,OPTEND]) :-
    optend_punct(OPTEND,Type),
    MAX => start,
    % ap_arg(AP),
    max_nadv_ap(AP),
    dubb(DUBB),
    XP => start,
    XP:puncttype <=> Type,
    nucl_tag_structure(XP,AP,MAX).

%% Lachend : " ik hou er mee op "
grammar_rule(ap_quoted_dip,MAX,[AP,DUBB,DQ1,XP,OPTEND,DQ2]) :-
    optend_punct(OPTEND,Type),
    MAX => start,
    % ap_arg(AP),
    max_nadv_ap(AP),
    dubb(DUBB),
    XP => start,
    XP:puncttype <=> Type,
    ql(DQ1),
    qr(DQ2),
    nucl_tag_structure(XP,AP,MAX).

%% " dat is raar " zei hij " dat doet hij anders nooit "

grammar_rule(start_max_dip_max,START,[START1,COMMA1,DIP,COMMA2,START2]) :-
    START => start,
    max_root(START1), START1:needs_dip => no,
    max_root(START2), START2:needs_dip => no,
    START0 => start,
    comma(COMMA1),
    comma(COMMA2),
    dp_dp_structure(START1,START2,START0),
    DIP => dip,
    nucl_tag_structure(START0,DIP,START).

grammar_rule(start_max_dip_max_q,START,[QL1,START1,OPTEND1,QR1,COMMA1,DIP,COMMA2,QL2,START2,OPTEND2,QR2]) :-
    START => start,
    max_root(START1), START1:needs_dip => no,
    max_root(START2), START2:needs_dip => no,
    START0 => start,
    ql(QL1),
    qr(QR1),
    ql(QL2),
    qr(QR2),
    optcomma(COMMA1),
    optcomma(COMMA2),
    optend_punct(OPTEND1),
    optend_punct(OPTEND2),
    dp_dp_structure(START1,START2,START0),
    DIP => dip,
    nucl_tag_structure(START0,DIP,START).

grammar_rule(start_max_dip_max_q2,START,[QL1,START1,OPTEND1,QR1,COMMA1,DIP,COMMA2,QL2,START2,END]) :-
    START => start,
    max_root(START1), START1:needs_dip => no,
    max_root(START2), START2:needs_dip => no,
    START0 => start,
    ql(QL1),
    qr(QR1),
    ql(QL2),
    optcomma(COMMA1),
    optcomma(COMMA2),
    optend_punct(OPTEND1),
    end_punct(END),
    dp_dp_structure(START1,START2,START0),
    DIP => dip,
    nucl_tag_structure(START0,DIP,START).

grammar_rule(start_max_tag_max,START,[START1,COMMA1,TAG,COMMA2,START2]) :-
    START => start,
    START1 => start,
    START2 => start,
    START0 => start,
    comma(COMMA1),
    comma(COMMA2),
    dp_dp_structure(START1,START2,START0),
    TAG => tag,
    unify_mods(TAG),
    nucl_tag_structure(START0,TAG,START).

grammar_rule(start_tag_dip_max,START,[TAG,COMMA1,DIP,COMMA2,START1] ):-
    START => start,
    START1 => start,
    START0 => start,
    comma(COMMA1),
    comma(COMMA2),
    TAG => tag,
    unify_mods(TAG),
    DIP => dip,
    nucl_tag_structure(START1,TAG,START0),
    nucl_tag_structure(START0,DIP,START).

grammar_rule(start_tag_dip_max_q,START,[QL1,TAG,QR1,COMMA1,DIP,COMMA2,QL2,START1,OPTEND,QR2] ):-
    START => start,
    START1 => start,
    START0 => start,
    optcomma(COMMA1),
    optcomma(COMMA2),
    ql(QL1),
    qr(QR1),
    ql(QL2),
    qr(QR2),
    TAG => tag,
    optend_punct(OPTEND,Type),
    START1:puncttype <=> Type,
    unify_mods(TAG),
    DIP => dip,
    nucl_tag_structure(START1,TAG,START0),
    nucl_tag_structure(START0,DIP,START).

grammar_rule(start_tag_dip_max_q2,START,[QL1,TAG,QR1,COMMA1,DIP,COMMA2,QL2,START1,END] ):-
    START => start,
    START1 => start,
    START0 => start,
    optcomma(COMMA1),
    optcomma(COMMA2),
    ql(QL1),
    qr(QR1),
    ql(QL2),
    TAG => tag,
    end_punct(END,Type),
    START1:puncttype <=> Type,
    unify_mods(TAG),
    DIP => dip,
    nucl_tag_structure(START1,TAG,START0),
    nucl_tag_structure(START0,DIP,START).

%%%%%%%%%%%%%%%%%%%%%%
%%%% PREDICATIVES %%%%
%%%%%%%%%%%%%%%%%%%%%%

grammar_rule(pred_a,Pred,[A]) :-
    Pred => pred, A => a,
    A:aform => nattr,
    A:cj => ncj,		% reduce spur amb
    A:adv => ~oadv /*& ~detadv*/,
    A:hstem <=> STEM, dif(STEM,geworden),
    Pred:pcat => ap_pred,
    hd_structure(A,Pred).

grammar_rule(pred_np,Pred,[NP]) :-
    Pred => pred,
    NP => np, 
    NP:cj => ncj,     % reduce spur amb
    NP:nform => (norm;meas_mod),
    NP:bmeas => no,
    NP:pred => npred,
    NP:subn => ~sub_veel,
    NP:wkpro => ~weakpro,
    %% sub_indef_adj: dat zijn betere
    %% sub_*_verb:
    %%        wij vinden dat spijkers op laag water zoeken
    %%                       zeuren
    %% NP:redrel => no,   no: 'ik ben wie ik ben' 'wat je zegt ben je zelf'
    NP:case => (acc;gen),  % geef de keizer wat des keizers is
                           % dat is niet des Ajax
    Pred:pcat => np_pred,
    hd_structure(NP,Pred).

pred_pp_structure(Pred,PP) :-
    Pred => pred, Pred0 => pred,
    PP => pp,
    PP:cj => ncj,  % reduce spur.amb.
    PP:nnform => ~refl,
    PP:pp_role => pp_obj1,
    Pred:hstem <=> PP:prep,
    unify_except(Pred0,Pred,hstem),
    hd_structure(PP,Pred0).

grammar_rule(pred_pp_vol,Pred,[PP]) :-
    pred_pp_structure(Pred,PP),
    Pred:pcat => ap_pred,
    PP:ld_pc => pred_pp,
    PP:prep ==> vol.

%% "voor onbenullig" in "ik houd hem voor onbenullig"
grammar_rule(pred_pp_voor,Pred,[PP]) :-
    pred_pp_structure(Pred,PP),
    Pred:pcat => voor_pred,
    PP:ld_pc => pred_pp,
    PP:prep ==> voor.

%% "zoals X" in "hij is zoals hij is/zoals Piet"
grammar_rule(pred_zoals_cp,Pred,[CP]) :-
    Pred => pred,
    CP => sbar,
    CP:slash => [],
    CP:tags => [],
    CP:ctype => c_compare,
    Pred:pcat => zoals_pred,
    hd_structure(CP,Pred).

grammar_rule(pred_als_cp,Pred,[CP]) :-
    Pred => pred,
    CP => sbar,
    CP:slash => [],
    CP:tags => [],
    CP:ctype => c_als,
    Pred:pcat => als_pred,
    hd_structure(CP,Pred).

% grammar_rule(pred_als_cp,Pred, [ Comp, XP ]) :-
%     Comp => comp,
%     Pred => pred,
%     np_arg(NP),
%     cmp_body_structure(Comp,XP,Pred),
%     unify_except_l(NP,XP,[case,e_deps]),  % zoals ik/mij
%     XP:wkpro => ~weakpro,
%     XP:redrel => no,
%     XP:wh <=> Pred:wh,
%     Pred:slash => [],
%     Comp:ctype => c_als,
%     Pred:pcat => als_pred.

%%%%%%%%%%%%%%%%%%%%%%%
%%%% R pronominals %%%%
%%%%%%%%%%%%%%%%%%%%%%%

%% *er reken ik niet op
%% but
%% er wordt op gerekend
%% er bestaan voorbeelden van
%% er zijn mensen bang voor
%% so we don't make a distinction between NP[+er], once
%% they are promoted into nouns
grammar_rule(er_np,NP,[ADV]) :-
    ADV => adv,
    ADV:tmploc => (wk_er;str_er),
    ADV:redrel => no,
    max(ADV0),
    unify_except(ADV0,ADV,exs), % ik wil nergens anders op rekenen dan op jou
    NP => np,
    NP:nform => er,
    hd_structure(ADV,NP).

%%%%%%%%%%%%%%%%%%%%%%
%%%% MODIFICATION %%%%
%%%%%%%%%%%%%%%%%%%%%%

grammar_rule(adv_a,Adv,[Adj]) :-
    Adv => adv,
    ap_arg(Adj),
    Adv:subadv => subadv_adj,
    Adj:cj => ncj, % reduce spurious amb.
    Adj:adv => (yadv;oadv),
    Adj:agr => het & indef & sg, % should not have -e suffix!
    Adj:aform => nattr,  % was: (attr;nattr)
    hd_structure(Adj,Adv).

grammar_rule(adv_meer,Adv,[Niet,Meer]) :-
    Adv => adv, Niet => adv, Meer => post_adv_adv,
    Niet:wk => no,
    Niet:redrel => no,
    Niet:haspre => no,
    Niet:cj => ncj, % red. amb. in 'niet alleen ... maar ... ook'
                    % 'niet of niet meer' only narrow scope of "meer"
    Niet:tmploc => ~str_er & ~wk_er & ~postp & ~hoe_hoe & ~tmp_n,
    hd_mod_structure(Niet,Meer,Adv).

grammar_rule(adv_ergens,Adv,[Daar,Ergens]) :-
    Adv => adv, Daar => adv, Ergens => post_loc_adv_adv,
    Daar:wk => no,
    Daar:redrel => no,
    Daar:haspre => no,
    Daar:tmploc => loc,
    hd_mod_structure(Daar,Ergens,Adv).

grammar_rule(daarom_immers,Adv,[Daarom,Immers]) :-
    Adv => pp, Daarom => pp, Immers => post_adv_adv,
    Adv:pp_er => yes,
    Daarom:pp_er => yes,
    Daarom:pp_role => pp_obj1,
    hd_mod_structure(Daarom,Immers,Adv).

grammar_rule(daarboven_ergens,Adv,[Daarom,Immers]) :-
    Adv => pp, Daarom => pp, Immers => post_loc_adv_adv,
    Adv:pp_er => yes,
    Daarom:ld_pc => (n_pp;ld_pp;mod_pp),
    Daarom:pp_er => yes,
    Daarom:pp_role => pp_obj1,
    hd_mod_structure(Daarom,Immers,Adv).

grammar_rule(adj_genoeg,Adj,[Gek,Genoeg]) :-
    Adj => a, Gek => a, Genoeg => post_adj_adv, 
    Gek:agr => het & indef & sg, % should not have -e suffix!
    Gek:aform => nattr,
    Gek:adv => ~detadv,
    hd_mod_structure(Gek,Genoeg,Adj).

%% modifier introduced by rule
%% very tolerant..

%% ADVERBs
grammar_rule(mod1, Mod, [ Adv ] ) :-
    Mod => modifier, Adv => adv,
    
    Mod:sel => (to_left;to_topic),
    Adv:tmploc => (ntmploc;wk_er),

    Mod:mcat => mcat_adv,
    Adv:cj => ncj, % diy
    Adv:redrel => no,
    hd_structure(Adv,Mod).

grammar_rule(mod1a, Mod, [ Adv ] ) :-
    Mod => modifier, Adv => adv,
    
    Mod:eps => no,
    Adv:tmploc => (tmp;tmp_n;meas_n;loc;sent;me;postp),

    Mod:mcat => mcat_adv,
    Adv:cj => ncj, % diy
    Adv:redrel => no,
    hd_structure(Adv,Mod).

grammar_rule(mod1b, Mod, [ Adv ] ) :-
    Mod => modifier, Adv => adv, 

    Mod:sel => to_right,
    Mod:eps => no,
    Adv:can_postv => yes,
    Adv:exs => [], % diy

    Mod:mcat => mcat_adv,
    Adv:cj => ncj, % diy
    Adv:redrel => no,
    hd_structure(Adv,Mod).

%% PPs
grammar_rule(mod2, Mod, [ Pp ] ) :-
    Mod => modifier, Pp => pp,

    No => no,
    Yes => yes,
    Pp:pp_er <=> ER,
    Mod:sel <=> Sel,
    NotRight => ~to_right,

    when(nonvar(ER),
	 (  ER = No
	 ;  ER = Yes, Sel = NotRight
	 )),
    
    Mod:mcat => mcat_pp,
    Mod:eps => no,
    Pp:cj => ncj, % diy
    Pp:e_deps => [],    % otherwise spurious ambiguities
    Pp:nnform => ~refl, % id.
    Pp:ld_pc => (mod_pp;pred_pp),
    Pp:pp_role => pp_obj1,
    Pp:vc => yes,
    hd_structure(Pp,Mod ).

%% SBARs
grammar_rule(mod5, Mod, [ Sbar ]) :-
    Mod => modifier,
    Mod:mcat => mcat_sbar,
    Sbar => sbar,
    Sbar:cj => ncj, %diy
    Sbar:tags => [],
    Sbar:ctype => (c_mod;c_compare),
    Sbar:e_deps => [],
    Mod:eps => no,
    hd_structure(Sbar,Mod).

%% SBARs
%% TODO: rule this out where normal relative is possible...
%% TODO: disallow 'die/wie' relative, since this refers to 'proposition' ?
grammar_rule(mod5rr, Mod, [ Sbar ]) :-
    Mod => modifier,
    redrel_modifier(Sbar),
    Mod:mcat => mcat_redrel,
    Mod:eps => no,
    hd_structure(Sbar,Mod).

%% we moeten doorwerken willen we op tijd komen
%% we hebben geluk mocht dat doorgaan
grammar_rule(mod7, Mod, [ SV1 ]) :-
    Mod => modifier, SV1 => sv1,
    Mod:mcat => mcat_imp,
    Mod:sel => (to_right;to_topic),
    SV1:cj => ncj, % diy
    SV1:sv1_mod => yes,
    SV1:can_be_max => yes,
    max_sv1(SV1),
    hd_structure(SV1, Mod).

/*
extremely slow
%% aan zijn reactie zien heeft hij ...
grammar_rule(mod8,Mod,[X]) :-
    X => vp,
    X:vform => pass_te,
    X:e_deps => [],
    %% to prevent clefts etc:
    X:cleft => no,
    X:subj => np,
    X:subj:nform => (norm;het_nform),
    X:subj:subn => sub_noun,
    X:subj:allows_drop => yes,
    X:subj:dt => [],    
    %%
    X:haswh => no,
    Mod => modifier, 
    Mod:mcat => mcat_vp,
    Mod:sel => to_topic,
    hd_structure(X,Mod).
*/

modifier_p_start_structure(Mod,Mod1,P1,P2) :-
    Mod1 => modifier,
    Mod1:eps => no,
    Mod => start,
    Mod1:mcat => mcat_bracket,
    P1 => punct,
    P2 => punct,
    hd_structure(Mod,Mod1).

%% modifier --> ( modifier )
grammar_rule(modifier_p(1), Mod1,[P1, Mod, OptQm, P2 ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    modifier_p_start_structure(Mod,Mod1,P1,P2),
    optend_mod_punct(OptQm),
    P1:puncttype => haak_open,
    P2:puncttype => haak_sluit.

grammar_rule(modifier_p(1), Mod1,[P1, Mod, OptQm, P2 ]):-
    hdrug_util:hdrug_flag(parse_or_generate,generate),
    Mod1 => modifier,
    Mod1:eps => no,
    max_np(Mod), 
    Mod:nform => ~temp,
    Mod:subn => ~sub_indef_adj,
    Mod:can_mod => no,
    Mod1:mcat => mcat_bracket,
    P1 => punct,
    P2 => punct,
    hd_structure(Mod,Mod1),
    optend_mod_punct(OptQm),
    P1:puncttype => haak_open,
    P2:puncttype => haak_sluit.

%% modifier --> - modifier -
grammar_rule(modifier_p(2), Mod1,[P1, Mod, OptQm, P2 ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    modifier_p_start_structure(Mod,Mod1,P1,P2),
    optend_mod_punct(OptQm),
    P1:puncttype => ligg_streep,
    P2:puncttype => ligg_streep.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%% rules for adverbs %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% predm_adv --> predm_adv_num number
%% ze gingen alle zes naar huis
grammar_rule(alle_zes, ADV, [ ALLE, ZES ]) :-
    ADV => predm_adv,
    ALLE => predm_adv_num,
    ZES => num, 
    ZES:app => yes,
    hd_det_structure(ALLE,ZES,ADV).

%% predm_adv --> predm_adv_num number
%% alle zes de aanwezigen
grammar_rule(alle_zes_pre_det_quant, ADV, [ ALLE, ZES ]) :-
    ADV => pre_det_quant,
    ALLE => predm_adv_num,
    ZES => num, 
    ZES:app => yes,
    hd_det_structure(ALLE,ZES,ADV).

%% eenmaal stoned/president/binnen ...
grammar_rule(eenmaal_absolute, ADV, [ EENMAAL, PRED ]) :-
    ADV => predm_adv,
    EENMAAL => eenmaal_adv,
    max_pred(PRED),
    unify_mods(PRED),
    dp_dp_structure(EENMAAL,PRED,ADV).

grammar_rule(eenmaal_absolute_loc, ADV, [ EENMAAL, LOC ]) :-
    ADV => predm_adv,
    EENMAAL => eenmaal_adv,
    max_advp(LOC),
    LOC:tmploc => loc,
    unify_mods(LOC),
    dp_dp_structure(EENMAAL,LOC,ADV).

grammar_rule(eenmaal_absolute_pp, ADV, [ EENMAAL, LOC ]) :-
    ADV => predm_adv,
    EENMAAL => eenmaal_adv,
    LOC => pp,
    LOC:ld_pc => ld_pp,
    LOC:wh => nwh,
    LOC:nnform => ~refl,
    LOC:pp_role => pp_obj1,
    max(LOC),
    unify_mods(LOC),
    dp_dp_structure(EENMAAL,LOC,ADV).

%% XP --> adv XP
%% juist Jan
%% ook in Amsterdam

xp_modal_xp_structure(X,Adv,XP) :-
    Adv => modal_adv,
    hd_mod_structure(X,Adv,XP).

grammar_rule(xp_modal_xp(np),XP,[Adv,X]):-
    XP => np,
    X:has_app => no,   % reduce spurious ambiguities
    XP:nform => (norm;temp;temp_meas_mod;meas_mod),
                        % zeker de laatste jaren; vooral deze week...
                        % bijna de hele weg
                        % ook daar werd altijd flink op gehamerd
                        % al begin jaren tachtig
    X => np,
    X:wh => nwh,
%    X:redrel => no,   % Alleen wie lief is krijgt lekkers
    Adv:modal_adv_arg => adv_noun,

    YES => yes,
    NO => no,
    X:hdet <=> HDET,
    X:subn <=> SUBN,
    NNUM => ~sub_num & ~sub_veel,      % use normal adverb for that

    when(nonvar(HDET),
	 (  HDET=NO,  SUBN=NNUM
	 ;  HDET=YES
	 )),
    
%   wrong: "alleen die twee hebben ..."
    xp_modal_xp_structure(X,Adv,XP).

grammar_rule(xp_modal_xp(sbar),X,[Adv,OPTCOMMA,Y]):-
    X => sbar,
    X:ctype => (c_mod;c_als;c_compare;c_compare_np;c_dat),
    %% ook dat ze arm zijn deert ze niet
    %% vooral dat ze niet komen stoorde mij zeer
    Y => sbar,
    Y:tags => [],
    Adv:modal_adv_arg => adv_comp,
    optcomma(OPTCOMMA),
    xp_modal_xp_structure(Y,Adv,X).

grammar_rule(xp_modal_xp(prep),X,[Adv,Y]):-
    X => p,
    Y => p,
    X:wh => nwh,
    Adv:modal_adv_arg => adv_prep,
    xp_modal_xp_structure(Y,Adv,X).

grammar_rule(niet_pp,X,[Adv,Y]):-
    X => pp,
    Y => pp,
    X:pp_er => no,
    X:sel => to_topic,
    Y:sel => to_topic,
    X:wh => nwh,
    Adv => adv,
    Adv:hstem ==> niet,
    Adv:redrel => no,
    Adv:subadv => subadv_adv,
    Adv:tmploc => ntmploc,
    hd_mod_structure(Y,Adv,X).

grammar_rule(xp_modal_xp(pp),X,[Adv,Y]):-
    X => pp,
    Y => pp,
    X:wh => nwh,
    X:vc <=> Y:vc,
    Y:slash => [],
    %% NB: this rule is only required now for conjunctions
    %%     to get wide scope "vooral voor de rust en na de rust"
    %%     and also for "lexical" PP's
    %%     "vlak hiervoor"
    %%     so we forbid that Y is a simple PP[P XP] struct
    Y:allow_modal => yes,
    Adv:modal_adv_arg => adv_prep,
    xp_modal_xp_structure(Y,Adv,X).

grammar_rule(p_npmod_p,X,[Adv,Y]):-
    X => p,
    Y => p,
    X:ld_pc => (ld_pp;mod_pp;n_pp),
    X:preptype => ld_prep,
    X:wh => nwh,
    Adv => adv,
    Adv:tmploc => (tmp_n;meas_n),
    Adv:nsubn => ~sub_tmp,
    hd_mod_structure(Y,Adv,X).

grammar_rule(pp_npmod_pp,X,[Adv,Y]):-
    X => pp,
    Y => pp,
    Y:slash => [],
    Y:allow_modal => yes,
    X:vc <=> Y:vc,
    X:ld_pc => (ld_pp;mod_pp;n_pp),
    X:preptype => ld_prep,
    X:wh => nwh,
    Adv => adv,
    Adv:tmploc => (tmp_n;meas_n),
    Adv:nsubn => ~sub_tmp,
    hd_mod_structure(Y,Adv,X).

%% twee jaar voordat, voor, nadat ...
grammar_rule(sbar_npmod_sbar,X,[Adv,OPTCOMMA,Y]):-
    X => sbar,
    X:slash => [],
    X:ctype => c_mod,
    Y => sbar,
    Y:tags => [],
    optcomma(OPTCOMMA),
    Adv => adv,
    Adv:tmploc => tmp_n,
    Adv:nsubn => ~sub_tmp,
    hd_mod_structure(Y,Adv,X).

grammar_rule(xp_modal_xp(adv),X,[Adv,Y]):-
    X => adv,
    Y => adv,
    Y:tmploc => ~postp & ~wk_er & ~hoe_hoe,
    Y:subadv => ~subadv_noun,  % reduce spur amb in 'bijna drie weken'
    Y:subadv => ~subadv_adj,   % use normal adverb in that case; all modal_adv are adv?
    X:redrel => no,
    Adv:modal_adv_arg => adv_adv,
    X:haspre => yes,
    xp_modal_xp_structure(Y,Adv,X).

grammar_rule(xp_modal_xp(vp),X,[Adv,Y]):-
    X => vp,
    X:mf => [],
    X:vform => om,
    Y => vp,
    xp_modal_xp_structure(Y,Adv,X),
    Adv:modal_adv_arg => adv_verb.

grammar_rule(xp_modal_xp(vp_modifier),X,[Adv,Y]) :-
    X => modifier,
    Y => modifier,
    X:mcat => mcat_vp,
    Y:mcat => mcat_vp,
    xp_modal_xp_structure(Y,Adv,X),
    Adv:modal_adv_arg => adv_verb.

grammar_rule(adv_adv_pps, AdvP,[ Adv, OPTCl, PP ] ) :-
    AdvP => adv, Adv => adv, PP => pp,
    optcomma(OPTCl),
    Adv:wk => no,
    Adv:tmploc => (loc;tmp), % hier in Almelo
				  % gisteren om half zes
    Adv:haspre => no,
    % Adv:wh => nwh,  % but: waar in Groningen heb je gewoond?
                      %      wanneer in februari heb je tijd?
    Adv:subadv => ~subadv_adj,  % reduce spur. amb.; use a_a_pp rule
    Adv:redrel => no,
    Adv:modifies_a => no, % 16 Nov 2010
    pp_modifier(PP),
    PP:sel => to_right,
    PP:vc => yes,
    hd_mod_structure(Adv,PP,AdvP).

%% VLAAMS
grammar_rule(vandaag_woensdag, AdvP,[ Adv, TEMP ] ) :-
    AdvP => adv, Adv => adv, 
    Adv:wk => no,
    Adv:tmploc => tmp, % vandaag woensdag
    Adv:haspre => no,
    % Adv:wh => nwh,  % but: waar in Groningen heb je gewoond?
                      %      wanneer in februari heb je tijd?
    Adv:subadv => ~subadv_adj,  % reduce spur. amb.; use a_a_pp rule
    Adv:redrel => no,
    Adv:modifies_a => no,
    TEMP => np,
    TEMP:redrel => no,
    TEMP:pred => npred,
    TEMP:nform => temp,
    TEMP:e_deps => [],
    TEMP:cj => ncj,
    TEMP:bmeas => no,
    TEMP:case => acc,
    hd_mod_structure(Adv,TEMP,AdvP).

grammar_rule(adv_adv_rel, AdvP, [Adv, OPTCl, Rel, OPTCr ]) :-
    AdvP => adv,  Adv => adv,  Rel => rel,
    Adv:wk => no,
    Adv:redrel => no,
    Adv:haspre => no,
    Adv:wh => nwh,
    Adv:tmploc => loc,
    Adv:modifies_a => no, % 16 Nov 2010
    optcomma(OPTCl),
    optcomma(OPTCr),
    hd_rel_structure(Adv,Rel,AdvP).

grammar_rule(adv_adv_sbar,AdvP,[Adv,OPTCl,Sbar,OPTCr]) :-
    AdvP => adv, Adv => adv,
    Adv:wk => no,
    Adv:redrel => no,
    Adv:wh => nwh,
    Adv:tmploc => (tmp;tmp_n),  % vanavond als ik slaap
                                % twee weken voordat ik vertrok
    Adv:haspre => no,
    Adv:modifies_a => no, % 16 Nov 2010
    max_sbar(Sbar),
    Sbar:ctype => c_mod,
    optcomma(OPTCl),
    optcomma(OPTCr),
    hd_mod_structure(Adv,Sbar,AdvP).

grammar_rule(adv_tmp_np,Adv,[NP]) :-
    Adv0 => adv,
    unify_except(Adv0,Adv,wh_reltmploc),
    Adv:wh_reltmploc => tmp_n,
    Adv:subadv => subadv_noun,
    Adv:tmploc => tmp_n,
    NP => np,
    NP:redrel => no,
    NP:pred => npred,
    NP:nform => temp,
    NP:e_deps => [],
    NP:cj => ncj,
    NP:bmeas => no,
    NP:case => acc,
    Adv:nsubn <=> NP:subn,
    hd_structure(NP,Adv0).

grammar_rule(adv_meas_np,Adv,[NP]) :-
    Adv0 => adv,
    unify_except(Adv0,Adv,wh_reltmploc),
    Adv:wh_reltmploc => meas_n,
    Adv:subadv => subadv_noun,
    Adv:tmploc => meas_n,
    NP => np,
    NP:redrel => no,
    NP:pred => npred,
    NP:nform => meas_mod,
    NP:case => acc, % also ensures no application of meas_np_agreement_mismatch
    NP:e_deps => [],
    NP:cj => ncj,
    NP:bmeas => no,
    hd_structure(NP,Adv0).

grammar_rule(adv_mod_np,Adv,[NP]) :-
    Adv0 => adv,
    unify_except(Adv0,Adv,wh_reltmploc),
    Adv:wh_reltmploc => (meas_n;tmp_n),
    Adv:subadv => subadv_noun,
    Adv:tmploc => (meas_n;tmp_n),
    NP => np,
    NP:redrel => no,
    NP:pred => npred,
    NP:nform => temp_meas_mod,
    NP:case => acc, % also ensures no application of meas_np_agreement_mismatch
    NP:e_deps => [],
    NP:cj => ncj,
    NP:bmeas => no,
    hd_structure(NP,Adv0).

%% ergens/nergens/waar anders
grammar_rule(adv_adv_adj,ADVP,[ADV,A]) :-
    ADVP => adv,
    ADV => iets_adv,
    ADVP:tmploc => (loc;str_er),
    nwh_ap_arg(A),
    A:aform => anders,
    hd_mod_structure(ADV,A,ADVP).

grammar_rule(waar_nodig,REL0,[Waar,Nodig]) :-
    REL => rel, REL0 => rel,
    REL:tmploc => loc,
    max_ap(Nodig),
    Waar => adv,
    Waar:tmploc => loc,
    Waar:wh => rywh,
    xy_dep_dt(Nodig,Waar,REL,body,rhd),
    unify_except(REL0,REL,hstem),
    non_hd_structure([Waar,Nodig],REL,rel).

%%%%%%%%%%%%%%%%%%%%%%
%%%% NOUN PHRASES %%%%
%%%%%%%%%%%%%%%%%%%%%%

%% iedere twee jaar; elke drie weken

grammar_rule(np_tmp_det_num_n, NP, [ Det, Num, N ]) :-
    NP => np,
%%    NP:nform => temp,  van elke duizend werknemers
    NP:agr => pl,
    Det => tmp_det,
    Num => num,
    N => n,
    N_mid => n,
    NP:wh => nwh,
    hd_det_structure(Num,N,N_mid),
    hd_det_structure(Det,N_mid,NP).

%% Piet zijn vader
%% niemand zijn vader
%% Wie zijn vader
grammar_rule(det_np_det,DP,[NP,DET]) :-
    DET => gen_det,
    DP0 => det,
    max_np(NP0),
    unify_except_l(DP0,DP,[wh,agr]),  % resulting determiner phrase has arb agr?
    DP:agr => def,
    DP:neclass ==> none,
    unify_except_l(NP0,NP,[wh_reltmploc,wh]),
    NP:nform => norm,
    NP:subn => (sub_noun;sub_name;sub_def_pron;sub_indef_pron;sub_def_adj),
                                % sub_adj: de ene zijn dood
    DET:agr <=> NP:agr,
    NP:prs => thi,
    NP:case => ~gen & ~nom,
    DP:case => ~gen,
    DP:wh <=> NP:wh,
    DP:wh_reltmploc <=> NP:wh_reltmploc,
    DP:modf => no,
    DP:pro => no,
    DP:exs => [],
    hd_mod_structure(DET,NP,DP0).

%% re-implemented in order to satisfy requirements of CGN annotation guide
grammar_rule(np_det_n, NP, [ Det, N ] ) :-
    np_det_n_structure(NP,Det,N).

grammar_rule(np_det_n_q, NP, [ QL, Det, N, QR ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    ql(QL),
    qr(QR),
    np_det_n_structure(NP,Det,N).

np_det_n_structure(NP,Det,N) :-
    NP0 => np, Det => det, N => n,
    hd_det_structure(Det,N,NP0,np),
    unify_except_l(NP0,NP1,[wh,wh_reltmploc]), % ignore hfc

    wh_principle(Det,N,NP1),
    Det:has_obcomp => no,  % *meer dan ik dacht kinderen
    N:hdet => yes,
    Det:case <=> NP0:case,
    Det:agr <=> N:agr,
    Det:nsubn <=> N:subn,
    add_rel(NP1,NP).

%% could (should?) be done with threading;
%% if Det is wh+ percolate that to NP
%% if N is wh+ percolate that to NP
%% otherwise nwh
%% also, wh_reltmploc info should be part
%% of wh feature
wh_principle(Det,N,NP) :-
    N:wh <=> N_WH,
    Det:wh <=> DET_WH,
    NP:wh <=> NP_WH,
    N:wh_reltmploc <=> N_WHR,
    Det:wh_reltmploc <=> DET_WHR,
    NP:wh_reltmploc <=> NP_WHR,

    NQNLEX:rlex => no,
    
    NoWH => nwh,

    when( ?=(DET_WH,NoWH),
	  (  DET_WH=NoWH,
	     N_WH=NP_WH,
	     N_WHR=NP_WHR
	  ;  DET_WH \= NoWH,
	     DET_WH=NP_WH,
	     DET_WHR=NP_WHR,
	     N_WH=NoWH,
             NP_WH=NQNLEX
	   )
	 ).
	      
/*

wrong: should forbid post-head modifiers

*een groot aantal schurken schurken
*een groot aantal in Amsterdam schurken

%% een groot aantal schurken werden opgepakt
grammar_rule(det_np,DET, [ NP ]) :-
    DET => det,
    unify_except(DET,DET0,agr),
    NP => np,
    DET:agr => pl,
    DET:wh => nwh,
    DET:case => ~gen,
    DET:pro => no,
    DET:modf => no,
    NP:agr => sg,
    NP:nform => norm,
    NP:hstem <=> Stem,
    alpino_wappend:wmember(Stem,[aantal,soort,tal]),
    hd_structure(NP,DET0,np).

*/

%%% TODO?
%%% gedode aantal soldaten per land

grammar_rule(np_n, NP,  [ N ] ) :-
    np_n_structure(NP,N).

np_n_structure(NP,N) :-
    NP0 => np, N => n,
    NP0:agr => indef,
    NP0:subn => ~sub_def_verb,  % !
    NP0:subn => ~sub_def_adj & ~sub_indef_adj,       % cf np_adjn,
    NP0:case => ~gen,
    N:hdet => no,
    N:bmeas <=> NP:bmeas,
    N:cj => ncj,		% Lenooor: prevent '[np [N and N]]' because
				% that would assign cat=np instead of cat=conj
    hd_structure(N,NP0,np),
    add_rel(NP0,NP).

grammar_rule(np_zoon_n,NP,[ ADV, N ]) :-
    NP => np,
    NP:case => ~gen,
    N => n,
    N:amount => yes,
    N:hdet => no,
    ADV => pre_num_adv,
    ADV:agr <=> NP:agr,
    NP0 => np,
    hd_mod_structure(N,ADV,NP0),
    add_rel(NP0,NP).

%% separate rule to prevent agreement mismatch
%% (because only -e adjectives are allowed in n-->adj)
grammar_rule(np_adjn, NP,  [ N ] ) :-
    NP0 => np, N => n,
%    NP0:agr => indef,   % enige wat ik niet begrijp is ...
                         % eerste/laatste wat ik zou doen ..
    NP0:subn => sub_indef_adj,
    NP0:case => ~gen,
    N:hdet => no,
    N:cj => ncj,		% Lenooor: prevent '[np [N and N]]' because
				% that would assign cat=np instead of cat=conj
    hd_structure(N,NP0,np),
    add_rel(NP0,NP).

np_pron_structure(PRON,NP) :-
    PRON => pron,
    NP => np,
    NP:hdet => no,
    NP:pred => npred,
    NP:e_deps => [],
    NP:parg <=> PRON:parg,
    hd_structure(PRON,NP,np).

grammar_rule(np_pron, NP,  [ PRON ] ) :-
    NP => np,
    NP:wkpro => strongpro,
    np_pron_structure(PRON,NP0),
                      % new: extraposition now only for sub-class of pronouns
                      %  otherwise many false parses using this possibility
    add_rel(NP0,NP).

grammar_rule(np_pron_weak, NP,  [ PRON ] ) :-
    np_pron_structure(PRON,NP),
    NP:wkpro => ~strongpro.

grammar_rule(pron_det, PRON, [ DET ] ) :-
    PRON => pron, 
    DET => det,
    DET:pro => yes,
    DET:parg <=> PRON:parg,
    PRON => pron,
    hd_structure(DET, PRON).

%% twee procent meer rente dan voorheen
grammar_rule(det_me_det, M, [ ME, DET ] ) :-
    M => det,
    DET => det,
    np_me_arg(ME),
    DET:parg <=> M:parg,
    hd_comp_structure(DET, ME, M).

grammar_rule(pron_pron_pps, NP,[ N, PP ] ) :-
    NP => pron, N => pron, PP => pp,
    pp_modifier(PP),
    PP:sel => to_right,
    PP:vc => yes,
    N:wkpro => ~weakpro,
    pron_mod_structure(N,PP,NP).

grammar_rule(pron_pron_rel, NP, [N, OPTCl, Rel, OPTCr ]) :-
    NP => pron,  N => pron,  Rel => rel,
    N:wkpro => ~weakpro,
%    Rel:relform => (relform_fin;relform_inf), % perhaps allow: [niemand om mee te spelen]
    optcomma(OPTCl),
    optcomma(OPTCr),
    hd_rel_structure(N,Rel,NP).

grammar_rule(pron_pron_dus, NP, [N, Adv ]) :-
    NP => pron,  N => pron,  Adv => post_np_adv,
    pron_mod_structure(N,Adv,NP).

%% dit gevoegd bij het feit ..
%% dat gekoppeld aan zijn enthousiasme gaf de doorslag
%% dat samen ...
grammar_rule(pron_pron_mod_a, N, [ N0, OPTCl, MOD, OPTCr ]) :-
    optcomma(OPTCr),
    optcomma(OPTCl),
    max_nadv_ap(MOD0),
    unify_except(MOD0,MOD,adv),
    MOD:adv => ~oadv & ~detadv,
    MOD:tmploc => ~wk_er & ~str_er & ~tmp & ~tmp_n & ~ld_dir & ~me, 
    MOD:can_postn_with_cform => yes,
    MOD:can_postn => yes,
%%%    N:subn => sub_det, % dit, dat, ...
%%% wij samen; jullie samen    
    pron_mod_structure(N0,MOD,N).

%% cdb 4026
grammar_rule(pron_pron_modroot(haak), N, [ N0, Cl, ROOT, OptQm, Cr ]) :-
    Cl => punct, Cr => punct,
    Cl:puncttype => haak_open, Cr:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    ROOT => start,
    pron_mod_structure(N0,ROOT,N).

grammar_rule(pron_pron_modroot(min), N, [ N0, Cl, ROOT, Cr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Cl => punct, Cr => punct,
    Cl:puncttype => ligg_streep, Cr:puncttype => ligg_streep,
    ROOT => start,
    pron_mod_structure(N0,ROOT,N).

%% Wij Nederlanders
grammar_rule(pron_pron_napp, NP, [ N, APP ]) :-
    NP => pron, N => pron, APP => n,
    NP:agr => pl&def,    % required?
    APP:agr => pl,       % required?
    NP:wkpro => ~weakpro,  % required?
    NP:subn => sub_def_pron, % required?
    APP:subn => sub_noun,% required?
    hd_app_structure(N,APP,NP).

pron_mod_structure(N,MOD,NP) :-
    NP => pron, N => pron,
    N:wkpro => ~weakpro,
    hd_mod_structure(N,MOD,NP).

%% (n)iets om
%% dit om 

%% n --> n n
%% een zak aardappelen
%% ambiguities exist now between
%% een [zak [aardappelen met klei]   ]
%% een [zak [aardappelen] met korting]
%% Do we want that?
%%
%% the N daughter effectively is an island for mexs now
%% we don't get: "omdat ik een groep medicijnen bestel die mij helpen"
grammar_rule(n_n_napp, NP, [ APP_N, N ]) :-
    NP => n, APP_N => app_n, N => n,
    NP:wh => nwh,
    NP:nform <=> N:nform,  % tientallen keren
    N:e_deps => [],
    N:pred => npred,
    N:subn => ~sub_num,
    NP:subn => sub_noun,
    NP:bmeas <=> APP_N:bmeas,
    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (   PG == parse
    ;   PG == generate,               % *een scherm volledige
	N:subn => ~sub_indef_adj,     % alleenstaande massa's --> *massa's alleenstaanden
	N:subn => ~sub_def_adj
    ),

%    N:subn => ~sub_verb & ~sub_name,
				% but:   een rondje fietsen
				%        een eindje rijden
				%        na het uurtje zwemmen
                                %   een kan drinken
                                %   een bord eten
                                % names should become app
                                % but:   tien jaar Bijlmer
    hd_mod_structure(APP_N,N,NP).


grammar_rule(n_n_npapp, NP, [ APP_N, N ]) :-
    NP => n, APP_N => app_np_mod, N => np,
    NP:wh => nwh,
    NP:nform <=> N:nform,  % tientallen keren
    N:e_deps => [],
    N:pred => npred,
    N:subn => ~sub_num,
    NP:subn => sub_noun,
%    N:subn => ~sub_verb & ~sub_name,
				% but:   een rondje fietsen
				%        een eindje rijden
				%        na het uurtje zwemmen
                                % names should become app
                                % but:   tien jaar Bijlmer
    hd_mod_structure(APP_N,N,NP).

%% het woord fietsen
%% de maand juni
grammar_rule(n_n_napp_app, NP, [ APP_N, N ]) :-
    NP => n, APP_N => app_n_app, N => n,
    NP:wh => nwh,
    NP:nform => ~meas_mod & ~temp_meas_mod,
    N:e_deps => [],
    N:pred => npred,
    N:subn => ~sub_name & ~sub_num,  % we'll get that one anyway
    NP:subn => sub_noun,
    hd_app_structure(APP_N,N,NP).

%% het motto " we zullen wel zien "
%% het motto : we zullen wel zien .
grammar_rule(n_n_napp_app_start1,NP,[APP_N,DUBB,OPTQL,START,OPTPUNCT,OPTQR ]):-
    NP => n, APP_N => start_app_n_app, START => start,
    dubb(DUBB),
    optql(OPTQL),
    optqr(OPTQR),
    OPTPUNCT => optpunct,
    OPTPUNCT:cat <=> Punct,
    Punct => punct,
    Punct:puncttype => (vraag;uitroep;hellip),
    NP:subn => sub_noun,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    hd_app_structure(APP_N,START,NP).

grammar_rule(n_n_napp_app_start_colon,NP,[APP_N,DUBB ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    NP => n, APP_N => start_app_n_app, START => start,
    dubb(DUBB),
    NP:subn => sub_noun,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    START:dt => [], % !
    hd_app_structure(APP_N,START,NP).

grammar_rule(n_n_napp_app_start2, NP, [APP_N,DL,START,OPTPUNCT,DR ]) :-
    NP => n, APP_N => start_app_n_app, START => start,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    ql(DL),
    qr(DR),
    OPTPUNCT => optpunct,
    OPTPUNCT:cat <=> Punct,
    Punct => punct,
    Punct:puncttype => (vraag;uitroep;hellip),
    NP:subn => sub_noun,
    hd_app_structure(APP_N,START,NP).

%% meneer de voorzitter; meneer de pastoor
grammar_rule(np_n_napp_app, NP, [ APP_N, N ]) :-
    NP => n, APP_N => app_np, N => np,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    N:agr => def,  % reduce spurious ambiguities "Mevrouw Sanders"
    N:e_deps => [],
    N:pred => npred,
    NP:subn => sub_noun,
    N:subn => (sub_noun;sub_name),
    hd_app_structure(APP_N,N,NP).

%% half januari
%% eind 1979
%% eind dit jaar
%% hd-mod is the CGN analysis...
grammar_rule(n_n_tmpnapp, ADV, [ APP_N, N ]) :-
    ADV => adv, APP_N => tmp_app_n, N => np,
    ADV:wh => nwh,
    ADV:tmploc => tmp,
    ADV:wh_reltmploc => tmp,
    N:nform => (temp;year),
    N:pred => npred,
    N:subn => (sub_noun;sub_tmp),
    hd_mod_structure(APP_N,N,ADV).

%% de begin jaren tachtig
%% TODO: agr, def,
%% 
grammar_rule(np_n_tmpnapp, NP, [ DET, APP_N, N ]) :-
    NP0 => np,
    NP => np,
    APP_N => tmp_app_n, N => np,
    DET => det,
    NP:wh => nwh,
    NP:nform => norm,
    NP:subn => sub_tmp,
    N:nform => (temp;year),
    N:pred => npred,
    N:subn => sub_noun,
    hd_mod_structure(APP_N,N,NP0),
    hd_det_structure(DET,NP0,NP,np).

%% de familie Beerta
%% TODO: prevent post-n modifiers attached to N?
%% NO: minister van justitie X
grammar_rule(n_n_pnapp, NP, [ N, PN ]) :-
    n_n_pnapp_structure(NP,N,PN).

n_n_pnapp_structure(NP,N,PN) :-
    PN => pn,
    n_n_app_structure(NP,N,PN).

n_n_app_structure(NP,N,PN) :-
    NP => n, N => n,
    haspreno(NP),  %%%    NP:haspre => no, % for generation we can't have this
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    N:rightm => no,
    N:subn => (sub_noun;sub_adj_pl),  % Real miste de geblesseerden Gareth Bale en Toni Kroos
    N:cj => ~no_crd,    % Gerlof: de dichter en schrijver Jan Wolkers
    hd_app_structure(N,PN,NP).

%% [president Jeltins] regering
grammar_rule(n_n_pnappgen, NP, [ N, PN ]) :-
    NP0 => det, N => n, PN => det,
    NP0:pro => no,
    NP0:modf => no,
    NP0:sc => [],
    NP0:neclass ==> none,
    NP0:case => ~gen,
    PN:neclass <=> Val,
    dif(Val,none),
    N:lex => yes,
    N:rightm => no,
    N:subn => sub_noun, 
    N:cj => ncj,
    hd_app_structure(N,PN,NP0),
    unify_except(NP0,NP,agr).
%% allow both
%%    premier Koks regering(en)
%%    premier Koks kabinet(ten)


%% de vroegere leider generaal Franco
grammar_rule(n_n_n_pnapp,NP,[N, N2, PN ]) :-
    NP => n, N => n,
    n_n_pnapp_structure(NN,N2,PN),
    NP:haspre => no,
    N:subn => sub_noun,
    N:nform => norm,
    N:cj => ~no_crd,
    N:rightm => no,
    N:haspre => yes,
    N2:lex => yes,
    N2:rightm => no,
    N2:bmeas => no,
    hd_app_structure(N,NN,NP).
    
%% Chevrolet programma
%% stack:   Het ING TopRentePlus programma

% bijlage III
grammar_rule(n_n_pntag,NP,[N,Tag]) :-
    Tag => enumeration,
    N:cj => ncj,
    n_n_app_structure(NP,N,Tag).

grammar_rule(n_pn_n, NP1, [ PN, N ]) :-
   
    NP => n, N => n, PN => pn,
    overwrite(NP,NP1,lex,yes),
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,

    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (   PG == parse,
	N:lex => yes		% * het Chevrolet mooi programma
				% de nieuwe ING drie procent lening
				% BUT: cdbl 5412: de succesvolle Nereus lichte elite-acht
    ;   PG == generate
    ),
	
    N:subn => ~sub_def_verb & ~sub_indef_verb & ~sub_name & ~sub_num,
    N:cj => ncj,
    hd_mod_structure(N,PN,NP).

%% het ICCE kampioenschap schaken
grammar_rule(app_n_pn_app_n, NP, [ PN, N ]) :-
    NP => app_n_app, N => app_n_app, PN => pn,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    hd_mod_structure(N,PN,NP).

%% de 1991 editie
grammar_rule(n_year_n, NP, [ YEAR, N ]) :-
    NP => n, N => n, YEAR => np,
    YEAR:nform => year,
    N:lex => yes,    % * de 1993 mooie editie
    N:subn => sub_noun,
    N:cj => ncj,
    N:bmeas => no,   % 2000 dollar must be treated as num-n
    hd_mod_structure(N,YEAR,NP).

%% de 400 meter baan
%% stack?    Het 24 graden 25 meter bad
%% really a compound?
grammar_rule(n_measn_n, NP1, [ MEASN, N ]) :-
    NP => n, N => n, MEASN => adv,
    overwrite(NP,NP1,lex,yes),
    MEASN:tmploc => meas_n,
    MEASN:redrel => no,
    MEASN:subadv => subadv_noun,
    MEASN:wh_reltmploc => meas_n,
    N:lex => yes,    %   de nieuwe 3 procent ING lening
    N:subn => ~sub_def_verb & ~sub_indef_verb & ~sub_name & ~sub_num,
    N:cj => ncj,
    hd_mod_structure(N,MEASN,NP).

%% het agendapunt drie
%% is this app or mod?
%% "jaren 80" (for "begin jaren 80")
grammar_rule(n_n_num_app, NP, [ N, NUM ]) :-
    NP => n, N => n, NUM => num,
    NUM:app => yes,
    NP:haspre => no,
    NP:nform => ~meas_mod & ~temp_meas_mod,
    N:rightm => no,
    N:subn => (sub_noun;sub_name),  % sub_name for: 'Willem 3' or is that mwu?
    hd_app_structure(N,NUM,NP).

%% actiepunt nummertje twee
grammar_rule(n_n_num_number_app, NP, [ N, NUMBER, NUM ]) :-
    NP => n, N => n, NUM => num, NUMBER => post_n_n,
    NP:nform => ~meas_mod & ~temp & ~temp_meas_mod,
    NP0 => n,
    NUM:app => yes,
    NP:haspre => no,
    N:subn => sub_noun,
    N:rightm => no,
    hd_app_structure(NUMBER,NUM,NP0),
    hd_app_structure(N,NP0,NP).

%% np --> np sbar
grammar_rule(n_n_sbar, NP, [ N, OPTCOMMA1, SBAR, OPTCOMMA2 ]) :-
    optcomma(OPTCOMMA1),
    optcomma(OPTCOMMA2),
    NP => np, N => np, SBAR => sbar,
    SBAR:slash => [], SBAR:tags => [], SBAR:wh => nwh,
    hd_extra_structure(N,SBAR,NP).

%% np --> np vp
grammar_rule(n_n_vp, NP, [ N, OPTCOMMA1, VP, OPTCOMMA2 ]) :-
    optcomma(OPTCOMMA1),
    optcomma(OPTCOMMA2),
    NP => np, N => np,
    mod_vp(VP),
    hd_extra_structure(N,VP,NP).

%% GvN: the next two rules introduce irritating (?) ambiguities: 
%% [[adj n] pp]  vs. [adj [n pp]]
%% therefore the haspre attribute ensures that all right-modifiers
%% attach higher than all left-modifiers:
%% every head of [mod n] has yes
%% every mother of [n mod] has no

%% n --> adj n
grammar_rule(n_adj_n, NP, [ AP, N ] ) :-
    unmarked_n_adj_n_structure(N,AP,NP).

%% cdb-1389
grammar_rule(n_bracketed_adj_n,NP, [ OPEN, AP, OPTPUNCT, CLOSE, N ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optend_mod_punct(OPTPUNCT),
    unmarked_n_adj_n_structure(N,AP,NP).

grammar_rule(n_dashed_adj_n,NP, [ OPEN, AP, OPTPUNCT, CLOSE, N ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => ligg_streep,
    CLOSE => punct, CLOSE:puncttype => ligg_streep,
    optend_mod_punct(OPTPUNCT),
    unmarked_n_adj_n_structure(N,AP,NP).

grammar_rule(n_bracketed_mod_n,NP, [ OPEN, AP, OPTPUNCT, CLOSE, N ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optend_mod_punct(OPTPUNCT),
    AP => start,
    n_mod_structure(N,AP,NP).

grammar_rule(n_dashed_mod_n,NP, [ OPEN, AP, OPTPUNCT, CLOSE, N ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => ligg_streep,
    CLOSE => punct, CLOSE:puncttype => ligg_streep,
    optend_mod_punct(OPTPUNCT),
    AP => start,
    n_mod_structure(N,AP,NP).

unmarked_n_adj_n_structure(N,AP,NP) :-
    n_adj_n_structure(N,AP,NP),
    AP:agr <=> N:agr.

%% een grote , sterke man
grammar_rule(n_comma_adj_n, NP, [ COMMA, AP, N ] ) :-
    unmarked_n_adj_n_structure(N,AP,NP),
    COMMA => punct,
    COMMA:puncttype => komma.

%% two comma's, only if N is +lex, otherwise captured by previous rule
%% recursively; TODO: allow additional modifier before AP?
%% deze , naar wij nu denken fatale , beslissing
grammar_rule(n_comma_adj_comma_n, NP, [ COMMA1, AP, COMMA2, N ] ) :-
    unmarked_n_adj_n_structure(N,AP,NP),
    N:lex => yes,
    COMMA1 => punct,
    COMMA1:puncttype => komma,
    COMMA2 => punct,
    COMMA2:puncttype => komma.

marked_n_adj_n_structure(N,AP,NP) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    n_adj_n_structure(N,AP,NP),
    N:subn => ~sub_def_adj &  % reduce spur amb in 'gemiddeld langere'
              ~sub_indef_adj &
              ~sub_adj_pl &   % reduce spur amb in 'de direct betrokkenen'
              ~sub_rang &
              ~sub_num  &     % *half tien
              ~sub_def_verb & % reduce spur amb in 'het ziek zijn'
%%              ~sub_name &   % ,, ,,              'een geweldig Feyenoord'
                              %  but het Scandinavisch Hoogland
                              %          Democratisch Blok
                              %          Filipijns Congres
              ~sub_tmp &      % ,, ,,              'uiterlijk tien januari'
              ~sub_indef_verb,
	      %%    N:cj => ncj,              % reduce spur amb in grote 'lees- en weethonger'
	      %%    het gemeenschappelijk veiliheids- en defensiebeleid
    AP:deverbal => no,        % reduce spur amb in 'te kloppen tegenstander'
    AP:can_marked_attr => yes,% reduce spur amb in 'de reuze gitarist'
                              % but: 'een groter man'
    AP:agr => sg&het&indef,
    N:agr => ~(sg&het&indef). 

%% n --> adj n
%% een groot man
%% het openbaar vervoer
%% een befaamd gitarist
%% algemeen directeur
%% Europees kampioen
%% een bekend groot man heeft eens gezegd...
%% de wetenschappelijk begeleiders
%% beeldend kunstenaar(s)
%% maatschappelijk werker(s)
%% 
%% maatschappelijk werkers ?? --> now lexical entry (is a compound)
%% but is now also allowed to be generated by rule because the
%% lexicon is far from complete for these cases / it is a productive
%% process.
grammar_rule(n_adj_n_marked, NP, [ AP, N ] ) :-
    marked_n_adj_n_structure(N,AP,NP).

grammar_rule(n_comma_adj_n_marked, NP, [ COMMA, AP, N ] ) :-
    marked_n_adj_n_structure(N,AP,NP),
    COMMA => punct,
    COMMA:puncttype => komma.

n_adj_n_structure(N,AP,NP) :-
    NP => n, AP => a, N => n,
    NP:subn => ~sub_indef_verb, % reduce spur amb in 'ziek zijn'
    ap_arg(AP),
    N:wh => nwh,
    NP:wh <=> AP:wh,  % de hoeveelste overwinning was dat?
    NP:wh_reltmploc <=> AP:wh_reltmploc,
    AP:aform => attr,
    AP:adv => ~oadv & ~detadv,
    N:haspre => yes,
%%    N:bmeas <=> NP:bmeas,
%% no: volgend jaar; vorig jaar etc.
    unify_except_l(NP,NP0,[wh,wh_reltmploc]),
    hd_mod_structure(N,AP,NP0).

%% cf n_pn_n
%%    n_year_n
%%    n_measn_n
grammar_rule(n_score_n, NP1, [ AP, N ] ) :-
    NP => n, AP => score_cat, N => n,
    overwrite(NP,NP1,lex,yes),
    N:lex => yes,  % * de 1-0 mooie overwinning
    N:cj => ncj,
    N:subn => ~sub_def_verb & ~sub_indef_verb & ~sub_name & ~sub_num,
    N:bmeas => no,
    hd_mod_structure(N,AP,NP).

%% de top 10 notering
%% de nummer 1 hit
grammar_rule(n_adv_n, NP1, [ AP, N ] ) :-
    NP => n, AP => pre_np_adv, N => n,
    overwrite(NP,NP1,lex,yes),
    N:lex => yes,
    N:cj => ncj,
    N:subn => ~sub_def_verb & ~sub_indef_verb & ~sub_name & ~sub_num,
    N:bmeas => no,
    hd_mod_structure(N,AP,NP).

quoted_structure(N,N,QL,QR) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    ql(QL),
    qr(QR),
    structure.

grammar_rule(q_np,M,[QL,N,QR]) :-
    quoted_structure(M,N,QL,QR),
    N => np.

grammar_rule(q_n,M,[QL,N,QR]) :-
    quoted_structure(M,N,QL,QR),
    N => n,
    N:pn => no.

grammar_rule(q_pn,M,[QL,PN,QR]) :-
    quoted_structure(M,PN,QL,QR),
    PN => pn.

grammar_rule(q_pred,M,[QL,PRED,QR]) :-
    quoted_structure(M,PRED,QL,QR),
    PRED => pred,
    PRED:pcat => ~np_pred.

grammar_rule(q_mod,M,[QL,MOD,QR]) :-
    quoted_structure(M,MOD,QL,QR),
    MOD => modifier.

grammar_rule(q_vb,M,[QL,V,QR]) :-
    quoted_structure(M,V,QL,QR),
    V => vb,
    V:vbc => no.

grammar_rule(q_v,M,[QL,V,QR]) :-
    quoted_structure(M,V,QL,QR),
    V => v.

grammar_rule(q_vp,M,[QL,V,QR]) :-
    quoted_structure(M,V,QL,QR),
    V => vp.

grammar_rule(q_vproj,M,[QL,V,QR]) :-
    quoted_structure(M,V,QL,QR),
    V => vproj.

grammar_rule(q_sbar,M,[QL,S,QR]) :-
    quoted_structure(M,S,QL,QR),
    S => sbar.

grammar_rule(q_sbar_punct,M,[QL,S,PUNCT,QR]) :-
    quoted_structure(M,S,QL,QR),
    end_punct(PUNCT),
    S => sbar.

grammar_rule(q_a,M,[QL,A,QR]) :-
    quoted_structure(M,A,QL,QR),
    A => a,
    A:aform => attr. % otherwise use pred or mod rule

%% iets lekkers
%% wat heel lekkers
%% het is iets onbegrijpelijks dat hij komt
%% ==> e_deps percolated from A
grammar_rule(n_n_adj,NP,[N,A]) :-
    NP => n,
    NP:nform => norm,
    NP:haspre => no,  % * adj iets lekkers
    NP:subn => sub_noun,
%    NP:wh => nwh,  % wie anders
    N => iets_n,
    NP:hdet => no, % * mijn iets bijzonders
    A0 => a,
    A0:sc => [],
    A:e_deps <=> NP:e_deps,
    A0:wh => nwh,
    A0:aform <=> N:aform,
    unify_except(A0,A,e_deps), % het is niets bijzonders dat ...
    unify_except(NP0,NP,e_deps),
    hd_mod_structure(N,A0,NP0).

grammar_rule(wat_te_eten,NP,[N,VP]) :-
    NP => n,
    NP:subn => sub_noun,
    NP:nform => norm,
    NP:haspre => no,  % * adj wat te eten
    NP:hdet => no, % * mijn iets bijzonders
    N => iets_n,
    max_vp(VP), 
    VP:vform => te,  % with "om" --> vp_om_rel
    hd_mod_structure(N,VP,NP).

n_adj_structure(N,AP) :-
    N => n,
    N:nform => norm,
    AP => a,
    AP:deverbal => no,
    AP:sc => [],
    AP:wh => nwh,
    AP:cj => ncj,
    hd_structure(AP,N,np).

%% de groene
%% "the greene one"
grammar_rule(n_adj,N,[ AP ]) :-
    n_adj_structure(N,AP),
    N:subn => (sub_def_adj;sub_indef_adj),
    AP:cform => ~rang,
    AP:aform => attr,
    AP:can_nominalize => yes,
    AP:adv => ~oadv & ~detadv,
    AP:agr => ~(indef & sg & het).  % only -e inflected adjectives

grammar_rule(n_rang,N,[ AP ]) :-
    N => n,
    N:nform => norm,
    AP => a,
    AP:deverbal => no,
    AP:sc => [],
    AP:cj => ncj,
    hd_structure(AP,N,np),
    N:subn => sub_rang,
    AP:aform => attr,
    AP:can_nominalize => yes,
    AP:adv => ~oadv & ~detadv,
%    AP:agr => ~(indef & sg & het),  % only -e inflected adjectives
    AP:cform => rang.

%% de groenen
%% +human ???
%% these start out as special adjectives that must undergo this rule.
grammar_rule(n_adj_pl,N,[ AP ]) :-
    n_adj_structure(N,AP),
    N:subn => sub_adj_pl, 
    AP:aform => only_n,
    AP:e_deps => [].

%% for 'veel', 'weinig', 'meer', 'minder', 'hoeveel'
%% are adjectives: [ME] te veel, [ME] te weinig, o zo weinig N...
%% but can promote in determiners (and adverbs)
%% also: 'zo weinig/veel mogelijk' behaves as adjective too
%%
%% TODO: rule out that a AP with OBCOMP is used as determiner
%%    * meer dan ik dacht kinderen
grammar_rule(det_adj,Det,[ AP0 ]) :-
    Det => det,
    Det:subn => sub_veel,
    Det:neclass ==> none,
    Det:agr => indef,
    Det:case => ~gen,
    Det:nform => norm,
    Det:pro => yes,
    Det:wkpro => strongpro,
    AP => a,
    AP:adv => detadv,
    AP:e_deps => [],
    AP:sc => [],
    AP:aform => (nattr;attr;anders),
    hd_structure(AP,Det),
    AP0:agr => het & indef & sg, % should not have -e suffix!
    unify_except(AP0,AP,agr).  % agr of 'veel' sg&het, but 'veel boeken' and 'veel wijn'

%% n --> n pp
%% opmerkingen als zou hij slapen
% grammar_rule(n_n_pps, NP, [ N, PP ] ) :-
%    pp_modifier(PP),
%    n_mod_structure(N,PP,NP),
%    N:rightm => no.
%
% complicated to allow CLEF questions such as:
%    de fpu van welke chip bevat een fout?
grammar_rule(n_n_pps, NP, [ N, PP ] ) :-
    pp_modifier(PP0),
    n_post_mod_structure(N0,PP0,NP0),
    unify_except(PP0,PP,wh),
    unify_except(N0,N,wh),
    unify_except(NP0,NP,wh),
    N:rightm => no,
    N:wh <=> WH1,
    PP:wh <=> WH2,
    NP:wh <=> WH3,
    PP:sel => to_right,
    PP:ld_pc => n_pp,
    NWH => nwh,
    YWH => ywh,
    YQ => dq,  % only for direct questions
    PP:pp_er <=> PP_ER,
    NER => no,
    when(nonvar(WH2),
         ( WH2 = NWH,
           WH1 = WH3
         ; WH2 = YWH,
           WH2 = YQ,    % not in relatives "*dat is de man de vrouw van wie ik gezien heb"
           PP_ER = NER, % not +R "*in de chip waarvan zat een fout?"
           WH2 = WH3,
           WH1 = NWH
         )).
    

%% zomers zoals vroeger
%% problemen zoals gisteren; zoals bij hun; zoals voornoemd; zoals vermeld op...; etc 
grammar_rule(n_n_cp, NP, [ N, OPTCOMMA1, CP, OPTCOMMA2 ] ) :-
    max_sbar(CP),
    optcomma(OPTCOMMA1),
    optcomma(OPTCOMMA2),
    CP:ctype => (c_compare_np;c_alsof;c_mod_np),
    NP:rightm => yes,
    N:rightm => no,
    n_post_mod_structure(N,CP,NP).

n_mod_structure(N,MOD,NP) :-
    NP => n, N => n, 
    N:bmeas <=> NP:bmeas,
    hd_mod_structure(N,MOD,NP).

n_post_mod_structure(N,MOD,NP) :-
    n_mod_structure(N,MOD,NP),
    haspreno(NP). %%%    NP:haspre => no.  % for generation we can't have this

grammar_rule(n_n_mod_vp, NP, [N, VP ]) :-
    n_post_mod_structure(N,VP,NP),
    NP:rightm => yes,
    N:rightm => no,
    mod_om_vp(VP).    

%% in de loop der jaren
%% de heer des huizes
grammar_rule(n_n_gennp, NP, [ N, GEN ] ) :-
    NP => n, N => n, 
    gen_np_arg(GEN),
    N:rightm => no,
    NP:haspre => no,
    hd_mod_structure(N,GEN,NP).

%% een der weinigen
grammar_rule(pron_pron_gennp, NP, [ N, GEN ] ) :-
    NP => pron, N => pron,

    GEN => np,
    GEN:e_deps => [],
    unify_mods(GEN),
    GEN:pred => npred,
    GEN:nform => (norm;temp),
    GEN:redrel => no,
    GEN:case => gen,

    N:nform => norm,
    unify_except(NP,NP0,nform),
    hd_mod_structure(N,GEN,NP0),
    GEN:nform <=> NP:nform. % een dezer dagen -> temp

%% zomers zoals vroeger
%% problemen zoals gisteren; zoals bij hun; zoals voornoemd; zoals vermeld op...; etc 
grammar_rule(pron_pron_cp, NP, [ N, CP ] ) :-
    NP => pron, N => pron,
    max_sbar(CP),
    CP:ctype => (c_compare_np;c_mod_np),
    hd_mod_structure(N,CP,NP).

%% een langere man dan ik woont hier niet
%% n --> n comparative
grammar_rule(n_n_comparative,NP,[N,Extra]) :-
    NP => np, N => np, Extra => comparativep,
    N:subn => ~sub_veel, % diy
    hd_extra_structure(N,Extra,NP).

grammar_rule(n_n_rel, NP, [N, OPTCl, Rel, OPTCr ]) :-
    NP => n,  N => n,  Rel => rel,
    NP:rightm => yes,
    N:rightm => no,
    optcomma_dash(OPTCl),
    optcomma_dash(OPTCr),

    haspreno(NP),   %%%    NP:haspre => no, % for generation we can't have this
    hd_rel_structure(N,Rel,NP).

% subsumed by n_n_modroot()
%grammar_rule(n_n_bracketed_rel, NP, [N, Cl, Rel, OptQm, Cr ]) :-
%    NP => n,  N => n,  Rel => rel,
%    Cl => punct, Cr => punct,
%    Cl:puncttype => haak_open, Cr:puncttype => haak_sluit,
%    optend_mod_punct(OptQm),
%    NP:haspre => no,
%    hd_rel_structure(N,Rel,NP).

grammar_rule(n_pn,N,[PN]) :-
    PN => pn,
    N => n,
    N:pn => yes,
    PN:lex => yes,
    N:e_deps => [],
    PN:cj => ncj,
    N:subn => sub_name,
    N:nform => norm,
    unify_except(N,N0,lex),
    hd_structure(PN,N0).

%% n --> n adv
%% adv in closed class {aanstaande,daar,hier,indoor,junior,.....}
%% do we need a variant for pronouns too? 'hij daar'
%% do we need to allow tmp-np's/adv's here too?
%% de vergadering gisteren
%% de afspraken deze week
grammar_rule(n_n_adv,NP,[N,ADV]):-
    ADV => post_n_adv,
    N:subn => ~sub_indef_verb,
    n_post_mod_structure(N,ADV,NP).

grammar_rule(np_np_adv,NP,[N,ADV]):-
    ADV => post_np_adv,
    N:nform => (temp;norm;meas_mod;temp_meas_mod),
    n_post_mod_structure(N,ADV,NP).

grammar_rule(n_n_loc_adv,NP,[N,ADV]):-
    ADV => adv,
    ADV:tmploc => loc,
    N:subn => ~sub_indef_verb,
    n_post_mod_structure(N,ADV,NP).

grammar_rule(pron_pron_adv,NP,[N,ADV]):-
    ADV => post_n_adv,
    pron_mod_structure(N,ADV,NP).

grammar_rule(pron_pron_loc_adv,NP,[N,ADV]):-
    ADV => adv,
    ADV:tmploc => loc,
    pron_mod_structure(N,ADV,NP).

%% for non-pronouns, use np_np_adv rules above
%% np --> np adv
%% adv in {dus,bijvoorbeeld,...}
grammar_rule(np_np_adv_non,Np,[Np1,Adv]):-
    Adv => post_np_adv,
    Np:redrel => no,
    Np1:redrel => no,
    Np1:has_app => no,
    Np1:wkpro => ~weakpro,
    Np => np,
    Np1 => np,
    Np1:subn => (sub_def_pron;sub_indef_pron;sub_det;sub_name),
    hd_mod_structure(Np1,Adv,Np).

%% twee uur vannacht
%% mei volgend jaar
%% de overwinning vorige week tegen Ajax
%% het protesteren gisteren heeft niet geholpen
%% de weg omhoog naar de top
grammar_rule(np_np_tmp,Np,[Np1,Adv]) :-
    Adv => adv,
    Adv:tmploc => (tmp;tmp_n;ld_dir),
    Adv:wh => nwh,
    Adv:wk => no,
    Np1:nform => (temp;norm),
    Np1:subn => (sub_noun;sub_def_verb;sub_tmp),
    Adv:agr => ~pl,     % try to limit type of temporal NP's that occur here
    %%% TODO: begin/eind jaren tachtig
    n_post_mod_structure(Np1,Adv,Np).
    
grammar_rule(np_np_year,Np,[Np1,Year]) :-
    Year => np,
    Year:nform => year,
    Np1:nform => (temp;norm),
    Np1:subn => (sub_noun;sub_def_verb;sub_name),  % NOT sub_tmp, because DIY
    n_post_mod_structure(Np1,Year,Np).
    
%% np[-wh] --> np[+wh] adv[dan,ook]
%% adv in {ook-maar,ook,dan-ook}
grammar_rule(np_wh_np_adv,NP,[N,Adv]):-
    NP => np,
    N => np,
    Adv => post_wh_adv,
    NP:nform => (temp;norm;meas_mod),
    N:redrel => no,
    NP:wh => nwh,
    N:wh => ywh,
    N:wh => yq,
    unify_except_l(N,N1,[wh,wh_reltmploc]),
    hd_mod_structure(N1,Adv,NP).

%%  - hoe triest ook - 
grammar_rule(ap_wh_ap_adv,AP,[A,Adv]):-
    AP => a,
    A => a,
    Adv => post_wh_adv,
    A:wh => ywh,
    AP:wh => nwh,
    unify_except_l(A,A1,[wh]),
    hd_mod_structure(A1,Adv,AP).
    

%% om het even welke 
grammar_rule(np_adv_wh_np,NP,[Adv,N]):-
    NP => np,
    N => np,
    Adv => pre_wh_adv,
    NP:nform => (temp;norm;meas_mod),
    N:redrel => no,
    NP:wh => nwh,
    N:wh => ywh,
    N:wh => yq,
    unify_except_l(N,N1,[wh,wh_reltmploc]),
    hd_mod_structure(N1,Adv,NP).

%% advp[-wh] --> advp[+wh] adv[dan,ook]
%% adv in {ook-maar,ook,dan-ook}
grammar_rule(adv_wh_adv_adv,ADVP,[ADV,MOD]):-
    MOD => post_wh_adv,
    ADVP => adv,
    ADVP:wh => nwh,
    ADV => adv,
    ADV:redrel => no,
    ADV:wh => ywh,
    ADV:wh => yq,
    unify_except_l(ADV,ADV1,[wh_reltmploc,wh]),
    hd_mod_structure(ADV1,MOD,ADVP).

%% np --> np , modifier , 
%% Jan , een dappere strijder , ..
%% John , a brave knight , ..
%% de minister van buitenlandse zaken , Genscher , ..
%%
grammar_rule(n_n_modnp(komma), N, [ N0, Cl, NP, OPTCr ]) :-
    n_n_modnp_komma_structure(N,N0,Cl,NP,OPTCr).

n_n_modnp_komma_structure(N,N0,Cl,NP,OPTCr) :-
    np_np_modnp_structure(N0,NP,N),
    NP:cj => ~no_crd,	% improved HACK reduce ambiguities in pn, pn, .. seqs
    N0:cj => ~no_crd,	% improved HACK reduce ambiguities in pn, pn, .. seqs
    N:has_app => yes, % ,,
    NP:has_app => no, % ,,
    NP:subn => ~sub_indef_adj,
    NP:wkpro => ~weakpro, % ?? 29 jan 2020
    optcomma(OPTCr),
    Cl => punct, 
    Cl:puncttype => komma.

% Paris , Texas
% Dr. Denker , Nieuwsblad van het Noorden , Groningen
grammar_rule(pn_n_modpn(komma), N, [ N0, Cl, NP, OPTCr ]) :-
    N => np, N0 => np,
    nwh_np_arg(NP),
    NP:wkpro => ~weakpro,
    NP:redrel => no,
    NP:subn => ~sub_indef_adj,
    N:nform => norm,
    N0:redrel => no,
    N0:wkpro => ~weakpro,
    NP:cj => ncj,	% improved HACK reduce ambiguities in pn, pn, .. seqs
    N0:cj => ncj,	% improved HACK reduce ambiguities in pn, pn, .. seqs
    N:has_app => yes, % ,,
    N0:has_app => no, % ,,
    optcomma(OPTCr),
    Cl => punct, 
    Cl:puncttype => komma,
    N0:subn => sub_name,
    NP:subn => sub_name,
    hd_mod_structure(N0,NP,N).

%% Jan , meestal een dappere strijder , ..
grammar_rule(n_n_modified_np,N,[N0,Cl,MOD,NP0,OPTCr]) :-
    np_np_modmod_structure(NP0,MOD,NP),
    n_n_modnp_komma_structure(N,N0,Cl,NP,OPTCr).

grammar_rule(n_n_predm_np,N,[N0,Cl,MOD,NP0,OPTCr]) :-
    np_np_predm_mod_structure(NP0,MOD,NP),
    n_n_modnp_komma_structure(N,N0,Cl,NP,OPTCr).

%% Jan , zelf een dappere strijder , ..
grammar_rule(n_n_predm_modified_np,N,[N0,Cl,MOD,NP0,OPTCr]) :-
    max_predm(MOD),
    np_np_mod_structure(NP0,MOD,NP),
    n_n_modnp_komma_structure(N,N0,Cl,NP,OPTCr).

grammar_rule(n_n_modnp(dubb_punt), N, [ N0, Cl, NP, OPTCr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Cl => punct,
    Cl:puncttype => dubb_punt,
    optcomma(OPTCr),
    np_np_modnp_structure(N0,NP,N).

np_np_modnp_structure(N0,NP,N) :-
    N => np, N0 => np,
    nwh_np_arg(NP),
    NP:wkpro => ~weakpro,
    NP:redrel => no,
    N:nform => norm,
    N:redrel => no,
    N0:redrel => no,
    N0:wkpro => ~weakpro,
    %% try to prevent "president van [ Peru , Jantje Pietersen ] , .."
    %% this rules out the case that both NP's are names.
    %% Actually, this is wrong, because of:
    %%        Delta Lloyd , het vroegere Red Stars , ...  ORG ORG
    %%        Van der Kuylen , " het Kanon " , ...        PER MISC/PER
    %% (film)  .. een oude vriendin Vera , Monique avn der Ven , .. PER/PER
    N0:subn <=> SUBN1,
    NP:subn <=> SUBN2,
    N0:neclass <=> CLASS1,
    NP:neclass <=> CLASS2,
    NP:subn => ~sub_indef_adj,
    SUBN => sub_name,
    when( (?=(SUBN1,SUBN),
	   ?=(SUBN2,SUBN)
	  ),
	  (   \+ ( SUBN1=SUBN,
                   SUBN2=SUBN
	         )
          ;   SUBN1=SUBN,
              SUBN2=SUBN,
              CLASS1=CLASS2
	  )
        ),
    hd_app_structure(N0,NP,N).

%% motivated by cdb-4879
grammar_rule(n_n_modroot(haak), N, [ N0, Cl, ROOT, OptQm, Cr ]) :-
    Cl => punct, Cr => punct,
    Cl:puncttype => haak_open, Cr:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    ROOT => start,
    n_post_mod_structure(N0,ROOT,N).

%% motivated by cdb-5702
grammar_rule(n_n_modroot(min), N, [ N0, Cl, ROOT, Cr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Cl => punct, Cr => punct,
    Cl:puncttype => ligg_streep, Cr:puncttype => ligg_streep,
    ROOT => start,
    n_post_mod_structure(N0,ROOT,N).

%% motivated by cdb-6859
grammar_rule(n_n_modroot(comma), N, [ N0, Cl, ROOT, Cr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    comma(Cl),comma(Cr),
    max_root(ROOT),
    n_post_mod_structure(N0,ROOT,N).

%% motivated by
%% WR-P-P-H-0000000013.p.1.s.4
%% Schreuders , van beroep verwarmingsmonteur , overleed na een langdurig ziekbed .

grammar_rule(n_n_modroot_dp(comma), N, [ N0, Cl, MOD, Cr ]) :-
    comma(Cl),comma(Cr),
    max(MOD),
    MOD:max_type => t_dp,
    n_post_mod_structure(N0,MOD,N).

np_np_modmod_structure(N0,MOD,N) :-
    MOD => modifier,
    MOD:mcat => ~mcat_imp,  %  & ~mcat_adv,  ?????
    np_np_mod_structure(N0,MOD,N).

np_np_predm_mod_structure(N0,MOD,N) :-
    MOD => predm_adv,
    np_np_mod_structure(N0,MOD,N).

np_np_modadj_structure(N0,MOD,N) :-
    max_nadv_ap(MOD),
    MOD:adv => nboth,
    np_np_mod_structure(N0,MOD,N),
    N:subn => (sub_noun;sub_name),  %% too strict???
    N:nform => norm.

np_np_modadv_structure(N0,MOD,N) :-
    MOD => adv,
    MOD:tmploc => ~hoe_hoe & ~wk_er,
    max(MOD),
    MOD:subadv => ~subadv_adv,
    np_np_mod_structure(N0,MOD,N),
    N:nform => norm.

np_np_mod_structure(N0,MOD,N) :-
    N => np, N0 => np, 
    N:nform => (norm;temp),
    N0:wkpro => ~weakpro, 
    MOD:wh =?> nwh,
    N:redrel => no,
    N0:redrel => no,
    hd_mod_structure(N0,MOD,N).

%% np --> np , MOD ,
%% Jan , uit Amsterdam , ..
grammar_rule(n_n_mod(komma), N, [ N0, Cl, MOD, OPTCr ]) :-
    Cl => punct,
    optcomma(OPTCr),
    np_np_modmod_structure(N0,MOD,N),
    MOD:mcat => ~mcat_adv,      % use the following two rules in that case
    MOD:mcat => ~mcat_redrel,   % use normal relative in that case
    Cl:puncttype => komma.

grammar_rule(n_n_mod_a(komma), N, [ N0, Cl, MOD, OPTCr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    optcomma(OPTCr),
    Cl => punct, 
    np_np_modadj_structure(N0,MOD,N),
    Cl:puncttype => komma.

%% De kleding bestemd voor Polen werd opgehaald
%% attaches at N: kleding bestemd voor Polen uit Zeeland gaat eerst weg
%% de ervaringen opgedaan tijdens het projgect
%% *de ervaringen opgedaan
%% maar wel:
%% zondag aanstaande
%% dat woord vertaald luidt:
grammar_rule(n_n_mod_a, NP, [ N, MOD ]) :-
    max_nadv_ap(MOD0),
    unify_except(MOD0,MOD,adv),
    n_post_mod_structure(N,MOD,NP),
    N:rightm => no,
    N:subn => ~sub_num,
%%    NP:rightm => yes,  'kleding bestemd voor Polen uit de achterse wagen ..'
    MOD:adv => ~oadv & ~detadv,
    MOD:tmploc => ~wk_er & ~str_er & ~tmp & ~tmp_n & ~ld_dir & ~me, % use np_np_tmp in those cases
    MOD:can_postn_with_cform => yes,
    MOD:can_postn => yes.

grammar_rule(n_n_mod_adv(komma), N, [ N0, Cl, MOD, OPTCr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    optcomma(OPTCr),
    Cl => punct, 
    np_np_modadv_structure(N0,MOD,N),
    Cl:puncttype => komma.

%% Seedorf , niet getrouwd overigens , ...
grammar_rule(n_n_mod_adv_mod(komma), N, [ N0, Cl, MOD, Tag, Cr ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    comma(Cr),
    comma(Cl),
    max_advp(Tag),
    Tag:tmploc => sent,
    Tag:cj => ncj,
    Tag:redrel => no,
    Tag:wh => nwh,
    MOD => adv,
    MOD2 => adv,
    MOD:modifies_v => yes,
    hd_mod_structure(MOD,Tag,MOD2),
    np_np_modadv_structure(N0,MOD2,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% ADJECTIVAL PHRASES %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% GvN: added haspre feature to reduce uninteresting ambiguities
%%    [[adv  a] pp ]
%% vs [ adv [a  pp]]
%% every head of [xp a] has yes
%% every mother of [a xp] has no

%% adj --> adv adj
grammar_rule(a_adv_a,AP,[Adv,A]):-
    a_adv_a_structure(AP,Adv,A),
    A:adv => ~detadv.

grammar_rule(a_bracketed_mod_a,AP,[OPEN,Adv,OPTPUNCT,CLOSE,A]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    AP => a,
    A => a,
    haspreyes(A),
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    Adv => modifier,
    hd_mod_structure(A,Adv,AP).

grammar_rule(a_ligg_mod_a,AP,[OPEN,Adv,OPTPUNCT,CLOSE,A]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    AP => a,
    A => a,
    haspreyes(A),
    OPEN => punct, OPEN:puncttype => ligg_streep,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => ligg_streep,
    Adv => modifier,
    hd_mod_structure(A,Adv,AP).

grammar_rule(a_detadv_a,AP,[Adv,A]):-
    a_adv_a_structure(AP,Adv,A),
    Adv:tmploc => ntmploc,
    A:adv => detadv.

a_adv_a_structure(AP,Adv,A0) :-
    AP => a, Adv => adv, A=>a,
    unify_except_l(A0,A,[wh,wh_reltmploc,can_postv]),
				% ignore wh feature of adjectival head,
				% instead use Adv's wh feature. Solely
				% for the 'Hoe lief is Jan?' examples.
    A0:wh => nwh,
    Adv:wh <=> A:wh,
    Adv:wh_reltmploc <=> A:wh_reltmploc,
    AP:can_postv <=> Adv:adj_can_postv,
    Adv:tmploc => (ntmploc;sent;tmp;tmp_n;loc;ld_dir;wk_er),
    Adv:redrel => no,
    Adv:modifies_a => yes,
    haspreyes(A0),
    hd_mod_structure(A,Adv,AP).

%% de zich daar niet van bewuste leraar
%%% TODO: should attach higher than corresponding PREP!
%%% * de zich van er bewuste leraar
grammar_rule(a_er_a,AP,[ER,A]) :-
    AP => a, A => a,
    A:aform => attr,  % otherwise inherited by governor
    ER => np,
    ER:nform => er,
    projected_hd_filler_structure(A,ER,AP).

grammar_rule(a_cp_a,AP,[SBAR,A]) :-
    AP => a, SBAR => sbar, A => a,
    haspreyes(A),
    SBAR => sbar,
    SBAR:tags => [],
    SBAR:slash => [],
    SBAR:wh => nwh,
    SBAR:ctype => c_adv,
    hd_mod_structure(A,SBAR,AP).

grammar_rule(a_hoe_a,AP,[Adv,A]) :-
    AP => a, Adv => hoe_adv, A0=>a,
    AP:adv => ~oadv & ~detadv,
    unify_except_l(A0,A,[wh,wh_reltmploc,adv]),
				% ignore wh feature of adjectival head,
				% instead use Adv's wh feature. Solely
				% for the 'Hoe lief is Jan?' examples.
    AP:wh => ywh,
%    AP:wh => yq,  %?
    AP:wh_reltmploc => hoe_hoe,
    haspreyes(A),
    A:cform => compar,
    A:exs => [],
    hd_mod_structure(A0,Adv,AP).

%% done: * te heel mooie
%% done  * erg te lieve
grammar_rule(a_int_adv_a,AP,[Adv,A]):-
    AP => a, Adv => int_adv, A=>a,
    haspreyes(A),  % so A cannot combine with PP
    A:lex => yes,  % so A cannot combine with ADV
%    A:exs => [],  % *des te leuker dan ik dacht
                   % ok:  iets veel mooiers dan jij
                   %      iets heel anders dan gisteren
    Adv:agr <=> A:agr,  
    hd_mod_structure(A,Adv,AP).

grammar_rule(a_bracketed_int_adv_a,AP,[OPEN,Adv,OPTPUNCT,CLOSE,A]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    AP => a, Adv => int_adv, A=>a,
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    haspreyes(A),
    A:exs => [],
    Adv:agr <=> A:agr,  
    hd_mod_structure(A,Adv,AP).

grammar_rule(a_int_me_adv_a,AP,[NP,Adv,A]):-
    AP0 => a, Adv => int_adv, A=>a, Adv1 => adv,
    haspreyes(A),
    A:exs => [],
    NP => np,
    NP:wh => nwh,
    hd_comp_structure(Adv,NP,Adv1),
    hd_mod_structure(A,Adv1,AP0),
    unify_except(AP0,AP,me_adj),
    AP:me_adj => yes.

%% adj --> adj pp
grammar_rule(a_a_pp, AP, [ A, PP ]) :-
    AP => a, A => a, PP => pp,
    A:adv => ~detadv,
    pp_modifier(PP),
    PP:sel => to_right,
    haspreno(AP),
    A:hasextra => no,           % bang dat je komt ervoor 
    A:aform => nattr,		% *de bang voor muizen man
				%  gebouwd van goedkoop materiaal voldoet dit
				%     huis aan de idealen van Jan Splinter
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    hd_mod_structure(A,PP,AP).

%% gekleed zoals hij zich altijd kleedt kwam hij binnen
grammar_rule(a_a_modcp,AP,[A,SBAR]) :-
    AP => a, A => a, max_sbar(SBAR),
    haspreno(AP),
    AP:hasextra => yes,
    A:aform => nattr,
    A:adv => ~detadv,
    SBAR:ctype => (c_compare_np;c_alsof),
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    hd_mod_structure(A,SBAR,AP).

%% keurig als altijd veroordelen wij anarchisme
%% "keurig" is not a padv
%% but the result is padv
grammar_rule(a_a_modcp_pred,AP1,[A,SBAR]) :-
    AP => a, A => a, max_sbar(SBAR),
    haspreno(AP),
    AP:hasextra => yes,
    A:aform => nattr,
    A:adv => ~detadv & ~padv,
    SBAR:ctype => (c_compare_np;c_alsof),
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    hd_mod_structure(A,SBAR,AP),
    overwrite(AP,AP1,adv,padv).

grammar_rule(a_a_bracketed_mod,AP,[A,OPEN,MOD,OPTPUNCT,CLOSE]) :-
    AP => a, A => a, MOD => start,
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    haspreno(AP),
    AP:hasextra => yes,
    A:aform => nattr,
    A:adv => ~detadv,
    hd_mod_structure(A,MOD,AP).

grammar_rule(a_a_lig_mod,AP,[A,OPEN,MOD,OPTPUNCT,CLOSE]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    AP => a, A => a, MOD => start,
    OPEN => punct, OPEN:puncttype => ligg_streep,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => ligg_streep,
    haspreno(AP),
    AP:hasextra => yes,
    A:aform => nattr,
    A:adv => ~detadv,
    hd_mod_structure(A,MOD,AP).

%% adj --> adj comparativep
grammar_rule(a_a_compp, AP1, [ A, CP ]) :-
    AP => a, A => a, CP => comparativep,
    A:aform => nattr,		% *de bangere dan Piet man
    haspreno(AP),
    hd_extra_structure(A,CP,AP),
    AP:has_obcomp => yes,
    overwrite(AP,AP1,can_postn,yes).

%% adj --> pp adj
grammar_rule(a_pp_a, AP, [ PP, A ]) :-
    a_pp_a_structure(AP,PP,A),
    PP:sel => to_left.

a_pp_a_structure(AP,PP,A) :-
    AP => a, A => a,
    pp_modifier(PP),
    A:aform => (attr;nattr;only_n),  % de ter dood veroordeelden
    A:adv => ~detadv,
    haspreyes(A),
    hd_mod_structure(A,PP,AP).

%% de drie na grootste producent
grammar_rule(a_num_na_a, AP, [ NUM_NA, A ]) :-
    A:aform => (attr;nattr;only_n),  % de drie na grootsten
    AP => a, A => a,  % A:cform => super,  ook: laatste which is now a number(rang)
    NUM_NA => num_na,
    hd_mod_structure(A,NUM_NA,AP).

%% hij is bang dat het regent
grammar_rule(a_a_sbar, AP, [ A, OPTCOMMA, S ]) :-
    optcomma(OPTCOMMA),
    AP => a, A => a, S => sbar,
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    AP:hasextra => yes,
    haspreno(AP),
    A:aform => nattr,           % *de bange dat het regent man
    S:slash => [],		% island
    S:tags => [],
    hd_extra_structure(A,S,AP).

%% rekening houdend dat hij komt
grammar_rule(a_a_sbar_hd_comp, AP, [ A, OPTCOMMA, S ]) :-
    optcomma(OPTCOMMA),
    AP => a, A => a, S => sbar,
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    AP:hasextra => yes,
    haspreno(AP),
    A:aform => nattr,           % *de bange dat het regent man
    S:slash => [],		% island
    S:tags => [],
    hd_comp_structure(A,S,AP).

%% hij is bang om op te vallen
grammar_rule(a_a_sinf, AP, [ A, OPTCOMMA, S ]) :-
    optcomma(OPTCOMMA),
    AP:hasextra => yes,
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    AP => a, A => a, S => vp,
    haspreno(AP),
    S:vform => (om;te), 
    A:aform => nattr,           % *de bang om op te vallen man
    S:slash => [],		% *de om op te vallen bange man
    S:tags => [],
    S:haswh => no,
    hd_extra_structure(A,S,AP).

%% dat boek is leuk om te lezen
%% todo: dat boek is moeilijk te lezen (or is "moeilijk" adv here?)
grammar_rule(a_a_sinf_tough, AP, [ A, OPTCOMMA, REL ]) :-
    optcomma(OPTCOMMA),
    AP => a, A => a, 
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    AP:hasextra => yes,
    haspreno(AP),
    A:aform => nattr,           % *de leuk om te lezen boeken
    REL => rel,
    REL:relform => relform_inf,
    REL:tmploc => non_adv,
    hd_extra_structure(A, REL, AP).

%% hij is afkerig van spruitjes
%% de van spruitjes afkerige jongen
grammar_rule(a_a_pp_comp, AP, [ A, PP ]) :-
    AP => a, A => a, PP => pp,
    A:hasextra => no,
    haspreno(AP),
    A:aform => nattr,
    PP:wh => nwh,
    PP:sel => to_right,
    PP:slash => [],
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    hd_extra_structure(A,PP,AP).

grammar_rule(a_a_er_pp_comp, AP, [ A, PP ]) :-
    AP => a, A => a, PP => pp,
    A:hasextra => no,
    haspreno(AP),
    A:aform => nattr,
    PP:wh => nwh,
    PP:sel => to_right,
    PP:slash <=> [_], % otherwise use a_a_pp_comp
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    hd_comp_structure(A,PP,AP).

grammar_rule(a_pp_comp_a, AP, [ PP, A]) :-
    AP => a, A => a, PP => pp,
    haspreyes(A),
    A:aform => (nattr;attr), 
%%    PP:wh => nwh,  % hij vroeg wie waarvoor verantwoordelijk was
    PP:sel => to_left,
%%    PP:slash => [],	% * dat hij daar_i altijd [ voor_i erg bang ] is
                        %   dat hij daar_i druk [ mee_i bezig ] is
    hd_comp_structure(A,PP,AP).

%% dit gezegd hebbende
grammar_rule(a_vb_a,AP, [VC, A]) :-
    AP => a,
    A => a,
    haspreyes(A),
    A:aform => (nattr;attr), 
    VC => vb,
    VC:vslash => [],
    VC:slash => [],
    hd_comp_structure(A,VC,AP).

grammar_rule(a_me_comp_a, AP, [ NP, A]) :-
    AP => a, A => a,
    A:lex => yes,   % * twee dagen geleden
                    % zijn de pathetiek niet zelden naderende hang...
    A:me_adj => yes,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    NP => np,
    %% hoeveel boeken meer bezit hij ?
    %% hoeveel graden warmer wordt het ?
    unify_except_l(AP0,AP,[wh,wh_reltmploc]),
    NP:wh <=> AP:wh,

    NP:wh <=> WH,
    NWH => nwh,
    YWH => ywh,
    when(nonvar(WH),
	 (  WH = YWH
	 ;  WH = NWH
	 )
	),   % not for relatives!
    NP:wh_reltmploc <=> AP:wh_reltmploc,
    hd_comp_structure(A,NP,AP0).

grammar_rule(a_np_comp_a, AP, [ NP, A]) :-
    AP => a, A => a,
    A:me_adj => no,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    NP => np,
    NP:wh => nwh,
    %%% * de wie kussende man heb jij ontmoet?
    %% hoeveel boeken meer bezit hij ?
    %% hoeveel graden warmer wordt het ?
    hd_comp_structure(A,NP,AP).

%% nota, bevattende een verslag van de vergadering"
%% de show, getiteld X
%% gesigneerd J.de Vries

grammar_rule(a_a_np_comp, AP1, [ A, NP ]) :-
    AP => a, A => a,
    overwrite(AP,AP0,adv,nadv),
    overwrite(AP0,AP1,can_nominalize,no),
    haspreno(AP),
    A:hasextra => no,
    A:wh => nwh,
    A:avform => (avform_ppres;avform_ppart),
    A:aform => nattr,
                           % Nov 16 2010
    AP:modifies_a => no,   % not with rightward complements/modifiers?
    NP => np,
    NP:wh => nwh,
    NP:nform => norm,
    NP:subn => (sub_noun;sub_name),
    hd_comp_structure(A,NP,AP).

grammar_rule(a_fixed_a, AP, [ FIXED, A]) :-
    AP => a, A => a,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    FIXED => fixed_part,
    FIXED:cat => pred,
    hd_comp_structure(A,FIXED,AP).

grammar_rule(a_part_a, AP, [ PART, A]) :-
    AP => a, A => a,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    PART => part,
    hd_comp_structure(A,PART,AP).

grammar_rule(a_pred_a, AP, [ PRED, A]) :-
    AP => a, A => a,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    PRED => pred,
    PRED:subn => ~sub_indef_verb,
    hd_comp_structure(A,PRED,AP).

grammar_rule(a_predm_a, AP, [ PRED, A]) :-
    AP => a, A => a,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    PRED => predm_adv,
    hd_predm_structure(A,PRED,AP).

grammar_rule(a_predm_dev_a, AP, [ PRED, A]) :-
    AP => a, A => a,
%    A:deverbal => yes,         % only for 'te-V' adjectives? should also allow present/past participles
    A:avform => ~avform_ap,
    haspreyes(A),
    A:wh => nwh,		% * np hoe beter
    predm_adj(PRED),            % de nieuw uit te geven aandelen
    hd_predm_structure(A,PRED,AP).

grammar_rule(zo_adj_mogelijk,AP,[Zo,Adj,Mogelijk]) :-
    AP => a,
    Zo => zom_adv,
    Mogelijk => zom_a,
    unify_mods(Mogelijk),
    Adj => a,
    unify_except_l(Adj,Adj1,[agr,aform]),
    Adj1:agr <=> Mogelijk:agr,
    Adj1:aform <=> Mogelijk:aform,
    Adj1:cform <=> Mogelijk:cform,
    Adj:agr => indef & sg & het,
    Adj:cform => base,
    Adj:aform => nattr,
    alpino_data:dt(Zo,ZoDt),
    alpino_data:dt(Mogelijk,MogelijkDt),
    ZoDt:obcomp <=> MogelijkDt,
    hd_mod_structure(Adj1,Zo,AP).

%% S L O W .....
%%grammar_rule(adv_adv_adv,AdvP,[Adv,AdvH]):-
%%    AdvP => adv, Adv => adv, AdvH=>adv,
%%    hd_mod_structure(AdvH,Adv,AdvP).

/* "zijn vrouw achterna"
   only in contexts that cannot be also analysed as V+part
   "ik ga zijn vrouw achterna" is only analyes as

                  top=top
                  |
              -- =smain              
 _______________________________     
 |       |           |          |
su      hd         ld=np       svp   
 |       |        ______        |    
 |       |        |     |       |
ik  ga_achterna  det   hd   achterna 
                  |     |
                zijn  vrouw          
*/

grammar_rule(adv_adv_modroot(haak), Adv, [ Adv0, Cl, ROOT, OptQm, Cr ]) :-
    Cl => punct, Cr => punct,
    Cl:puncttype => haak_open, Cr:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    ROOT => start,
    Adv => adv,
    Adv0 => adv,
    Adv:modifies_v => yes,
%    Adv:sel => to_topic,
    Adv:subadv => ~subadv_adj,
    hd_mod_structure(Adv0,ROOT,Adv).

grammar_rule(adv_adv_modroot(min), Adv, [ Adv0, Cl, ROOT, Cr ]) :-
    Cl => punct, Cr => punct,
    Cl:puncttype => ligg_streep, Cr:puncttype => ligg_streep,
    ROOT => start,
    Adv => adv,
    Adv0 => adv,
    Adv:modifies_v => yes,
%    Adv:sel => to_topic,
    Adv:subadv => ~subadv_adj,
    hd_mod_structure(Adv0,ROOT,Adv).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% PREPOSITIONAL PHRASES %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar_rule(pp_np_p, PP, [NP,P ]) :-
    PP => post_pp,
    P => post_p,
    NP => np,
    NP:nform => ~er,
    NP:parg => yes,
    NP:pred => npred,
    NP:subn => ~sub_indef_verb,
    hd_comp_structure(P,NP,PP).

grammar_rule(pp_p, PP, [ P ]) :-
    PP => pp, P => p, PP:pp_er => yes,
    PP:vhasmod => no,  % daar heb ik aan niet gedacht
    PP:veps:out => no,
    PP:haspart => no,
    PP:hcj <=> P:cj,
    P:dt:hdf => [],
    hd_structure(P,PP).

pp_p_part_principle(PP,P,Part) :-
    PP => pp, P => p, PP:pp_er => no,
    Part => part,
    unify_mods(Part),
    PP:haspart => yes,
    PP:veps:in <=> PP:veps:out,
    PP:allow_modal => no,  % because should be attached to P
    P:ppost <=> List,
    alpino_wappend:wmember(PartVal,List),
    Part:part <=> PartVal,
    PP:dt => dt,
    PP:dt:hdf <=> Part:dt.

grammar_rule(pp_p_part, PP, [ P, Part ]) :-
    pp_p_part_principle(PP,P,Part),
    hd_structure(P,PP).

pp_p_arg_part_structure(P,XP,PP,Part) :-
    pp_p_part_principle(PP,P,Part),
    hd_comp_structure(P,XP,PP).

pp_p_arg_structure(P,XP,PP) :-
    PP => pp, P => p, PP:pp_er => no,
    PP:hcj <=> P:cj,
    PP:e_deps <=> Edeps,
    PP:veps:in <=> PP:veps:out,
    PP:nhstem <?=?> XP:hstem,
    if_defined(XP:e_deps,Edeps,[]), % ik beschouw het als ongepast, dat je komt
    PP:haspart => no,
    PP:dt:hdf => [],
    PP:allow_modal => no,  % because should be attached to P
    unify_except(PP0,PP,e_deps),
    hd_comp_structure(P,XP,PP0).

grammar_rule(pp_p_arg(np), PP, [ P, OPTPUNCT, XP ]) :-
    pp_p_arg_np_structure(PP,P,OPTPUNCT,XP).

%% lists are often introduced with a preposition followed by : or ...
%% similarly for complementizers
grammar_rule(pp_p_arg(dubb), PP, [ P, DUBB ]) :-
    DUBB => punct,
    DUBB:puncttype => (dubb_punt;hellip),
    max_np(NP),
    NP:mexs => [],
    NP:hstem => [],
    NP:nform => norm,
    NP:subn => sub_noun,
    NP:dt => [],
    NP:allows_drop => yes,
    pp_p_arg_np_structure(PP,P,_OPTPUNCT,NP).

%% too liberal??
%% should these cases be treated as spelling mistakes?
%% "Hij ziet er in vooral een dienende taak"
%% "En daar door behoorde hij bij de doden die de doden begraven"
%% "Giften worden hier op graag tegemoet gezein
grammar_rule(pp_p_arg(r), PP, [ XP, P ]) :-
    pp_p_arg_r_structure(PP,XP,P).

%% todo?
%% "overal ergens nergens" cannot be used here (ANS blz 495)
%% but
%% VK20020102-104-8-5|Ergens tussendoor was ook nog de Libanees jarig .
pp_p_arg_r_structure(PP,XP,P) :-
    XP => np,
    XP:nform => er,
    PP => pp, P => p, PP:pp_er => yes,
    PP:hcj <=> P:cj,
    PP:vc => no, %% this rule should *not* be used pre-VC, in order
                 %% to reduce spur amb in "ik trap er in"
    PP:e_deps => [],
    PP:nhstem <=> XP:hstem,
    PP:haspart => no,
    P:dt:hdf => [],
    projected_hd_filler_structure(P,XP,PP).

pp_p_arg_np_structure(PP,P,OPTPUNCT,XP) :-
    optdubb(OPTPUNCT),
    XP => np,
    XP:nform => ~er,
    XP:parg => yes,
    XP:pred => npred,
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_mod_arg(np), PP, [ P, COMMA1, MOD, COMMA2, XP ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    comma_dash(COMMA1),
    comma_dash(COMMA2),
    MOD => modifier,
    XP => np,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    pp_p_arg_np_structure(PP,P,_,XP1).

grammar_rule(pp_p_tag_arg(np), PP, [ P, COMMA1, MOD, COMMA2, XP ]) :-
    comma(COMMA1),
    comma(COMMA2),
    MOD => tag,
    MOD:adv => no, % use previous rule for adverbs
    MOD:np => no, % use previous rule for adverbs
    XP => np,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    pp_p_arg_np_structure(PP,P,_,XP1).

grammar_rule(pp_p_d_mod_arg(np), PP, [ P, COMMA1, MOD, OptQm, COMMA2, XP ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    dash(COMMA1),
    dash(COMMA2),
    optend_mod_punct(OptQm),
    MOD => start,
    XP => np,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    pp_p_arg_np_structure(PP,P,_,XP1).

grammar_rule(pp_p_br_mod_arg(np), PP, [ P, COMMA1, MOD, OptQm, COMMA2, XP ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    haak_open(COMMA1),
    haak_sluit(COMMA2),
    optend_mod_punct(OptQm),
    MOD => start,
    XP => np,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    pp_p_arg_np_structure(PP,P,_,XP1).

%% aldus gisteravond de voorzitter
grammar_rule(pp_aldus_mod_arg(np), PP, [ P, MOD, XP ]) :-
    pp_aldus_mod_structure(PP,P,MOD,XP).

%% aldus de voorzitter gisteravond 
grammar_rule(pp_aldus_arg_mod(np), PP, [ P, XP, MOD ]) :-
    pp_aldus_mod_structure(PP,P,MOD,XP).

pp_aldus_mod_structure(PP,P,MOD,XP) :-
    max_advp(MOD),
    unify_mods(MOD),
    finish_mexs(MOD),
    XP => np,
    pp_p_arg_np_structure(PP0,P,_,XP),
    P:prep ==> aldus,
    unify_except(PP0,PP,cmods),
    MOD:dt <=> MODDT,
    PP:cmods <=> [MODDT|MODS],
    PP0:cmods <=> MODS.

grammar_rule(pp_p_arg(pp), PP, [ P, XP ]) :-
    XP => pp,
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_arg(a), PP, [ P, XP ]) :-
    XP => a,
    XP:wh => nwh,
    XP:sc => [],
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_arg(n), PP, [ P, XP ]) :-
    XP => n,
    XP:pred => npred,
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_arg(adv), PP, [ P, XP ]) :-
    XP => adv,
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_arg(sbar), PP, [ P, XP ]) :-
    XP => sbar,
    XP:tags => [],
    pp_p_arg_structure(P,XP,PP).

%% hij begon met te zeggen ...
grammar_rule(pp_p_arg(vp), PP, [ P, XP ]) :-
    XP => vp,
    XP:tags => [],
    XP:vform => te,
    XP:haswh => no,
    pp_p_arg_structure(P,XP,PP).

grammar_rule(pp_p_arg_part(np), PP, [ P, XP, Part ]) :-
    XP => np,
    XP:redrel => no,
    XP:nform => ~er,
    XP:parg => yes,
    XP:pred => npred,
    pp_p_arg_part_structure(P,XP,PP,Part).

grammar_rule(pp_p_arg_part(pp), PP, [ P, XP, Part ]) :-
    XP => pp,
    pp_p_arg_part_structure(P,XP,PP,Part).

grammar_rule(pp_p_arg_part(adv), PP, [ P, XP, Part ]) :-
    XP => adv,
    pp_p_arg_part_structure(P,XP,PP,Part).

grammar_rule(pred_van_belang,PRED,[VAN,BELANG]) :-
    PRED:deverbal => no,
    PRED:redrel => no,
    PRED:pcat => pp_pred,
    PRED:hstem <=> VAN:prep,
    PRED:nhstem <=> BELANG:hstem,
    VAN => p,
    VAN:dt:hdf => [],
    VAN:pp_role => pp_obj1,
    nwh_np_arg(BELANG0),
    unify_except_l(BELANG0,BELANG,[pred,e_deps]),
    BELANG:pred:predp <=> VAN:prep,
    BELANG:e_deps <=> PRED:e_deps, % het is van groot belang dat je komt
    unify_except_l(PRED0,PRED,[hstem,e_deps]),
    hd_comp_structure(VAN,BELANG,PRED0).


%% bij ons thuis
%% NB: "bij ons in de garage" is perhaps similar, but hard to distinguish
%% from [bij [ons pp[in de garage]] which we get anyway.
grammar_rule(pp_pp_adv,PP,[P,ADV]):-
    ADV => post_p_adv,
    PP => pp, P => pp,
    hd_mod_structure(P,ADV,PP).

%% TODO
%% the two complements of Met behave as a unit in coordination:
%% met Haider dronken en Bush op vakantie ...

%% met Haider dronken
grammar_rule(abs_p_predc,PP,[Met,NP,PRED]) :-
    abs_p_np_predc_structure(Met,NP,PRED,PP).

%% met Haider uiteraard dronken
grammar_rule(abs_p_mod_predc,PP,[Met,NP,MOD,PRED]) :-
    PP => pp,
    MOD => modifier,
    MOD:mcat => mcat_adv,
    PP0 => pp,
    hd_mod_structure(PP0,MOD,PP),
    abs_p_np_predc_structure(Met,NP,PRED,PP0).

%% met parallel hieraan een mooie versiering
%% met NP NP creates an ambiguity. Block predc obj1 order...

%% in many cases, this creates ambiguity with
%% met adj/MOD NP
%% met waarschijnlijk een uitzondering
%%
%% in the large majority of cases, the rel should be
%% MOD, not PREDC

%% met als gevolg een enorme ravage
grammar_rule(abs_p_predc_inv,PP,[Met,PRED,NP]) :-
    abs_p_np_predc_structure(Met,NP,PRED,PP),
    PRED:pcat => als_pred.

%% met als gevolg (natuurlijk) dat ..
grammar_rule(abs_p_predc_sbar_inv,PP,[Met,PRED,SBAR]) :-
    SBAR => sbar,
    SBAR:ctype => c_dat,
    SBAR:slash => [],
    SBAR:tags => [],
    SBAR:wh => nwh,
    abs_p_predc_structure(Met,SBAR,PRED,PP),
    PRED:pcat => als_pred.

grammar_rule(abs_p_predc_mod_sbar_inv,PP,[Met,PRED,MOD,SBAR]) :-
    PP => pp,
    MOD => modifier,
    MOD:mcat => mcat_adv,
    PP0 => pp,
    hd_mod_structure(PP0,MOD,PP),
    SBAR => sbar,
    SBAR:ctype => c_dat,
    SBAR:slash => [],
    SBAR:tags => [],
    SBAR:wh => nwh,
    abs_p_predc_structure(Met,SBAR,PRED,PP0),
    PRED:pcat => als_pred.

%% met als doel (natuurlijk) (om) carriere te maken
grammar_rule(abs_p_predc_vp_inv,PP,[Met,PRED,SBAR]) :-
    SBAR => vp,
    SBAR:slash => [],
    SBAR:tags => [],
    SBAR:vform => (om;te),
    SBAR:haswh => no,
    abs_p_predc_structure(Met,SBAR,PRED,PP),
    PRED:pcat => als_pred.

grammar_rule(abs_p_predc_mod_vp_inv,PP,[Met,PRED,MOD,SBAR]) :-
    PP => pp,
    MOD => modifier,
    MOD:mcat => mcat_adv,
    PP0 => pp,
    hd_mod_structure(PP0,MOD,PP),
    SBAR => vp,
    SBAR:slash => [],
    SBAR:tags => [],
    SBAR:vform => (om;te),
    SBAR:haswh => no,
    abs_p_predc_structure(Met,SBAR,PRED,PP0),
    PRED:pcat => als_pred.

abs_p_np_predc_structure(Met,NP,PRED,PP):-
    nwh_np_arg(NP),
    NP:wkpro => ~weakpro,
    abs_p_predc_structure(Met,NP,PRED,PP).

abs_p_predc_structure(Met,ARG,PRED,PP) :-
    PRED => pred,
    PRED:wh => nwh,
    PRED:slash => [],
    PRED:e_deps => [],
    PRED:subn => ~sub_indef_verb & ~sub_def_verb,
    abs_p_structure(Met,ARG,PRED,PP).

abs_p_structure(Met,ARG1,ARG2,PP) :-
    Met => abs_p,
    %% max_pp(PP),
    PP => pp,
    PP:preptype => no_ld_prep,
    PP:preptype => no_r_prep,
    PP:e_deps => [],
    PP:wh => nwh,
    PP:nnform => ~refl,
    PP:prep ==> absolute,
    PP:veps:in <=> PP:veps:out,
    PP:pp_er => no,
    hd_comp2_structure(Met,ARG1,ARG2,PP). 

abs_p_mod_structure(Met,NP,MOD,PP) :-
    nwh_np_arg(NP),
    NP:wkpro => ~weakpro,
    Met => abs_p,
    PP0 => pp,
    PP => pp,
    PP:preptype => no_ld_prep,
    PP:preptype => no_r_prep,
    PP:e_deps => [],
    PP:wh => nwh,
    PP:nnform => ~refl,
    PP:prep ==> absolute,
    PP:veps:in <=> PP:veps:out,
    PP:pp_er => no,
    hd_comp_structure(Met,NP,PP0),
    hd_mod_structure(PP0,MOD,PP).

%% met andermaal/opnieuw/altijd NP
%% met behalve NP NP
%% met zoals gezegd vele deelnemers
grammar_rule(abs_p_mod_np,PP,[Met,MOD,OPTDUBB,NP]) :-
    optdubb(OPTDUBB),
    max_modifier(MOD),
    MOD:mcat => (mcat_pp;mcat_adv;mcat_sbar),
    abs_p_mod_structure(Met,NP,MOD,PP).

grammar_rule(abs_p_np_mod,PP,[Met,NP,MOD]) :-
    max_modifier(MOD),
    MOD:mcat => (mcat_pp;mcat_adv),  % removed mcat_sbar??
    abs_p_mod_structure(Met,NP,MOD,PP).

%% met de duim (natuurlijk) omhoog ...
grammar_rule(abs_p_np_dir,PP,[Met,NP,MOD]) :-
    max_advp(MOD),
    MOD:tmploc => ld_dir,
    abs_p_mod_structure(Met,NP,MOD,PP).

%% met Kris het huis uit ...
grammar_rule(abs_p_np_post_pp,PP,[Met,NP,MOD]) :-
    MOD => post_pp,
    max(MOD),
    abs_p_mod_structure(Met,NP,MOD,PP).

grammar_rule(abs_p_np_mod_dir,PP,[Met,NP,MOD2,MOD]) :-
    PP => pp,
    MOD2 => modifier,
    MOD2:mcat => mcat_adv,
    PP0 => pp,
    hd_mod_structure(PP0,MOD2,PP),
    max_advp(MOD),
    MOD:tmploc => ld_dir,
    abs_p_mod_structure(Met,NP,MOD,PP0).

%%%%%%%%%%%%%%%%%%
%%%% SBAR etc %%%%
%%%%%%%%%%%%%%%%%%

%% coordinate conjunction, but not in coordination. This is now
%% treated as a complementizer selecting for root sentence.
%% rootbar --> comp (,:) root
%% where comp in {want,maar,en,of}

%% TODO: maar niet in Assen
%% in that case, don't allow all start types...
%% dus moet het niet gebeuren
%% spur.amb.; should not allow topic_drop start

grammar_rule(sbar(want),SBAR, [ Comp, OPTCOMMA, ROOT ]) :-
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    SBAR => rootbar,
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_root,
    ROOT => start,
    unify_mods(ROOT),
    COMMA => punct,
    COMMA:puncttype => (dubb_punt;komma;hellip),
    dlink_nucl_structure(Comp,ROOT,SBAR).

grammar_rule(sbar_want_tag,SBAR, [ Comp, COMMA1, TAG, COMMA2, ROOT ]) :-
    comma(COMMA1),
    comma(COMMA2),
    nwh_np_arg(TAG),
    SBAR => rootbar,
    unify_except(SBAR0,SBAR,dt),
    nucl_tag_structure(SBAR0,TAG,SBAR),
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_root,
    ROOT => start,
    unify_mods(ROOT),
    COMMA => punct,
    COMMA:puncttype => (dubb_punt;komma),
    dlink_nucl_structure(Comp,ROOT,SBAR0).
    

grammar_rule(sbar_want_dip,SBAR, [ Comp, COMMA1, DIP, COMMA2, ROOT ]) :-
    comma(COMMA1),
    comma(COMMA2),
    DIP => dip,
    SBAR => rootbar,
    SBAR0 => rootbar,
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_root,
    ROOT => start,
    unify_mods(ROOT),
    COMMA => punct,
    COMMA:puncttype => (dubb_punt;komma),
    dlink_nucl_structure(Comp,ROOT,SBAR0),
    nucl_tag_structure(SBAR0,DIP,SBAR).

grammar_rule(sbar_want_dip_q,SBAR, [ QL1,Comp,QR1,OPTCOMMA1,DIP,OPTCOMMA2,QL2,ROOT,OPTEND,QR2 ]) :-
    optcomma(OPTCOMMA1),
    optcomma(OPTCOMMA2),
    optend_punct(OPTEND,Type),
    ql(QL1),
    qr(QR1),
    ql(QL2),
    qr(QR2),
    DIP => dip,
    SBAR => rootbar,
    SBAR0 => rootbar,
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_root,
    ROOT => start,
    ROOT:puncttype <=> Type,
    unify_mods(ROOT),
    COMMA => punct,
    COMMA:puncttype => (dubb_punt;komma),
    dlink_nucl_structure(Comp,ROOT,SBAR0),
    nucl_tag_structure(SBAR0,DIP,SBAR).

grammar_rule(sbar_want_dip_q2,SBAR, [ QL1,Comp,QR1,OPTCOMMA1,DIP,OPTCOMMA2,QL2,ROOT,END ]) :-
    optcomma(OPTCOMMA1),
    optcomma(OPTCOMMA2),
    end_punct(END,Type),
    ql(QL1),
    qr(QR1),
    ql(QL2),
    DIP => dip,
    SBAR => rootbar,
    SBAR0 => rootbar,
    Comp => comp,
    Comp:e_deps => [],
    Comp:ctype => c_root,
    ROOT => start,
    ROOT:puncttype <=> Type,
    unify_mods(ROOT),
    COMMA => punct,
    COMMA:puncttype => (dubb_punt;komma),
    dlink_nucl_structure(Comp,ROOT,SBAR0),
    nucl_tag_structure(SBAR0,DIP,SBAR).

%% sbar --> comp vp
grammar_rule(sbar(al), SBAR, [ Comp, SV1 ]) :-
    SBAR => sbar, Comp => comp, SV1 => sv1,
    SV1:iexs => [],
    SV1:imexs => [],
    cmp_body_structure(Comp,SV1,SBAR).

grammar_rule(te, VP, [ Te, V ] ) :-
    te_v_structure(VP,Te,V).

grammar_rule(bracketed_te, VP, [ Te, OPEN, V, OPTPUNCT, CLOSE ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    te_v_structure(VP,Te,V).

te_v_structure(VP,Te,V) :-
    structure,
    VP => v, Te => te_comp, V => v,
    unify_mods(Te),
    unify_except_l(V,VP,[ccat0,ccat,dt,vform,cj]),
    VP:vform => (te;wk_te;pass_te),
    V:vform => inf,
    V:ccat0 <=> V:ccat,
    VP:dt:mod => [],
    VP:dt:app => [],
    VP:dt:det => [],
    VP:dt:predm => [],
    xy_dep_dt_nostype(Te,V,VP,ti,cmp,body).

grammar_rule(adj_te_v, AP, [ V ] ) :-
    AP => a,
    AP:adv => nadv,
    AP:aform => (attr;nattr),
    AP:deverbal => yes,
    AP:slash => [],
    AP:exs => [],
    AP:sc => [],
    AP:agr <=> V:adj_agr,  %% 'de te doorstane/*doorstaan proef
    AP:avform => avform_ti,
    AP:tmploc => ntmploc,
    V0 => vb,
    V0:vform => te,
    V0:vslash => [],
    % forbid clefts etc.
    V0:cleft => no,
    V0:subj => np,
    V0:subj:nform => norm,
    V0:subj:subn => sub_noun,
    hd_structure(V0,AP),
    unify_except(V0,V,sc),
    V:sc <=> [NP],
    NP => np,
    NP:dt => [],
    NP:allows_drop => yes,
    NP:case => acc.


grammar_rule(adj_te_zien, AP, [ V ] ) :-
    AP => a,
    AP:adv => yadv,
    AP:aform => (attr;nattr),
    AP:deverbal => yes,
    AP:slash => [],
    AP:exs => [],
    AP:sc <=> Tail,
    AP:agr <=> V:adj_agr,  %% 'de te doorstane/*doorstaan proef
    AP:avform => avform_aan_ti,
    AP:tmploc => ntmploc,
    V0 => vb,
    V0:vform => te,
    V0:vslash => [],
    % forbid clefts etc.
    V0:cleft => no,
    V0:subj => np,
    V0:subj:nform => norm,
    V0:subj:subn => sub_noun,
    hd_structure(V0,AP),
    unify_except(V0,V,sc),
    V:sc <=> [NP|Tail],
    V:hstem <=> STEM,
    alpino_wappend:wwmember(STEM,[zie,hoor,merk,oordeel,voel]),
    NP => np,
    NP:dt => [],
    NP:allows_drop => yes,
    NP:case => acc.

grammar_rule(sbar(van), SBAR, [ COMP, OPTDUBB, ROOT ]) :-
    OPTDUBB => optpunct,
    OPTDUBB:cat <=> DUBB,
    DUBB => punct,
    DUBB:puncttype => (dubb_punt;komma),
    SBAR => sbar, COMP => comp, ROOT => start,
    unify_mods(ROOT),
    COMP:ctype => c_van,
    cmp_body_structure(COMP,ROOT,SBAR).

sbar_comp_xp_structure(Comp,Arg,SBAR) :-
    SBAR => sbar, Comp => comp,
    cmp_body_structure(Comp,Arg,SBAR).

grammar_rule(sbar(np),SBAR,[ Comp, XP ]) :-
    np_arg(NP),
    unify_except_l(NP,XP,[case,e_deps]),  % zoals ik/mij
    XP:wkpro => ~weakpro,
    XP:redrel => no,
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(behalve_np), SBAR, [ Comp, Mod, XP ]) :-
    np_arg(NP),
    unify_except_l(NP,XP,[case,e_deps]),  % zoals ik/mij
    XP:wkpro => ~weakpro,
    XP:redrel => no,
    sbar_comp_behalve_xp_structure(Comp,XP,SBAR,Mod).

grammar_rule(sbar(mod_np),SBAR,[ Comp, COMMA, MOD, COMMA2, XP ]) :-
    comma_dash(COMMA),
    comma_dash(COMMA2),
    max_modifier(MOD),
    XP => np, 
    XP:pred => npred,
    XP:nform => (norm;meas_mod),
    XP:wkpro => ~weakpro,
    XP:redrel => no,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    sbar_comp_xp_structure(Comp,XP1,SBAR).

%% hack
%%
%% we kennen hem als :
%% if there is a modal adverb, as in
%% we kennen hem [ vooral als : ]
%% then 'als' is turned into the HD of a CP, which is wrong. But I don't
%% see any other way, and this is an infrequent event
%% alternative: have ':' as body?
grammar_rule(sbar(dubb),SBAR,[ Comp, DUBB ]) :-
    dubb(DUBB),
    max_np(NP),
    sbar_comp_xp_structure(Comp0,NP,SBAR0),
    unify_except_l(Comp0,Comp,[cmods,mods,cdets,dets,
                               cpredms,predms,ccat0,ccat,capps,apps]),
    unify_except_l(SBAR,SBAR0,[cmods,mods,cdets,dets,
                               cpredms,predms,ccat0,ccat,capps,apps,dt]),
    SBAR:dt <=> Comp:dt,
    SBAR:cmods <=> Comp:cmods,
    SBAR:mods <=> Comp:mods,
    SBAR:capps <=> Comp:capps,
    SBAR:apps <=> Comp:apps,
    SBAR:cdets <=> Comp:cdets,
    SBAR:dets <=> Comp:dets,
    SBAR:ccat0 <=> Comp:ccat0,
    SBAR:ccat <=> Comp:ccat,
    SBAR:cpredms <=> Comp:cpredms,
    SBAR:predms <=> Comp:predms.

grammar_rule(sbar(pp),SBAR,[ Comp, XP ]) :-
    max_pp(XP0),
    unify_except_l(XP0,XP,[wh,e_deps]),
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(behalve_pp),SBAR,[Comp,Mod,XP]) :-
    max_pp(XP0),
    XP0:sel => ~to_topic,
    unify_except_l(XP0,XP,[wh,e_deps]),
    sbar_comp_behalve_xp_structure(Comp,XP,SBAR,Mod).

sbar_comp_behalve_xp_structure(Comp,XP,SBAR,Mod) :-
    max_advp(Mod),
    SBAR => sbar,
    sbar_comp_xp_structure(Comp,XP,SBAR0),
    hd_mod_structure(SBAR0,Mod,SBAR),
    Comp:hstem <=> Stem,
    alpino_wappend:wwmember(Stem,[behalve,'zij het',tenzij]).

grammar_rule(sbar(mod_pp),SBAR,[ Comp, COMMA, MOD, COMMA2, XP ]) :-
    comma_dash(COMMA),
    comma_dash(COMMA2),
    max_modifier(MOD),
    XP0 => pp,
    XP0:ld_pc => (mod_pp;pred_pp),
    XP0:nnform => ~refl,
    max(XP0),
    XP0:pp_role => pp_obj1,
    unify_except(XP0,XP,e_deps),
    XP1 => pp,
    hd_mod_structure(XP,MOD,XP1),
    unify_mods(XP1),
    sbar_comp_xp_structure(Comp,XP1,SBAR).

grammar_rule(sbar(a),SBAR,[ Comp, XP ]) :-
    max_nadv_ap(XP0),
    unify_except_l(XP0,XP,[adv,e_deps,wh]),
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(quoted_a),SBAR,[ Comp, QL, XP, QR ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    ql(QL),
    qr(QR),
    max_nadv_ap(XP0),
    unify_except_l(XP0,XP,[adv,e_deps,wh]),
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(adv),SBAR,[ Comp, XP ]) :-
    max_advp(XP),
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(sbar),SBAR,[ Comp, XP ]) :-
    XP => sbar,
    XP:wh => nwh,
    XP:tags => [],
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(behalve_sbar),SBAR,[ Comp, Mod, XP ]) :-
    XP => sbar,
    XP:wh => nwh,
    XP:tags => [],
    sbar_comp_behalve_xp_structure(Comp,XP,SBAR,Mod).


grammar_rule(sbar(vp),SBAR,[ Comp, XP ]) :-
    XP => vp,
    XP:vform => (om;fin),
    XP:haswh => no,
    XP:subj => np,
    XP:subj:prs =?> ~invje,
    sbar_comp_xp_structure(Comp,XP,SBAR).

grammar_rule(sbar(behalve_vp),SBAR,[ Comp, Mod, XP ]) :-
    XP => vp,
    XP:vform => (om;fin),
    XP:haswh => no,
    XP:subj => np,
    XP:subj:prs =?> ~invje,
    sbar_comp_behalve_xp_structure(Comp,XP,SBAR,Mod).

grammar_rule(sbar(vpx),SBAR,[ Comp, XP ]) :-
    XP => vpx,
    XP:vform => (inf;psp),
    no_vslash(XP),
    XP:haswh => no,
    sbar_comp_xp_structure(Comp,XP,SBAR).

%% ik kom , tenzij...
%% ik kom , omdat :
grammar_rule(sbar_punct,SBAR, [ Comp, DUBB ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Comp => comp,
    Comp:ctype => c_mod,
    Comp:wh => nwh,
    SBAR => sbar,
    SBAR:slash => [],
    SBAR:tags => [],
    DUBB => punct,
    DUBB:puncttype => (dubb_punt;hellip),
    XP => vp,
    XP:vform => fin,
    XP:haswh => no,
    XP:slash => [],
    hd_comp_structure(Comp,XP,SBAR).

grammar_rule(start_comp_punct,SBAR, [ Comp, DUBB ]) :-
    Comp => comp,
    Comp:ctype => c_mod,
    Comp:wh => nwh,
    SBAR => start,
    DUBB => punct,
    DUBB:puncttype => vraag,
    XP => vp,
    XP:vform => fin,
    XP:haswh => no,
    XP:slash => [],
    hd_comp_structure(Comp,XP,SBAR).

grammar_rule(pp_p_arg(start1), PP, [ P, DUBB, OPTQL, XP, OPTPUNCT, OPTQR ]) :-
    XP => start,
    sbar_comp_xp_structure(P,XP,PP),
    P:ctype => c_compare_np,
    dubb(DUBB),
    optql(OPTQL),
    OPTPUNCT => optpunct,
    OPTPUNCT:cat <=> Punct,
    Punct => punct,
    Punct:puncttype => (vraag;uitroep;hellip),
    optqr(OPTQR).

grammar_rule(pp_p_arg(start2), PP, [ P, QL, XP, OPTPUNCT, QR ]) :-
    XP => start,
    sbar_comp_xp_structure(P,XP,PP),
    P:ctype => c_compare_np,
    ql(QL),
    qr(QR),
    OPTPUNCT => optpunct,
    OPTPUNCT:cat <=> Punct,
    Punct => punct,
    Punct:puncttype => (vraag;uitroep;hellip).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%% DP rules %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% mocht ik slapen dan kom ik later
%% "would I sleep then come I later"
%%  and "als je komt dan ben ik blij"
%%       with a similar deptree
%   and: "NP dat is leuk

grammar_rule(ques_dan,ROOT,[Ques, Dan]) :-
    ROOT => max,
    ROOT:max_type => t_dp,
    max_sv1(Ques),
    max_root(Dan), Dan:needs_dip => no,
    Dan:topic_hstem ==> dan,
    % Waren het vorige week de Duitsers , deze week ...
    nucl_sat_structure(Dan,Ques,ROOT).

grammar_rule(ques_comma_dan,ROOT,[Ques, COMMA, Dan]) :-
    comma(COMMA),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_sv1(Ques),
    max_root(Dan), Dan:needs_dip => no,
    % Waren het vorige week de Duitsers , deze week ...
    nucl_sat_structure(Dan,Ques,ROOT).

grammar_rule(ques_ques,ROOT,[Ques, OPTC, Dan]) :-
    comma(OPTC),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_sv1(Ques),
    max_sv1(Dan),
    nucl_sat_structure(Dan,Ques,ROOT).

%% mocht u vragen hebben, neem dan contact op met ...
grammar_rule(ques_imp,ROOT,[Ques, OPTC, Dan]) :-
    optcomma(OPTC),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_sv1(Ques),
    max_imp(Dan),
    nucl_sat_structure(Dan,Ques,ROOT).

%% voor vragen , zie de uitleg op bladzijde 23
grammar_rule(pp_imp,ROOT,[Ques, OPTC, Dan]) :-
    comma(OPTC),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_pp(Ques),
    Ques:sel => ~to_topic,
    max_imp(Dan),
    nucl_sat_structure(Dan,Ques,ROOT).

%% al met al , geef ons alstublieft twee weken .
grammar_rule(advp_imp,ROOT,[Ques, OPTC, Dan]) :-
    comma(OPTC),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_advp(Ques),
    max_imp(Dan),
    nucl_sat_structure(Dan,Ques,ROOT).

%% om je op te geven , surf naar www.let.rug.nl
grammar_rule(vp_imp,ROOT,[Ques, OPTC, Dan]) :-
    comma(OPTC),
    ROOT => max,
    ROOT:max_type => t_dp,
    max_vp(Ques),
    Ques:vform => om,
    max_imp(Dan),
    nucl_sat_structure(Dan,Ques,ROOT).

root_nucl_sat_structure(Dan,Max,ROOT) :-
    ROOT => max,
    ROOT:max_type => t_dp,
    max_root(Dan),
    Dan:needs_dip => no,
%    Max:wh =?> nwh,   % waarom , dat wist hij niet
                       % welke schrijver , dat wist hij niet
    Max:e_deps =?> [],
    nucl_sat_structure(Dan,Max,ROOT).

root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT) :-
    ROOT => max,
    ROOT:max_type => t_dp,
    max_root(Dan),
    Dan:needs_dip => no,
    Max:wh =?> nwh,
    Max:e_deps =?> [],
    nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% Piet , ik vind hem een vervelende vent
grammar_rule(sat_nucl(np),ROOT,[Max, COMMA, Dan]) :-
    comma(COMMA),
    max_np(Max1),
    Max:subn => ~sub_det,
    unify_except(Max1,Max,wh), %% welke minister , dat wist hij niet
    Max:redrel => no,
    root_nucl_sat_structure(Dan,Max,ROOT).

%% aanloop
%% Piet die mag ik niet
%% informeel en gesproken taalgebruik
grammar_rule(sat_nucl(aanloop),ROOT,[Max, Dan]) :-
    max_np(Max),
    Max:subn => ~sub_det,
    Max:redrel => no,
    root_nucl_sat_structure(Dan,Max,ROOT),
    Dan:topic_hstem <=> STEM,
    alpino_wappend:wwmember(STEM,[die,dat,daar]).

grammar_rule(sat_tag_nucl(np),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_np(Max),
    Max:subn => ~sub_det,
    Max:redrel => no,
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% In Amsterdam , daar kun je goed uitgaan
grammar_rule(sat_nucl(pp),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_pp(Max1),
    Max1:sel => ~to_topic,
    unify_except(Max1,Max,wh),  %% waarom, dat wist hij niet
    root_nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(sat_tag_nucl(pp),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_pp(Max),
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% Als je wilt , dan komen we later
%% Al schreeuw je nog zo hard, we gaan niet
grammar_rule(sat_nucl(sbar),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    Max:ctype => (c_mod;c_dat;c_of),
    root_nucl_sat_structure(Dan,Max,ROOT).

%% om kort te gaan, ik kom niet
grammar_rule(sat_nucl(oti),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_vp(Max),
    Max:vform => om,
    Max:e_deps => [],
    root_nucl_sat_structure(Dan,Max,ROOT).

%% Als dat niet arrogant is, wat dan wel ?
grammar_rule(sat_nucl(sbar,whsub),ROOT,[Max,COMMA,Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    Max:ctype => c_mod,
    ROOT => max,
    ROOT:max_type => t_dp,
    ROOT:puncttype => (punt;uitroep;vraag;hellip),
    max_sbar(Dan),
    Dan:ctype => c_of_short,
    nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(sat_tag_nucl(sbar),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_sbar(Max),
    Max:ctype => (c_mod;c_dat;c_of),
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

grammar_rule(sat_nucl_nocomma(sbar),ROOT,[Max, Dan]) :-
    max_sbar(Max),
    Max:ctype => c_mod,  % als je wilt dan kom ik later
                         % zo niet dan kom ik later
    root_nucl_sat_structure(Dan,Max,ROOT),
    Dan:topic_hstem ==> dan.

%% Als je dat wilt , zeur (dan) niet over...
grammar_rule(sat_nucl(sbar_imp),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    Max:ctype => c_mod,
    ROOT => max,
    ROOT:max_type => t_dp,
    max_imp(Dan),
    nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(sat_tag_nucl(sbar_imp),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    optcomma(OPTCOMMA),
    Max:ctype => c_mod,
    ROOT => max,
    ROOT:max_type => t_dp,
    max_imp(Dan),
    nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% Als je dat wilt , kun je het dan ook ?
grammar_rule(sat_nucl(sbar_ques),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    Max:ctype => c_mod,
    ROOT => max,
    ROOT:max_type => t_dp,
    ROOT:puncttype => vraag,
    max_sv1(Dan),
    nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(sat_tag_nucl(sbar_ques),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_sbar(Max),
    optcomma(OPTCOMMA),
    Max:ctype => c_mod,
    ROOT => max,
    ROOT:max_type => t_dp,
    ROOT:puncttype => vraag,
    max_sv1(Dan),
    nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% wat je ook zegt , ik kom niet
grammar_rule(sat_nucl(redrel),ROOT,[Max, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_redrel(Max),
    root_nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(sat_tag_nucl(redrel),ROOT,[Max, OPTCOMMA, TAG, COMMA, Dan]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_redrel(Max),
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% Het is een vervelende vent , die kerel
grammar_rule(nucl_sat(np),ROOT,[Dan, COMMA, Max]) :-
    comma_dash(COMMA),
    max_np(Max),
    Max:subn => ~sub_det,
    Max:redrel => no,
    root_nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(nucl_tag_sat(np),ROOT,[Dan, OPTCOMMA, TAG, COMMA, Max]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_np(Max),
    Max:subn => ~sub_det,
    Max:redrel => no,
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%% dat verbaast me , dat je dat nog weet
%% hij heeft zeker verloren , dat hij zo sip kijkt
%% .. namelijk
%%    te weten
%%    dat wil zeggen
%% zij het
%% althans
%% 
%% Het wordt al weer wat kouder en mijn spieren zijn nogal gevoelig , zodat ik moet uitkijken " .
grammar_rule(nucl_sat(sbar),ROOT,[Dan, COMMA, Max]) :-
    comma_end(COMMA),
    max_sbar(Max),
    Max:ctype => (c_mod;c_dat;c_of),
    root_nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(nucl_tag_sat(sbar),ROOT,[Dan, OPTCOMMA, TAG, COMMA, Max]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_sbar(Max),
    Max:ctype => (c_mod;c_dat;c_of),
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

%%% not used !?!?
grammar_rule(nucl_sat(redrel),ROOT,[Dan, COMMA, Max]) :-
    COMMA => punct, COMMA:puncttype => komma,
    max_redrel(Max),
    root_nucl_sat_structure(Dan,Max,ROOT).

grammar_rule(nucl_tag_sat(redrel),ROOT,[Dan, OPTCOMMA, TAG, COMMA, Max]) :-
    COMMA => punct, COMMA:puncttype => komma,
    optcomma(OPTCOMMA),
    max_redrel(Max),
    root_nucl_sat_tag_structure(Dan,Max,TAG,ROOT).

grammar_rule(nucl_sat_brackets,ROOT,[Dan, BrL, Max, OptQm, BrR]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    BrL => punct, BrL:puncttype => haak_open,
    BrR => punct, BrR:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    Max => start,
    root_nucl_sat_structure(Dan,Max,ROOT).

%% atman = zelf
grammar_rule(np_is_np,START,[NPA,EQUALS,NPB]) :-
    START => max,
    START:max_type => t_xp,
    max_np(NPA),
    max_np(NPB),
    EQUALS => punct,
    EQUALS:puncttype => is_gelijk,
    dp_dp_structure(NPA,NPB,START).

%% allemaal gelul
grammar_rule(predm_adv_np_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_np(XP),
    XP:subn => ~sub_indef_verb & ~sub_det,
    dp_dp_structure(ADV,XP,MAX).

%% allemaal voor twee tientjes
grammar_rule(predm_adv_pp_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_pp(XP),
    dp_dp_structure(ADV,XP,MAX).

%% allemaal om indruk te maken
grammar_rule(predm_adv_vp_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_vp(XP),
%    mod_om_vp(XP),
    XP:e_deps => [],
    XP:vform => om,		% otherwise single vp?
    dp_dp_structure(ADV,XP,MAX).

%% allemaal omdat hij indruk wil maken
grammar_rule(predm_adv_sbar_dp,MAX,[ADV,OPTCOMMA,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_sbar(XP),
    XP:ctype => c_mod,
    optcomma(OPTCOMMA),
    dp_dp_structure(ADV,XP,MAX).

%% allemaal leuk voor later
grammar_rule(predm_adv_ap_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_nadv_ap(XP),
    XP:adv => nboth,
    dp_dp_structure(ADV,XP,MAX).

%% leuk voor later , allemaal
grammar_rule(predm_ap_adv_dp,MAX,[XP,COMMA,ADV]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_nadv_ap(XP),
    XP:adv => nboth,
    optcomma(COMMA),
    dp_dp_structure(ADV,XP,MAX).

%% allemaal tevergeefs
grammar_rule(predm_adv_advp_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_advp(XP),
    dp_dp_structure(ADV,XP,MAX).

%% tevergeefs , allemaal
grammar_rule(predm_advp_adv_dp,MAX,[XP,COMMA,ADV]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_predm(ADV),
    max_advp(XP),
    optcomma(COMMA),
    dp_dp_structure(ADV,XP,MAX).

%% samen goed voor een ton
grammar_rule(preda_adv_advp_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_ap(ADV),
    ADV:adv => padv,
    max_advp(XP),
    dp_dp_structure(ADV,XP,MAX).

%% samen een auto
grammar_rule(preda_adv_np_dp,MAX,[ADV,XP]) :-
    MAX => max,
    MAX:max_type => t_xp,
    max_ap(ADV),
    ADV:adv => padv,
    max_np(XP),
    XP:subn => ~sub_indef_verb & ~sub_det,
    dp_dp_structure(ADV,XP,MAX).

pred_sbar_dp_structure(MAX,ADJ,SBAR) :-
    MAX => max,
    MAX:max_type => t_xp,
    ADJ => pred,
    ADJ:redrel => no,
    ADJ:pcat => (np_pred;ap_pred),   % np_pred: hoogste tijd dat hij komt; een schande dat hij niet kwam
    ADJ:slash => [],
    ADJ:exs => [],
    ADJ:wh => nwh,
    ADJ:e_deps <=> [SBAR],
    unify_mods(ADJ),
    dp_dp_structure(ADJ,SBAR,MAX).

pred_adv_sbar_dp_structure(MAX,ADVP,ADJ,SBAR) :-
    MAX => max,
    MAX:max_type => t_xp,
    ADJ => pred,
    ADJ:redrel => no,
    ADJ:pcat => (np_pred;ap_pred),
    ADJ:slash => [],
    ADJ:exs => [],
    ADJ:wh => nwh,
    ADJ:e_deps <=> [SBAR],
    unify_mods(ADJ),
    dp_dp_structure(ADVP,ADJ,SBAR,MAX).

%% jammer dat hij niet komt
%% onbegrijpelijk hoe dit kon gebeuren
%% raadselachtig of hij komt
%% ongelooflijk wat een troep
grammar_rule(pred_sbar_dp,MAX,[ADJ,OPTCOMMA,SBAR]) :-
    max_sbar(SBAR),
    pred_sbar_dp_structure(MAX,ADJ,SBAR),
    optcomma(OPTCOMMA),
    SBAR:ctype => (c_dat;c_of;c_redrel;c_of_short).

%% jammer dus dat hij niet komt
grammar_rule(pred_adv_sbar_dp,MAX,[ADJ,OPTCOMMA,ADVP,OPTCOMMA2,SBAR]) :-
    max_sbar(SBAR),
    max_modifier(ADVP),
    ADVP:mcat => (mcat_pp;mcat_adv),
    ADVP:wh => nwh,
    pred_adv_sbar_dp_structure(MAX,ADVP,ADJ,SBAR),
    optcomma(OPTCOMMA),
    optcomma(OPTCOMMA2),
    SBAR:ctype => (c_dat;c_of;c_redrel).

grammar_rule(pred_sbar_tag_dp,MAX,[ADJ,OPTCOMMA,TAG,OPTCOMMA2,SBAR]) :-
    max_sbar(SBAR),
    pred_sbar_dp_structure(MAX0,ADJ,SBAR),
    optcomma(OPTCOMMA),
    optcomma(OPTCOMMA2),
    unify_except_dt(MAX0,MAX),
    TAG => tag,
    nucl_tag_structure(MAX0,TAG,MAX),
    SBAR:ctype => (c_dat;c_of;c_of_short).

%% leuk om je weer eens te spreken
%% NOW SUBSUMED BY adv_vp_dp/adj_vp_dp
%% in case there is "om".
grammar_rule(pred_vp_dp,MAX,[ADJ,SBAR]) :-
    max_vp(SBAR),
    SBAR:vform => te,
    pred_sbar_dp_structure(MAX,ADJ,SBAR).

%% lief dat je dat wilt doen
%% leuk dat ze gekomen zijn
grammar_rule(pred_sbar_dp,MAX,[ADJ,SBAR]) :-
    max_sbar(SBAR),
    SBAR:ctype => c_dat,
    SBAR:vform => te,
    pred_sbar_dp_structure(MAX,ADJ,SBAR).

% vandaar/wellicht/misschien/allicht dat hij niet komt
grammar_rule(adv_dat_sbar_dp,MAX,[ADV,OPTCOMMA,SBAR]) :-
    MAX => max,
    MAX:max_type => t_xp,
    ADV => vandaar_adv,
    optcomma(OPTCOMMA),
    max_sbar(SBAR),
    SBAR:ctype => c_dat,
    dp_dp_structure(ADV,SBAR,MAX).

% zo van : we gaan naar huis
grammar_rule(adv_zo_van_sbar_dp,MAX,[ADV,SBAR]) :-
    MAX => sbar,
    MAX:tmploc => ntmploc,
    MAX:ctype => c_mod,
    MAX:slash => [],
    MAX:tags => [],
    ADV => zo_van_adv,
    SBAR => sbar,
    max(SBAR),
    SBAR:ctype => c_van,
    dp_dp_structure(ADV,SBAR,MAX).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% various DP DP structs %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar_rule(start_start_punt_komma,M,[A,COMMA,B]) :-
    COMMA => punct, COMMA:puncttype => (punt_komma;hellip;dubb_punt;schuin_streep;punt;vraag;uitroep),
    (   hdrug_util:hdrug_flag(parse_or_generate,generate),
	COMMA:puncttype => punt_komma
    ;   hdrug_util:hdrug_flag(parse_or_generate,parse)
    ),
    A => start,
    B => start,
    M => start,
    M:branch => yes,
    A:branch => no,   % for a;b;c;d only allow a;(b;(c;d))
    M:puncttype <=> B:puncttype,
    dp_dp_structure(A,B,M).

grammar_rule(start_start_ligg_streep,M,[A,COMMA,B]) :-
    COMMA => punct, COMMA:puncttype => ligg_streep,
    A => start,
    B => start,
    M => start,
    M:branch => yes,
    A:branch => no,   % A - B - C is not parsed as a series
    B:branch => no,   % but rather as A ( B ) C
    M:puncttype <=> B:puncttype,
    dp_dp_structure(A,B,M).

grammar_rule(start_start_dubb_punt,M,[A,COMMA,B]) :-
    COMMA => punct, COMMA:puncttype => dubb_punt,
    A => start,
    B => start,
    M => start,
    M:branch => yes,
    A:branch => no,   % for a;b;c;d only allow a;(b;(c;d))
    M:puncttype <=> B:puncttype,
    nucl_sat_structure(A,B,M).

grammar_rule(start_start_dubb_punt_q,M,[A,COMMA,QL,B,QR]) :-
    COMMA => punct, COMMA:puncttype => dubb_punt,
    ql(QL),
    qr(QR),
    A => start,
    B => start,
    M => start,
    M:puncttype <=> B:puncttype,
    nucl_sat_structure(A,B,M).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% FRAGMENTS %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dit_omdat_structure(Start,PRON,SBAR) :-
    PRON => pron,
    PRON:agr => sg&het&def,
    PRON:wkpro => ~weakpro,
    PRON:parg => no,
    np_omdat_structure(Start,PRON,SBAR).

dit_omdat_structure(Start,PRON,ALLEMAAL,SBAR) :-
    PRON => pron,
    PRON:agr => sg&het&def,
    PRON:wkpro => ~weakpro,
    PRON:parg => no,
    np_omdat_structure(Start,PRON,ALLEMAAL,SBAR).

np_omdat_structure(Start,N,SBAR) :-
    N:wh => nwh,
    SBAR:e_deps =?> [],
    max(N),
    Start => start,
    dp_dp_structure(N,SBAR,Start).

np_omdat_structure(Start,N,ALLEMAAL,SBAR) :-
    N:wh => nwh,
    SBAR:e_deps =?> [],
    max(N),
    Start => start,
    dp_dp_structure(N,ALLEMAAL,SBAR,Start).

grammar_rule(dit_omdat,Start,[PRON,OPTCOMMA,SBAR]) :-
    max_sbar(SBAR),
    SBAR:ctype => c_mod,
    optcomma(OPTCOMMA),
    PRON => np,
    np_omdat_structure(Start,PRON,SBAR).

grammar_rule(dit_allemaal_omdat,Start,[PRON,ALLEMAAL,OPTCOMMA,SBAR]) :-
    max_sbar(SBAR),
    max_predm(ALLEMAAL),
    SBAR:ctype => c_mod,
    optcomma(OPTCOMMA),
    PRON => np,
    np_omdat_structure(Start,PRON,ALLEMAAL,SBAR).

grammar_rule(dit_om,Start,[PRON,OPTCOMMA,SBAR]) :-
    max_vp(SBAR),
    SBAR:vform => om,
    optcomma(OPTCOMMA),
    dit_omdat_structure(Start,PRON,SBAR).

grammar_rule(dit_allemaal_om,Start,[PRON,ALLEMAAL,OPTCOMMA,SBAR]) :-
    max_vp(SBAR),
    max_predm(ALLEMAAL),
    SBAR:vform => om,
    optcomma(OPTCOMMA),
    dit_omdat_structure(Start,PRON,ALLEMAAL,SBAR).

grammar_rule(dit_vanwege,Start,[PRON,OPTCOMMA,SBAR]) :-
    max_pp(SBAR),
    optcomma(OPTCOMMA),
    dit_omdat_structure(Start,PRON,SBAR).

grammar_rule(dit_allemaal_vanwege,Start,[PRON,ALLEMAAL,OPTCOMMA,SBAR]) :-
    max_pp(SBAR),
    max_predm(ALLEMAAL),
    optcomma(OPTCOMMA),
    dit_omdat_structure(Start,PRON,ALLEMAAL,SBAR).

%% typical ellipsis: modifier followed by np
%% vanaf 1930 hoogleraar in Groningen
%% later directeur van Veendam
%% om te beginnen de neveneffecten
%% als laatste het milieu
%% TODO "bijgaand de notulen"
grammar_rule(start_mod_np,M,[MOD,NP]) :-
    M => max,
    M:max_type => t_dp,
    M:mod_np => yes,
    max_modifier(MOD),
    MOD:mcat => (mcat_pp;mcat_adv;mcat_vp;mcat_sbar),
    MOD:wh => nwh,  % separate rule for wh case
    max_np(NP),
    NP:subn => ~sub_indef_verb, %  & ~sub_det,   "en nu dit, maar eerst even dit"
    dp_dp_structure(MOD,NP,M).

max_dp_modifier(MOD) :-
    max_modifier(MOD),
    MOD:mcat => (mcat_pp;mcat_adv;mcat_vp;mcat_sbar),
    MOD:wh => nwh,
    MOD:wh_reltmploc => ~meas_n.

%% daarom hierbij een opmerking
%% daarom omdat het zo leuk is een herhaling
grammar_rule(start_mod_mod_np,M,[MOD1,MOD2,NP]) :-
    M => max,
    M:max_type => t_dp,
    M:mod_np => yes,
    max_dp_modifier(MOD1),
    max_dp_modifier(MOD2),
    max_np(NP),
    NP:subn => ~sub_indef_verb, %  & ~sub_det,   "en nu dit, maar eerst even dit"
    dp_dp_structure(MOD1,MOD2,NP,M).

%% plotseling gejoel buiten
grammar_rule(start_mod_np_mod,M,[MOD1,NP,MOD2]) :-
    M => max,
    M:max_type => t_dp,
    M:mod_np => yes,
    max_dp_modifier(MOD1),
    max_dp_modifier(MOD2),
    max_np(NP),
    NP:subn => ~sub_indef_verb, %  & ~sub_det,   "en nu dit, maar eerst even dit"
    dp_dp_structure(MOD1,MOD2,NP,M).

%% Ernst Happel na afloop over dit rare incident
%% Lubbers opnieuw verwikkeld in sexschandaal
grammar_rule(start_np_mod_mod,M,[NP,MOD1,MOD2]) :-
    M => max,
    M:max_type => t_dp,
    M:mod_np => yes,
    max_dp_modifier(MOD1),
    max_dp_modifier(MOD2),
    max_np(NP),
    NP:subn => ~sub_indef_verb, %  & ~sub_det,   "en nu dit, maar eerst even dit"
    dp_dp_structure(MOD1,MOD2,NP,M).

% voor wie hem kent , een verrassing
grammar_rule(start_mod_comma_np,M,[MOD,COMMA,NP]) :-
    comma(COMMA),
    M => start,
    max_modifier(MOD),
    MOD:mcat => (mcat_pp;mcat_adv;mcat_vp),
    MOD:wh => nwh,  % separate rule for wh case
    max_np(NP),
    NP:subn => ~sub_indef_verb & ~sub_det,
    dp_dp_structure(MOD,NP,M).

grammar_rule(dp_dp_root,ROOT,[ROOTA, COMMA, ROOTB]) :-
    end_punct(COMMA,Punct),
    ROOT => max,
    ROOT:max_type => t_dp,
    ROOTA => max,
    ROOTA:max_type => (t_dp;t_root;t_rootbar;t_topic_drop),
    ROOTA:puncttype <=> Punct,
    ROOTB => max,
    ROOTB:max_type => (t_dp;t_root),
    dp_dp_structure(ROOTA,ROOTB,ROOT).

grammar_rule(dp_dp_root_sv1,ROOT,[ROOTA, COMMA, ROOTB]) :-
    end_punct(COMMA,Punct),
    ROOT => max,
    ROOT:max_type => t_dp,
    ROOTA => max,
    ROOTA:max_type => (t_dp;t_root),
    ROOTA:puncttype <=> Punct,
    max_sv1(ROOTB),
    dp_dp_structure(ROOTA,ROOTB,ROOT).

grammar_rule(dp_tag_dp_root,ROOT,[ROOTA, OPTCOMMA, TAG, COMMA, ROOTB]) :-
    comma_hellip(COMMA),
    optcomma(OPTCOMMA),
    ROOT => root,
    ROOT:subj => no,
    ROOT:needs_dip => no,
    ROOT:allows_root_imp => no,
    max_root(ROOTA),ROOTA:needs_dip => no,
    max_root(ROOTB),ROOTB:needs_dip => no,
    dp_tag_dp_structure(ROOTA,TAG,ROOTB,ROOT).

%% kortom, gelul
%% ongelooflijk, wat een weelde
%% MAYBE this rule poses more problems than it solves?
%% maybe refuse ADV that are also TAG
grammar_rule(adv_np_dp,MAX,[ADV,COMMA,XP]) :-
    comma_hellip(COMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_np(XP0),
    unify_except(XP0,XP,wh),
    XP:subn => ~sub_indef_verb & ~sub_det,
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adv_tag_np_dp,MAX,[ADV,OPTCOMMA,TAG,COMMA,XP]) :-
    comma_hellip(COMMA),
    optcomma(OPTCOMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_np(XP),
    XP:subn => ~sub_indef_verb & ~sub_det,
    dp_tag_dp_structure(ADV,TAG,XP,MAX).

%% onzin , derhalve
%% 
%% Ik niet; Hij wel; Piet dus
%% maybe refuse ADV that are also TAG
%% inschrijven verplicht
%% reserveren gewenst
%% vissen verboden
%% dat nooit (meer)
%% dat niet
grammar_rule(np_adv_dp,MAX,[XP,OPTCOMMA,ADV]) :-
    optcomma(OPTCOMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_advp(ADV),
    ADV:redrel => no,
    max_np(XP),
    XP:subn => ~sub_num & ~sub_indef_adj & ~sub_def_adj & ~sub_rang & ~sub_tmp & ~sub_veel,
    dp_dp_structure(XP,ADV,MAX).

%% (waarvan) drie ernstig
grammar_rule(num_adv_dp,MAX,[XP,OPTCOMMA,ADV]) :-
    optcomma(OPTCOMMA),
    MAX => max,
    MAX:max_type => t_part,
    max_advp(ADV),
    ADV:redrel => no,
    max_np(XP),
    XP:subn => (sub_num ; sub_indef_adj ; sub_def_adj ; sub_rang ; sub_tmp ; sub_veel),
    dp_dp_structure(XP,ADV,MAX).

%% (waarvan) drie met brandwonden (en vier ernstig)
grammar_rule(num_pp_dp,MAX,[XP,OPTCOMMA,ADV]) :-
    optcomma(OPTCOMMA),
    MAX => max,
    MAX:max_type => t_part,
    max_pp(ADV),
    max_np(XP),
    dp_dp_structure(XP,ADV,MAX).

grammar_rule(np_adv_tag_dp,MAX,[XP,ADV,OPTCOMMA,TAG]) :-
    optcomma(OPTCOMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_advp(ADV),
    ADV:redrel => no,
    max_np(XP),
    XP:subn => ~sub_indef_verb & ~sub_det & ~sub_num & ~sub_indef_adj & ~sub_def_adj & ~sub_rang & ~sub_tmp & ~sub_veel,
    dp_tag_dp_structure(ADV,TAG,XP,MAX).

%% kortom, in Amsterdam
%% maybe refuse ADV that are also TAG
grammar_rule(adv_pp_dp,MAX,[ADV,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_advp(ADV),
    ADV:wk => no,
    ADV:tmploc => ~loc & ~tmp & ~wk_er & ~str_er,   % cf adv_adv_pps...
    %%    ADV:subadv => ~subadv_adj,         % cf a_a_pps...
    %%    vaak onder de allerarmsten
    %%    dikwijls zonder jas
    ADV:redrel => no,
    max_pp(XP),
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(tag_adv_pp_dp,MAX,[TAG,COMMA,ADV,XP]) :-
    comma(COMMA),
    MAX => start,
    max_advp(ADV),
    ADV:tmploc => ~loc & ~tmp & ~wk_er & ~str_er,   % cf adv_adv_pps...
    ADV:subadv => ~subadv_adj,         % cf a_a_pps...
    ADV:redrel => no,
    max_pp(XP),
    dp_tag_dp_structure(ADV,TAG,XP,MAX).

grammar_rule(a_pp_dp,MAX,[A,COMMA,XP]) :-
    comma_hellip(COMMA),
    MAX => start,
    max_ap(A),
    max_pp(XP),
    dp_dp_structure(A,XP,MAX).

%% tot nu toe zonder succes
grammar_rule(pp_part_pp_dp,MAX,[PP,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => max,
    MAX:max_type => t_xp,
    max_pp(PP),
    PP:haspart => yes,
    max_pp(XP),
    dp_dp_structure(PP,XP,MAX).

%% misschien wel ja , in bepaalde omstandigheden
grammar_rule(a_tag_pp_dp,MAX,[A,TAG,COMMA,XP]) :-
    comma_hellip(COMMA),
    MAX => start,
    max_ap(A),
    max_pp(XP),
    dp_tag_dp_structure(A,TAG,XP,MAX).

%% liever niet
%% eindeloos bijna
grammar_rule(a_advp_dp,MAX,[A,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_ap(A0),
    unify_except_l(A0,A,[deverbal,avform]),
    A:avform => (avform_ap;avform_aan_ti;avform_ppart),
    max_advp(XP),
    dp_dp_structure(A,XP,MAX).

grammar_rule(adv_vp_dp,MAX,[ADV,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_vp(XP),
    XP:e_deps => [],
    XP:vform => om, % otherwise adv normally is modifier of VP
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adv_vp_tag_dp,MAX,[ADV0,TAG,COMMA,XP]) :-
    max_advp(ADV),
    optcomma(COMMA),
    MAX => start,
    unify_except_dt(ADV0,ADV),
    TAG => tag,
    nucl_tag_structure(ADV0,TAG,ADV),
    ADV:redrel => no,
    max_vp(XP),
    XP:e_deps => [],
    XP:vform => om, % otherwise adv normally is modifier of VP
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adv_rel_vp_dp,MAX,[ADV,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    XP => rel,
    XP:nform => norm,
    XP:relform => relform_inf,
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adj_vp_dp,MAX,[ADV,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => start,
    max_nadv_ap(ADV),
    max_vp(XP),
    XP:e_deps => [],
    XP:vform => om, % otherwise adv normally is modifier of VP
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adj_rel_vp_dp,MAX,[ADV,COMMA,XP]) :-
    optcomma(COMMA),
    MAX => start,
    max_nadv_ap(ADV),
    XP => rel,
    XP:nform => norm,
    XP:relform => relform_inf,
    dp_dp_structure(ADV,XP,MAX).

%% in Amsterdam , derhalve
%% volgens mij niet
%% maybe refuse ADV that are also TAG
grammar_rule(pp_adv_dp,MAX,[XP,COMMA,ADV]) :-
    optcomma(COMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_advp(ADV),
    ADV:subadv => ~subadv_adj,
    ADV:redrel => no,
    max_pp(XP),
    dp_dp_structure(XP,ADV,MAX).

%% desondanks , graag !
%% maybe refuse ADV that are also TAG
%% (but we know which TAGs are also ADVs,
%%  but not vice versa)
grammar_rule(adv_adv_dp,MAX,[XP,COMMA,ADV]) :-
    optcomma(COMMA),
    MAX => max,
    MAX:max_type => t_dp,
    max_advp(ADV),
    ADV:redrel => no,
    max_advp(XP), % refuse ADV that are ADJ, because these can use
                  % rule a_advp_dp
    XP:subadv => ~subadv_adj,
    XP:redrel => no,
    dp_dp_structure(XP,ADV,MAX).

%% tijdelijk voor ovis data?
%% van - naar -
grammar_rule(pp_pp_dp,MAX,[PP1,PP2]) :-
    MAX => start,
    max_pp(PP1),PP1:prep ==> van,
    max_pp(PP2),PP2:prep ==> naar,
    dp_dp_structure(PP1,PP2,MAX).

%% loc-np naar -
grammar_rule(loc_pp_dp,MAX,[NP1,PP2]) :-
    MAX => start,
    Subn => sub_name,
    short_np(NP1,Subn),
    NP1:neclass ==> 'LOC',
    max_pp(PP2),PP2:prep ==> naar,
    dp_dp_structure(NP1,PP2,MAX).

%% kortom, omdat ik je miste
%% heerlijk , als je je kleintje weer ziet
%% heerlijk he , als je je kleine weer ziet
%% maybe refuse ADV that are also TAG
grammar_rule(adv_mod_sbar_dp,MAX,[ADV,OPTCOMMA,XP]) :-
    optcomma(OPTCOMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_sbar(XP),
    XP:ctype => c_mod,
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adj_mod_sbar_dp,MAX,[ADJ,OPTCOMMA,XP]) :-
    optcomma(OPTCOMMA),
    MAX => start,
    max_nadv_ap(ADJ),
    max_sbar(XP),
    XP:ctype => c_mod,
    dp_dp_structure(ADJ,XP,MAX).

grammar_rule(adv_mod_tag_sbar_dp,MAX,[ADV0,TAG,OPTCOMMA,XP]) :-
    optcomma(OPTCOMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    TAG => tag,
    unify_except_dt(ADV0,ADV),
    nucl_tag_structure(ADV0,TAG,ADV),
    max_sbar(XP),
    XP:ctype => c_mod,
    dp_dp_structure(ADV,XP,MAX).

%% kortom, ik kom niet
%% maybe refuse ADV that are also TAG
grammar_rule(adv_root_dp,MAX,[ADV,COMMA,XP]) :-
    comma(COMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_root(XP),
    XP:needs_dip => no,
    dp_dp_structure(ADV,XP,MAX).

%% triest, ze doen het niet
%% hoe triest ook, we moeten door
%% maybe refuse ADV that are also TAG
grammar_rule(padv_root_dp,MAX,[ADV,COMMA,XP]) :-
    comma(COMMA),
    MAX => start,
    max_ap(ADV),
    predm_adj(ADV),
    max_root(XP),
    XP:needs_dip => no,
    dp_dp_structure(ADV,XP,MAX).

grammar_rule(adv_tag_root_dp,MAX,[ADV,OPTCOMMA,TAG,COMMA,XP]) :-
    comma(COMMA),
    optcomma(OPTCOMMA),
    MAX => start,
    max_advp(ADV),
    ADV:redrel => no,
    max_root(XP),
    XP:needs_dip => no,
    dp_tag_dp_structure(ADV,TAG,XP,MAX).

%% waarom deze vragen?
%% met welk doel zo'n onderzoek?
max_wh_xp_structure(WH,XP,MAX) :-
				%    MAX => start,
    MAX => max,
    MAX:max_type => t_dp,
    max_modifier(WH),
    WH:wh => ywh,
    WH:wh => yq,
    WH:redrel =?> no,
    WH:exs =?> [],
    WH:slash =?> [],
    unify_mods(WH),
    XP:sc =?> [],
    XP:slash =?> [],
    unify_mods(XP),
    XP:imexs =?> [],
    XP:tags =?> [],
    XP:wh =?> nwh,
    MAX:dt:stype => whquestion,
    xy_dep_nostype_structure(WH,XP,MAX,whq,whd,body).

grammar_rule(max_wh_adv_np,MAX,[ADV,XP]) :-
    max_np(XP),
    XP:subn => ~sub_indef_verb, %  & ~sub_det,  hoezo dat?
    max_wh_xp_structure(ADV,XP,MAX).

grammar_rule(max_wh_adv_mod_np,MAX,[ADV,MOD,XP]) :-
    max_np(XP),
    max_modifier(MOD),
    Tussen => max,
    Tussen:max_type => t_dp,
    dp_dp_structure(MOD,XP,Tussen),
    XP:subn => ~sub_indef_verb, %  & ~sub_det,  hoezo dat?
    max_wh_xp_structure(ADV,Tussen,MAX).

grammar_rule(max_wh_adv_ap,MAX,[ADV,XP]) :-
    max_nadv_ap(XP),
    XP:adv => nboth,
    max_wh_xp_structure(ADV,XP,MAX).

grammar_rule(max_wh_adv_pp,MAX,[ADV,XP]) :-
    max_pp(XP),
    XP:sel => ~to_topic,
    max_wh_xp_structure(ADV,XP,MAX).

short_np(NP1,SUBN) :-
    max_np(NP1),
    NP1:hdet => no,
    NP1:nform => norm,
    NP1:subn <=> SUBN,
    NP1:has_app => no,
    NP1:redrel => no,
    NP1:cj => ncj.

%% Staking Franse verkeersleiders
%% abbr of "NP van NP", "ben/heb NP NP"
%% Piet de kampioen
%% Ik een held ?
%% Ik een drankprobleem ?
%% Zoetemelk tweede
%% abbr of "NP is/heeft NP"
grammar_rule(np_np,START,[NP1,NP2]) :-
    START => max,
    START:max_type => t_dp,  % was missing here???
    START:mod_np => yes,
    SUBN1 => (sub_def_pron;sub_noun;sub_name),
    short_np(NP1,SUBN1),
    NP1:meas => no,
    SUBN2 => (sub_num;sub_name;sub_noun),
    short_np(NP20,SUBN2),
    unify_except(NP20,NP2,hdet),
    dp_dp_structure(NP1,NP2,START).

%% Provinciezetel te koop
%% inschrijven noodzakelijk
%% reserveren gewenst
grammar_rule(np_ap,START,[NP,AP]) :-
    START => max,
    START:max_type => t_dp,  % was missing here???
    START:mod_np => yes,
    SUBN => (sub_def_pron;sub_name;sub_noun;sub_indef_verb),
    short_np(NP,SUBN),
    max_nadv_ap(AP),
    dp_dp_structure(NP,AP,START).

%% Opbrengst parkeerautomaten verdubbeld

grammar_rule(np_np_ap,START,[NP1,NP2,AP]) :-
    START => start,
    SUBN1 => sub_noun,
    short_np(NP1,SUBN1),
    NP1:meas => no,
    SUBN2 => (sub_noun;sub_name),
    short_np(NP2,SUBN2),
    max_ap(AP), % no nadv because no competing rule
    dp_dp_structure(NP1,NP2,AP,START).

%%%% TV-programma START
%%%% HOW to ensure that START starts with capital
%grammar_rule(tv_start,MAX,[PN,START]) :-
%    MAX => start,
%    START => start,
%    max_np(PN),
%    PN:subn => sub_name,
%    PN:nform => norm,
%    dp_dp_structure(PN,START,MAX).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% HOE X-er HOE ..... %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% done:
%% [adv adv]             hoe langer hoe beter
%% [rel adv]             hoe langer je wacht, hoe beter
%% [rel rel]             hoe langer je wacht, hoe beter het is
%% [[adv np][adv np]]    hoe ouder de man, hoe jonger de vrouw
%% [[adv np] adv]        hoe ouder de man, hoe beter
%% [[adv np] rel]        hoe ouder de man, hoe beter het is
%% todo ellipsis:
%% [rel [adv np]]        hoe ouder de man is, hoe jonger zijn vrouw
%% [[adv pp][adv np]]    hoe later op de avond, hoe jonger de vrouw
%% [[adv pp] adv]        hoe later op de avond, hoe beter
%% [[adv pp] rel]        hoe later op de avond, hoe beter het is
%% [[adv np][adv pp]]    hoe jonger de vrouw, hoe later op de avond
%% [[adv pp][adv pp]]    hoe later op de avond hoe later op het werk
%% etc?

grammar_rule(hoe_hoe,M,[A,COMMA,B]) :-
    M => start,
    optcomma(COMMA),
    max_hoe_advp(A),
    max_hoe_advp(B),
    dp_dp_structure(A,B,M).

grammar_rule(hoe_short_hoe,M,[A,COMMA,B]) :-
    M => start,
    optcomma(COMMA),
    max_hoe_advp(A),
    short_max_hoe_advp(B),
    dp_dp_structure(A,B,M).

grammar_rule(short_hoe_short_hoe,M,[A,COMMA,B]) :-
    M0 => a,
    unify_except_l(M0,M,[wh_reltmploc,wh]),
    M:tmploc => ntmploc,
    M:adv => yadv,
    M:slash => [],
    M:sc => [],
    M:aform => nattr,
    M:wh => nwh,
    M:avform => avform_ap,
    optcomma(COMMA),
    short_max_hoe_advp(A),
    short_max_hoe_advp(B),
    dp_dp_structure(A,B,M0).

grammar_rule(hoe_np_hoe_np,M,[A0,B0,COMMA,A1,B1]) :-
    M => start,
    optcomma(COMMA),
    short_max_hoe_advp(A0),
    max_np(B0),
    short_max_hoe_advp(A1),
    max_np(B1),
    C0 => start,
    C1 => start,
    dp_dp_structure(A0,B0,C0),
    dp_dp_structure(A1,B1,C1),
    dp_dp_structure(C0,C1,M).

grammar_rule(hoe_np_short_hoe,M,[A0,B0,COMMA,C1]) :-
    M => start,
    optcomma(COMMA),
    short_max_hoe_advp(A0),
    max_np(B0),
    short_max_hoe_advp(C1),
    C0 => start,
    dp_dp_structure(A0,B0,C0),
    dp_dp_structure(C0,C1,M).

grammar_rule(hoe_np_hoe,M,[A0,B0,COMMA,C1]) :-
    M => start,
    optcomma(COMMA),
    short_max_hoe_advp(A0),
    max_np(B0),
    max_hoe_advp(C1),
    C0 => start,
    dp_dp_structure(A0,B0,C0),
    dp_dp_structure(C0,C1,M).

grammar_rule(hoe_hoe_np,M,[C1,COMMA,A0,B0]) :-
    M => start,
    optcomma(COMMA),
    short_max_hoe_advp(A0),
    max_np(B0),
    max_hoe_advp(C1),
    C0 => start,
    dp_dp_structure(A0,B0,C0),
    dp_dp_structure(C1,C0,M).

max_hoe_advp(X) :-
    max_advp(X0),
    unify_except_l(X0,X,[tmploc,wh_reltmploc]),
    X:tmploc => hoe_hoe,
    X:wh => nwh.

short_max_hoe_advp(X) :-
    max_advp(X0),
    unify_except(X0,X,wh_reltmploc),
    X:wh => ywh,
    X:wh => yq,
    X:wh_reltmploc => hoe_hoe.

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% TOP Categories %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

%% top_cat --> start (Punc)
grammar_rule(top_start, TOP, [ START, PUNCT ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    optend_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    hd_structure(START,TOP).

grammar_rule(top_start_g1,TOP,[START,PUNCT]) :-
    hdrug_util:hdrug_flag(parse_or_generate,generate),
    end_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    START:dt:stype => (declarative;topic_drop;imparative),
    hd_structure(START,TOP),
    Type => punt.
grammar_rule(top_start_g2,TOP,[START,PUNCT]) :-
    hdrug_util:hdrug_flag(parse_or_generate,generate),
    end_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    START:dt:stype => (ynquestion;whquestion),
    hd_structure(START,TOP),
    Type => vraag.

%% ze vroeg: En?
%% Want :
%% Met andere woorden :
grammar_rule(start_comp, TOP, [ COMP1, PUNCT ]) :-
    end_punct(PUNCT,Type),
    Type => (punt;uitroep;vraag;dubb_punt),
    TOP => start,
    COMP => comp,
    COMP:ctype => c_root,
    unify_except(COMP,COMP1,sc),
    hd_structure(COMP,TOP).

%% top_cat --> start Punc
%% Bla bla bla . ( FOTO ANP )
grammar_rule(top_start_anp, TOP, [ START, PUNCT, OPEN, START2, CLOSE, P2 ]):-
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    end_punct(PUNCT,Type),
    optend_punct(P2,Type2), Type2 => punt,
    TOP => top_cat,
    START => start,
    START2 => start,
    START:puncttype <=> Type,
    dp_dp_structure(START,START2,TOP).

grammar_rule(bracketed_top_start, TOP, [ OPEN, START, PUNCT, CLOSE ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optend_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    hd_structure(START,TOP).

grammar_rule(top_bracketed_start, TOP, [ OPEN, START, CLOSE, PUNCT ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    end_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    hd_structure(START,TOP).

grammar_rule(quoted_top_start, TOP, [ OPEN, START, PUNCT, CLOSE ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    ql(OPEN),
    qr(CLOSE),
    optend_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    hd_structure(START,TOP).

grammar_rule(top_quoted_start, TOP, [ OPEN, START, CLOSE, PUNCT ]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    ql(OPEN),
    qr(CLOSE),
    end_punct(PUNCT,Type),
    TOP => top_cat,
    START => start,
    START:puncttype <=> Type,
    hd_structure(START,TOP).

%% start --> Top_category
grammar_rule(top_start_xp, Start, [ Max ]):-
    Start => start,
    Max => max,
    Max:max_type => ~t_part,
    Max:puncttype <=> Start:puncttype,
    unify_mods(Max),
    hd_structure(Max,Start).

%% start --> Dip
%% Aldus bleek gisteren in Amsterdam
%% Zo verklaarde de officier
grammar_rule(top_start_root_dip, Start, [ Max ]):-
    Start => start,
    Max => root,
    Max:tags => [],
    Max:needs_dip => yes,
    unify_mods(Max),
    hd_structure(Max,Start).

%% Max --> Tag , Top_category
grammar_rule(top_adv_tag_start_xp, Start, [Tag,OPTCOMMA,Max]):-
    Tag => tag,
    Tag:adv => yes,
    Max:sv1 => no,
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;hellip),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

grammar_rule(top_tag_start_xp, Start, [Tag,OPTCOMMA,Max]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Tag => tag,
    Tag:adv => no,
    Tag:np => no,
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;hellip;punt),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

%% Allemachtig , moeten we dat allemaal doen?
grammar_rule(top_adv_tag_start_sv1, Start, [Tag,COMMA,Max]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Tag => tag,
    Tag:adv => yes,
    Tag:np => no,
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;hellip;punt),
    unify_mods(Tag),
    Max => max,
    Max:sv1 => yes,
    tag_max_structure(Max,Tag,Start).

grammar_rule(top_np_tag_start_xp, Start, [Tag,COMMA,Max]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Tag => tag,
    Tag:np => yes,
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;hellip),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

grammar_rule(top_tag_start_xp, Start, [Tag,COMMA,Max]):-
    hdrug_util:hdrug_flag(parse_or_generate,generate),
    Tag => tag,
    Tag:adv => no,
    comma(COMMA),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

%% ja/nou , en ?
grammar_rule(top_tag_start_en, Start, [Tag,OPTCOMMA,Conj]):-
    Tag => tag,
    Tag:adv => no,
    Tag:np => no,
    OPTCOMMA => optpunct,
    OPTCOMMA:cat <=> COMMA,
    COMMA => punct,
    COMMA:puncttype => (komma;dubb_punt;hellip),
    unify_mods(Tag),
    Start => max,
    Start:max_type => t_dp,
    Conj => conj,
    nucl_tag_structure(Conj,Tag,Start).

%% Max --> Top_category , Tag
grammar_rule(top_start_tag_xp, Start, [Max,COMMA,Tag]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Tag => tag,
    Tag:np => no,
    optend_punct(COMMA),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

grammar_rule(top_start_tag_np_xp, Start, [Max,COMMA,Tag]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Tag => tag,
    Tag:np => yes,
    COMMA => punct,
    COMMA:puncttype => (komma;hellip),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

	    
grammar_rule(top_start_tag_xp, Start, [Max,COMMA,Tag]):-
    hdrug_util:hdrug_flag(parse_or_generate,generate),
    Tag => tag,
    comma(COMMA),
    unify_mods(Tag),
    tag_max_structure(Max,Tag,Start).

tag_start_structure(Max,Tag,Start) :-
    Start => start,
    Max => max,
    Max:max_type => ~t_part,
    Max:puncttype <=> Start:puncttype,
    unify_mods(Max),
    nucl_tag_structure(Max,Tag,Start).

/*
% Linda , leuk dat je komt
grammar_rule(top_np_tag_start_xp(root), Start, [Tag,COMMA,Max]):-
    max_pers_pn(Tag),
    COMMA => punct,
    COMMA:puncttype => (komma;hellip;uitroep;punt),
    tag_start_structure(Max,Tag,Start).

% Mijnheer Kok, leuk dat je er bent
grammar_rule(top_rnp_tag_start_xp(root), Start, [Tag,COMMA,Max]):-
    max_np(Tag),
    Tag:hstem <=> HSTEM,
    alpino_wappend:wwmember(HSTEM,[mijnheer,meneer,mevrouw,heer,dame,jongen,meisje]),
    COMMA => punct,
    COMMA:puncttype => (komma;hellip;uitroep;punt),
    tag_start_structure(Max,Tag,Start).
*/

% Hallo Linda , leuk dat je komt
grammar_rule(top_tag_np_tag_start_xp(root), Start, [Tag,PN,COMMA,Max]):-
    PN => tag,
    PN:np => yes,
    Tag => tag,
    Mid => start,
    nucl_tag_structure(PN,Tag,Mid),
    COMMA => punct,
    COMMA:puncttype => (komma;hellip;uitroep;punt),
    tag_start_structure(Max,Mid,Start).

grammar_rule(tag_np,Tag,[NP]) :-
    NP => np,
    NP:nform => norm,
    NP:redrel => no,
    NP:wh => nwh,
    NP:subn => sub_noun,
    Tag => tag,
    Tag:np => yes,
    Tag:adv => no,
    NP:hstem <=> HSTEM,
    alpino_wappend:wwmember(HSTEM,[mijnheer,meneer,mevrouw,heer,dame,jongen,meisje,
				   professor,sire,buurman,buurvrouw,man]),
    hd_structure(NP,Tag).

grammar_rule(tag_pn,Tag,[NP]) :-
    NP => pn,
    NP:neclass => 'PER',
    Tag => tag,
    Tag:np => yes,
    Tag:adv => no,
    hd_structure(NP,Tag).

tag_start_sent_structure(Max,Tag,Start,COMMA) :-
    Start => start,
    COMMA => punct,
    COMMA:puncttype => (komma;hellip;uitroep;punt),
    nucl_tag_structure(Max,Tag,Start).

%% Geloof me nou , het is niet leuk
grammar_rule(top_imp_tag_start_xp, Start, [Tag,COMMA,Max]):-
    max_imp(Tag),
    comma_hellip(COMMA),
    tag_start_structure(Max,Tag,Start).

/*
grammar_rule(top_start_tag_np_xp(root), Start, [Max,COMMA,Tag]):-
    max_pers_pn(Tag),
    COMMA => punct,
    COMMA:puncttype => (komma;hellip),
    tag_start_structure(Max,Tag,Start).

grammar_rule(top_start_tag_rnp_xp(root), Start, [Max,COMMA,Tag]):-
    max_np(Tag),
    Tag:hstem <=> HSTEM,
    alpino_wappend:wwmember(HSTEM,[mijnheer,meneer,mevrouw,heer,dame,jongen,meisje]),
    COMMA => punct,
    COMMA:puncttype => (komma;hellip),
    tag_start_structure(Max,Tag,Start).
*/

grammar_rule(top_start_tag_np_xp_tag, Start, [Max,COMMA,Tag,PnTag]):-
    Tag => tag,
    Start => start,
    comma(COMMA),
    PnTag => tag,
    PnTag:np => yes,
    PnTag2 => tag,
    Max => max,
    Max:max_type => ~t_part,
    nucl_tag_structure(PnTag,Tag,PnTag2),
    nucl_tag_structure(Max,PnTag2,Start).

%% dat is onzin, geloof me
%% dat vind ik vervelend, noem het angst
%%            , begrijp me goed
%%            , laat me niet lachen
%%            , neem dat van mij aan
grammar_rule(top_start_tag_root_imp, Start, [Max,COMMA,Tag]):-
    max_imp(Tag),
    max_root(Max),
    Max:needs_dip => no,
    tag_start_sent_structure(Max,Tag,Start,COMMA).

%% De « King of Pop » , zie Michael Jackson
%% De « King of Pop » , laat me niet lachen
grammar_rule(top_start_tag_np_imp, Start, [NP,COMMA,Tag]):-
    max_imp(Tag),
    max_np(NP),
    NP:subn => ~sub_det,
    comma(COMMA),
    Start => start,
    nucl_tag_structure(NP,Tag,Start).

tag_max_structure(Max,Tag,Start) :-
    Start => max,
    Start:max_type => t_dp,
    Max => max,
    Max:max_type => ~t_part,
    Max:puncttype <=> Start:puncttype,
    unify_mods(Max),
    nucl_tag_structure(Max,Tag,Start).

%% max --> Tag
grammar_rule(top_start_tag, Start, [Tag]):-
    Tag => tag,
    Tag:adv => no,
    Tag:np => no,
    top_max_structure(Tag,Start).

%% max --> Etc
grammar_rule(top_start_etc, Start, [Tag]):-
    Tag => etc,
    top_max_structure(Tag,Start).

top_max_structure(XP,Max) :-
    Max => max,
    Max:max_type => t_xp,
%    unify_mods(XP),
    XP:sc =?> [],
    XP:slash =?> [],
    XP:iexs =?> [],
    XP:imexs =?> [],
    XP:tags =?> [],
    XP:haswh =?> no,
    XP:cj <?=?> Max:cj,
    hd_structure(XP,Max).

%% start --> np en/want smain
xp_en_root_structure(Start,NP,CRD,ROOT) :-
    Start => start,
    CRD => conj,
    CRD:cform <=> CFORM,
    dif(CFORM,om),
    non_hd_structure([NP,CRD,ROOT],Start,conj),
    CRD:dt <=> CRDDT,
    NP:dt <=> NPDT,
    ROOT:dt <=> ROOTDT,
    initialize_dt([crd,cnj],Start),
    Start:dt => dt,
    Start:dt:hwrd => [],
    Start:dt:crd <=> [CRDDT],
    Start:dt:cnj <=> [NPDT,ROOTDT].    

grammar_rule(xp_en_root,Start,[XP,OPTCOMMA,CRD,ROOT]) :-
    optcomma_end(OPTCOMMA),
    XP => max,
    XP:max_type => (t_xp;t_dp),
    ROOT => max,
    ROOT:max_type => (t_dp;t_root),
    xp_en_root_structure(Start,XP,CRD,ROOT).

grammar_rule(xp_ques,Start,[XP,COMMA,QUES]) :-
    comma(COMMA),
    XP => max,
    XP:max_type => (t_xp;t_dp),
    max_sv1(QUES),
    Start => max,
    Start:max_type => t_dp,
    nucl_sat_structure(QUES,XP,Start).

%% leuk idee , maar werkt het ook ?
grammar_rule(xp_en_ques,Start,[XP,OPTCOMMA,CRD,ROOT]) :-
    optcomma_end(OPTCOMMA),
    XP => max,
    XP:cj => ncj,
    XP:max_type => (t_xp;t_dp),
    max_sv1(ROOT),
    xp_en_root_structure(Start,XP,CRD,ROOT).

grammar_rule(root_en_dp,Start,[XP,OPTCOMMA,CRD,ROOT]) :-
    optcomma(OPTCOMMA),
    XP => max,
    XP:max_type => t_root,
    XP:cj => ncj,
    ROOT => max,
    ROOT:max_type => t_dp,
    xp_en_root_structure(Start,XP,CRD,ROOT).

grammar_rule(max_xp(np),Max,[X]) :-
    max_np(X),
    X:subn => ~sub_indef_adj,
    top_max_structure(X,Max).

grammar_rule(max_xp(adj),Max,[X]) :-
    max_ap(X),
    X:adv => oadv,
    top_max_structure(X,Max).

grammar_rule(max_xp(sv1),Max,[X]) :-
    max_sv1(X),
    top_max_structure(X,Max),
    Max:dt:stype => ~declarative & ~topic_drop & ~whquestion,
    Max:sv1 => yes,
    Max:puncttype => (punt;uitroep;dubb_punt;punt_komma;vraag;hellip).

grammar_rule(max_xp(dip_sv1),Max,[X0]) :-
    X0 => sv1, X => sv1,
    X0:can_be_max => yes,
    dip_scope_structure(X0,X),
    Max:puncttype => (punt;uitroep;dubb_punt;punt_komma;vraag;hellip),
    top_max_structure(X,Max).

grammar_rule(max_xp(imp),Max,[X]) :-
    max_imp(X),
    top_max_structure(X,Max),
    Max:puncttype => (punt;uitroep;dubb_punt;punt_komma;hellip;vraag).

grammar_rule(max_xp(root),Max,[X]) :-
    max_root(X),
    top_max_structure(X,Max0),
    overwrite(Max0,Max,max_type,t_root),
    Max:puncttype <=> X:puncttype,
    X:needs_dip => no,
    Max:max_type => t_root.  % reduce spurious amb for 'root want root'

grammar_rule(max_xp(rootbar),Max,[X]) :-
    X => rootbar,
    top_max_structure(X,Max0),
    overwrite(Max0,Max,max_type,t_rootbar),
    Max:max_type => t_rootbar.

grammar_rule(max_xp(sbar),Max,[X]) :-
    max_sbar(X),
    X:ctype => ~c_alsof,
    top_max_structure(X,Max).

grammar_rule(max_xp(advp),Max,[X]) :-
    max_advp(X),
    X:subadv => ~subadv_adj,
    top_max_structure(X,Max).

%% ongelooflijk , maar waar
%% verlegen en bescheiden
grammar_rule(max_xp(pred),Max,[X]) :-
    max_pred(X),
    X:pcat => ap_pred,
    top_max_structure(X,Max).

grammar_rule(max_xp(pp),Max,[X]) :-
    max_pp(X),
    X:sel => ~to_topic,
    top_max_structure(X,Max).

grammar_rule(max_xp(post_pp),Max,[X]) :-
    X => post_pp,
    max(X),
    top_max_structure(X,Max).

%% geen mens te zien
grammar_rule(max_xp(vp),Max,[X]) :-
    X => vp,
    X:vform => (pass_te;om;inf;psp),
    X:e_deps => [],
    %% to prevent clefts etc:
    X:cleft => no,
    X:subj => np,
    X:subj:nform => (norm;het_nform),
    X:subj:subn => sub_noun,
    X:subj:allows_drop => yes,
    X:subj:dt => [],    
    %%
    X:haswh => no,
    top_max_structure(X,Max).

%% Te bestellen bij ..
%% Nog te zien tot ..
%% now subsumed by max_xp(pred)
%grammar_rule(max_xp(pass_te_vp),Max,[X]) :-
%    X => a,
%    X:deverbal => yes,
%    X:avform => avform_ti,
%    X:e_deps => [],
%    top_max_structure(X,Max).

%% om gek van te worden
%% die ik al heel lang ken
grammar_rule(max_xp(om_rel),Max,[X]) :-
%    hdrug_util:hdrug_flag(parse_or_generate,PG),
    X => rel,
    X:relform => ~relform_np,
%    (   PG == parse
%    ;   PG == generate,
%	X:relform => ~relform_inf
%    ),
    X:nform => norm,
    top_max_structure(X,Max).

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% RELATIVE CLAUSES %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%% TODO: integrate sbar and rel structures?
%%
%% relatives:
%% - reduced --> cat=sbar, ctype=redrel
%% -- function as np
%% -- function as sbar, ctype=arg
%% - non-reduced

sub_wh_principle(Rel,Pro,VP,RelHdTarget) :-
    VP:vform =?> fin,
    VP:subj =?> np,
    VP:subj:prs =?> ~invje,
    Pro:wh:relagr <=> Rel:agr,   % wie er lacht is af
                             % wie er hun lachen niet inhouden moeten weg
    Pro:wh_reltmploc <=> Rel:tmploc,
                            % overal waar, altijd wanneer
    Pro:wh:relhstem <?=?> Rel:hstem,
    initialize_dt([rhd,whd,body],Rel),
    RelHdTarget <=> Pro:dt,
    Rel:dt => dt,
    Rel:dt:hwrd => [],
    Rel:dt:cat <=> Rel:ccat,
    Rel:dt:body <=> VP:dt.

%% mysterious ambiguity because reduced relative np can be np inside
%% of pp too:
%% * mannen van wiens vrouwen ik liefheb verdwijnen nooit
%%
%% ok: ik ben vertrokken met wat ik bij me had
%%     ik heb je gezien van waar de beek stroomt
%%     ik besteel wiens deuren geopend zijn

%% ik hoorde wie de trein had gemist
%% I heard who missed the train
%%
%%   2 readings: 'I heard the man that missed the train'
%%               'I heard who it was that missed the train'
%%     np / sbar

%% np --> redrel
%% for reduced relatives
grammar_rule(np_red_rel,NP,[SBAR]) :-
    np_red_rel_structure(NP,SBAR),
    SBAR:e_deps => [].

%% wat ik wil is dat hij komt
grammar_rule(np_red_rel_edep_sbar,NP,[SBAR]) :-
    np_red_rel_structure(NP0,SBAR),
    SBAR:e_deps => [],
    unify_except(NP0,NP,e_deps),
    NP:e_deps <=> [VP],
    VP => sbar,
    VP:slash => [],
    VP:e_deps => [],
    VP:ctype => (c_of;c_of_short;c_redrel;c_dat;c_dip).

%% waar ik van houd is om te klieren
grammar_rule(np_red_rel_edep_vp,NP,[SBAR]) :-
    np_red_rel_structure(NP0,SBAR),
    SBAR:e_deps => [],
    unify_except(NP0,NP,e_deps),
    NP:e_deps <=> [VP],
    %% cf lex_types.gram no_subj_vp_arg definition
    VP => vp,
    VP:e_deps => [],
    VP:slash => [],
    %% forbid clefts in contexts where subj is ignored:
    VP:cleft => no,
    VP:subj => np,
    VP:subj:hstem => [],
    VP:subj:nform => norm,
    VP:subj:agr => sg,
    VP:subj:prs => thi,
    VP:subj:subn => sub_noun.

np_red_rel_structure(NP,SBAR) :-
    SBAR => redrel,
    SBAR:sub_wh => ywh,
    SBAR:sub_wh => nq,
%    SBAR:sub_wh:rlex => yes,
    SBAR:haswh => nwh,
    NP => np,
    NP:nform => norm,
    NP:redrel => yes,
    NP:wh => nwh,
    NP:case => ~gen,
    SBAR:tmploc => (str_er;non_adv),    %% disallow adverbials!
    NP:agr <=> SBAR:agr,
    unify_except(NP0,NP,redrel),
    hd_structure(SBAR,NP0,whrel),
    SBAR:dt:whd => [],
    SBAR:dt:rhd <=> SBAR:relhd.

%% adv --> redrel
grammar_rule(adv_red_rel,ADV,[SBAR]) :-
    SBAR => redrel,
    SBAR:e_deps => [],
    SBAR:sub_wh => ywh,
    SBAR:sub_wh => iq,  % ??
                        % not nq because of hoe ... hoe stuff
    SBAR:haswh => nwh,
    ADV => adv,
    ADV:redrel => yes,
    ADV:tmploc => ~non_adv & ~wk_er & ~postp,
    ADV:tmploc <=> SBAR:tmploc,
    unify_except(ADV0,ADV,redrel),
    hd_structure(SBAR,ADV0,whrel),
    SBAR:dt:whd => [],
    SBAR:dt:rhd <=> SBAR:relhd.

%% sbar --> redrel
grammar_rule(sbar_red_rel,SBAR,[REL]) :-
    SBAR => sbar,
    REL => redrel,
    SBAR:ctype => c_redrel,
    SBAR:slash => [],
    SBAR:tags => [],
    SBAR:wh => nwh,
    REL:relhd <=> REL:dt:whd,
    REL:dt:rhd => [],
    REL:tmploc => ~hoe_hoe & ~wk_er & ~postp,
    REL:e_deps => [],
    REL:sub_wh => iq,
    hd_structure(REL,SBAR,whsub).

%% redrel --> WH-ARG vp
wh_sbar_arg_struct_vp(Wh,VP,SBAR) :-
    VP0 => vp,
    %% forbid clefts:
%    VP0:cleft => no,  % NO: ik vroeg wie het waren
    wh_sbar_arg_structure(Wh,VP0,SBAR),
    unify_except(VP0,VP,ccat),
    VP:ccat0 <=> VP:ccat.

wh_sbar_arg_struct_cp(Wh,CP,SBAR) :-
    CP => sbar,
    CP:ctype => (c_of;c_of_short;c_dat),
    SBAR:sub_wh => iq,   % is this OK???
    wh_sbar_arg_structure(Wh,CP,SBAR).

wh_sbar_arg_structure(Wh,ARG,SBAR) :-
    SBAR => redrel, 
    Wh:wh => ywh,
    Wh:redrel =?> no,
    Wh:exs =?> [],
    SBAR:sub_wh <=> Wh:wh,
    SBAR:relhd <=> SBARRELHD,
    sub_wh_principle(SBAR,Wh,ARG,SBARRELHD),
    non_projected_hd_filler_structure(ARG,Wh,SBAR,whrel).

grammar_rule(wh_sbar_arg(np), SBAR, [Wh, VP]) :-
    Wh => np,
    wh_sbar_arg_struct_vp(Wh,VP,SBAR).

grammar_rule(wh_sbar_arg(adv), SBAR, [Wh, VP]) :-
    Wh => adv,
    SBAR:sub_wh:rlex => no,
    wh_sbar_arg_struct_vp(Wh,VP,SBAR).

grammar_rule(wh_sbar_arg(pp), SBAR, [Wh, VP]) :-
    Wh => pp,
    SBAR:sub_wh:rlex => no,
    wh_sbar_arg_struct_vp(Wh,VP,SBAR).

grammar_rule(wh_sbar_arg(pred), SBAR, [Wh, VP]) :-
    Wh => pred,
    wh_sbar_arg_struct_vp(Wh,VP,SBAR).

grammar_rule(wh_sbar_mod(pp), SBAR, [Wh, VP]) :-
    Wh => modifier,
    Wh:mcat => (mcat_pp;mcat_adv),
    SBAR:sub_wh:rlex => no,
    wh_sbar_arg_struct_vp(Wh,VP,SBAR).

%% Hoe te handelen?
grammar_rule(wh_sbar_mod_inf(pp), SBAR, [Wh, VP]) :-
    Wh => modifier,
    wh_sbar_arg_struct_vp(Wh,VP0,SBAR),
    Wh:mcat => (mcat_pp;mcat_adv),
    unify_except(VP0,VP,vform),
    VP:vform => te,
    SBAR:sub_wh => yq.

%% Wat te doen?
grammar_rule(wh_sbar_arg_inf(np), SBAR, [Wh, VP]) :-
    Wh => np,
    wh_sbar_arg_struct_vp(Wh,VP0,SBAR),
    unify_except(VP0,VP,vform),
    VP:vform => te,
    SBAR:sub_wh => yq.

%% hij vroeg wie dat ik tegenkwam
grammar_rule(wh_sbar_arg_m(np), SBAR, [Wh, VP]) :-
    Wh => np,
    wh_sbar_arg_struct_cp(Wh,VP,SBAR).

%% hij vroeg waar dat ik woonde
grammar_rule(wh_sbar_arg_m(adv), SBAR, [Wh, VP]) :-
    Wh => adv,
    wh_sbar_arg_struct_cp(Wh,VP,SBAR).

%% hij vroeg met wie dat ik zou komen
grammar_rule(wh_sbar_arg_m(pp), SBAR, [Wh, VP]) :-
    Wh => pp,
    wh_sbar_arg_struct_cp(Wh,VP,SBAR).

%% hij vroeg hoe dat ik hem vond
grammar_rule(wh_sbar_arg_m(pred), SBAR, [Wh, VP]) :-
    Wh => pred,
    wh_sbar_arg_struct_cp(Wh,VP,SBAR).

%% hij vroeg waarom dat ik sliep
grammar_rule(wh_sbar_arg_m(modifier_pp), SBAR, [Wh, VP]) :-
    Wh => modifier,
    Wh:mcat => (mcat_pp;mcat_adv),
    wh_sbar_arg_struct_cp(Wh,VP,SBAR).

grammar_rule(short_wh_sbar(pp),SBAR,[Wh]) :-
    Wh => pp,
    Wh:slash => [],
    Wh:e_deps => [],
    Wh:nnform => ~refl,
    Wh:ld_pc => mod_pp,
    Wh:pp_role => pp_obj1,
    Wh:ccat0 <=> SBAR:ccat0,
    short_wh_sbar_structure(Wh,SBAR).

grammar_rule(short_wh_sbar(advp),SBAR,[Wh]) :-
    Wh => adv,
    Wh:exs => [],
    Wh:ccat0 <=> SBAR:ccat0,
    short_wh_sbar_structure(Wh,SBAR).

grammar_rule(short_wh_sbar(np),SBAR,[NP]) :-
    NP => np,
    NP:e_deps => [],
    NP:pred => npred,
    NP:nform => norm,
    NP:case => (dat;acc),
    NP:ccat0 <=> SBAR:ccat0,
    short_wh_sbar_structure(NP,SBAR).

grammar_rule(short_wh_sbar(np_mod),SBAR,[NP,MOD]) :-
    NP => np,
    NP:e_deps => [],
    NP:pred => npred,
    NP:nform => norm,
    NP:case => (dat;acc),
    short_wh_mod_sbar_structure(SBAR,NP,MOD).

grammar_rule(short_wh_sbar(advp_mod),SBAR,[Wh,MOD]) :-
    Wh => adv,
    Wh:exs => [],
    short_wh_mod_sbar_structure(SBAR,Wh,MOD).

grammar_rule(short_wh_sbar(pp_mod),SBAR,[Wh,MOD]) :-
    Wh => pp,
    Wh:slash => [],
    Wh:e_deps => [],
    Wh:nnform => ~refl,
    Wh:ld_pc => mod_pp,
    Wh:pp_role => pp_obj1,
    short_wh_mod_sbar_structure(SBAR,Wh,MOD).

short_wh_mod_sbar_structure(SBAR,NP,MOD) :-
    max_advp(MOD),  % wie wel
    MOD:wh => nwh,
    unify_mods(MOD),
    finish_mexs(MOD),
    NP:wh => ywh,
    NP:wh => yq,
    NP:wh_reltmploc => ~hoe_hoe & ~str_er & ~wk_er & ~postp,
    unify_mods(NP),
    SBAR => sbar,
    SBAR:ctype => c_of_short,
    SBAR:tags => [],
    SBAR:slash => [],
    SBAR:dt:stype => whquestion,
    xy_dep_nostype_structure(NP,MOD,SBAR,whsub,whd,body).

short_wh_sbar_structure(Wh,SBAR) :-
    SBAR0 => sbar,
    SBAR => sbar,
    unify_except(SBAR0,SBAR,wh), % ignore WH for coordinations
    Wh:wh => ywh,
    Wh:wh => yq,
    Wh:wh_reltmploc => ~hoe_hoe & ~str_er & ~wk_er & ~postp,
    SBAR:ctype => c_of_short,
    SBAR:tags => [],
    SBAR:slash => [],
    SBAR:dt:stype => whquestion,
    hd_structure(Wh,SBAR0,_).

%%% wat als
grammar_rule(wat_als,Max,[Wat,Als]) :-
    max_sbar(Wat),
    Wat:ctype => c_of_short,
    max_sbar(Als),
    Als:ctype => c_mod,
    Max => max,
    Max:max_type => t_dp,
    dp_dp_structure(Wat,Als,Max).    

%% rel --> REL-ARG vp
rel_arg_structure(Pro,VP,Rel) :-
    Rel => rel, Rel0=> rel, VP0 => vp,
    VP0:e_deps => [],
    Rel:relform => relform_fin,
    unify_except(VP0,VP,ccat),
    Pro:wh => rwh,
    Pro:exs =?> [],
    Rel:agr <=> Pro:wh:relagr,
    Rel:hstem <=> Pro:wh:relhstem,
    Rel:dt:rhd <=> Target,
    Rel:dt:whd => [],
%    Rel:ccat0 ==> rel,
    sub_wh_principle(Rel,Pro,VP0,Target),
    non_projected_hd_filler_structure(VP0,Pro,Rel0,rel),
    VP:haswh => nwh,
    VP:ccat0 <=> VP:ccat,
    unify_except(Rel0,Rel,hstem).

grammar_rule(rel_arg(np), Rel, [Pro, VP]) :-
    rel_arg_np_structure(Rel,Pro,VP).

rel_arg_np_structure(Rel,Pro,VP) :-
    Pro => np,
    rel_arg_structure(Pro,VP,Rel).

%% if the np is temporal, relative is not possible, but
%% special "dat-clause" is used (?):
%% ik heb heimwee naar de jaren *die/dat ik in Assen woonde
grammar_rule(rel_arg(meas_mod_np), Rel, [Pro, VP]) :-
    rel_arg_np_structure(Rel,Pro,VP0),
    Pro:wh_reltmploc => non_adv,
    Pro:nform => norm,
    Pro:exs => [],
    Pro:e_deps => [],
    unify_mods(Pro),
    unify_except(VP0,VP,slash),
    VP:slash <=> [ADV],
    Rel:nform => meas_mod,
    ADV => modifier,
    ADV:dt <=> Pro:dt.

grammar_rule(rel_arg(adv), Rel, [Pro, VP]) :-
    Pro => adv,
    rel_arg_structure(Pro,VP,Rel).

grammar_rule(rel_arg(pp), Rel, [Pro, VP]) :-
    Pro => pp,
    rel_arg_structure(Pro,VP,Rel).

grammar_rule(rel_arg(pred), Rel, [Pro, VP]) :-
    Pro => pred,
    rel_arg_structure(Pro,VP,Rel).

grammar_rule(rel_mod(pp),Rel,[Pro, VP]) :-
    Pro => modifier,
    Pro:mcat => (mcat_adv;mcat_pp),
    rel_arg_structure(Pro,VP,Rel).


%% twaalf mensen (raakten gewond),
%% waaronder de voorzitter
%% van wie drie met brandwonden
%% van wie drie ernstig
%% van wie drie in Amsterdam en vier in Rotterdam
%%
%% not yet:
%% zes medailles , waarvan drie gouden

%grammar_rule(rel_pp_np, Rel, [PP, NP]) :-
%    rel_pp_np_structure(Rel,PP,NP).

grammar_rule(rel_pp_dp, Rel, [PP, DP]) :-
    structure,
    DP => max,
    DP:max_type => (t_part;t_dp;t_xp),
    Rel => rel, PP => pp,
    Rel:relform => relform_np,
    finish_mexs(PP),
    unify_mods(PP),
    PP:wh => rwh,
    PP:pp_role => pp_obj1,
    Rel:agr <=> PP:wh:relagr,
    Rel:hstem <=> PP:wh:relhstem,
    Rel:tmploc <=> PP:wh_reltmploc,
    xy_dep_dt(DP,PP,Rel,body,rhd),
    non_hd_dt_principle(Rel,rel),
    unify_mods(DP),
    PP:exs => [],
    PP:slash => [],
    PP:e_deps => [],
    PP:pp_role => pp_obj1.

%%%%%%%%%%%%%%%%%
%%%% NUMBERS %%%%
%%%%%%%%%%%%%%%%%

%% for use in
%%%% partitives
%%%% standalone with quantitative-er
grammar_rule(n_num,N1,[Num]) :-
    N => n,
    N:nform => norm,
    N:subn => sub_num,
    Num => num,
    Num:pro => yes, % since één is a pronoun too anyway...
    Num:cj => ncj,
    unify_except(N,N1,e_agr),   % daar is 50 toegestaan
				% de drie op haar rapport wordt ...
                                % hack, werkt niet goed in paraphrasing
    hd_structure(Num,N,np).

%% CGN: must be determiner
%% zes meter
%% drie boeken
grammar_rule(n_num_n, NP, [ Num, N ] ) :-
    n_num_n_structure(NP,Num,N).

grammar_rule(n_bracketed_num_n, NP, [ OPEN, Num, OPTPUNCT,CLOSE, N ] ) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    n_num_n_structure(NP,Num,N).

n_num_n_structure(N1,Num,N0) :-
    N1 => n, Num => num, N0 => n,
    unify_except(N1,N,bmeas),
    Num:agr <=> N:agr,
    N0:haspre => yes,
    N0:subn => ~sub_def_verb & ~sub_indef_verb,
    hd_det_structure(Num,N0,N).

%% 'bijna 6 flessen'
grammar_rule(num_adv_num, Num1, [Adv,Num]):-
    Num1 => num, Adv => adv, Num => num,
    Adv:tmploc => (sent;ntmploc),
    Adv:wh => nwh,
    Num:app => yes,
    hd_mod_structure(Num,Adv,Num1).

grammar_rule(num_bracketed_adv_num, Num1, [Left,Adv,Right,Num]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Left => punct, Left:puncttype => haak_open,
    Right => punct, Right:puncttype => haak_sluit,
    Num1 => num, Adv => adv, Num => num,
    Adv:tmploc => (sent;ntmploc),
    Adv:wh => nwh,
    Num:app => yes,
    hd_mod_structure(Num,Adv,Num1).

grammar_rule(num_cp_num, Num1, [SBAR,Num]):-
    Num1 => num, SBAR => sbar, Num => num,
    SBAR => sbar,
    SBAR:wh => nwh,
    SBAR:tags => [],
    SBAR:slash => [],
    SBAR:ctype => c_adv,
    Num:app => yes,
    hd_mod_structure(Num,SBAR,Num1).

grammar_rule(num_num_adv_num, Num1, [Adv,Num]):-
    Num1 => num, Adv => pre_num_adv, Num => num,
    Num:app => yes,
    Num1:agr <=> Adv:agr,
    hd_mod_structure(Num,Adv,Num1).

grammar_rule(det_adv_det, DetP, [Adv,Det]):-
    det_adv_det_structure(DetP,Adv,Det).

grammar_rule(det_bracketed_adv_det, DetP, [Left,Adv,Right,Det]):-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    Left => punct, Left:puncttype => haak_open,
    Right => punct, Right:puncttype => haak_sluit,
    det_adv_det_structure(DetP,Adv,Det).

det_adv_det_structure(DetP,Adv,Det) :-
    
    DetP => det, Adv => adv, DetP0 => det, Det => det,
    Det:modf => yes,
    Adv:tmploc => (sent;ntmploc),
    unify_except_l(DetP0,DetP,[wh_reltmploc,wh,wkpro]),
			       % for: "hoe weinig"
                               % for: "heel wat heb ik er..."
    DetP:wh <=> Adv:wh,
    DetP:wh_reltmploc <=> Adv:wh_reltmploc,
    DetP:wkpro => strongpro,    % if unspecified, spur amb np_pron(_weak) rule
                                % for: 'omdat er heel wat zullen zijn, die ...
    Det:subn => ~sub_veel, % diy: should be combined with adj[veel]
    hd_mod_structure(Det,Adv,DetP0).

%% al de aanwezigen
grammar_rule(det_quant_det,DetP, [Adv,Det]):-
    DetP => det, Adv => pre_det_quant, Det => det,
    Det:agr <=> Adv:agr,
    hd_mod_structure(Det,Adv,DetP).

grammar_rule(num_num_haak, NUMP, [ NUM, Cl, MOD, OptQm, Cr ]) :-
    NUM => num, NUMP => num,
    Cl => punct, Cr => punct,
    Cl:puncttype => haak_open, Cr:puncttype => haak_sluit,
    optend_mod_punct(OptQm),
    MOD => start,
    hd_mod_structure(NUM,MOD,NUMP).

%%%%%%%%%%%%%%%%%%%%%%
%%%% COORDINATION %%%%
%%%%%%%%%%%%%%%%%%%%%%

%% hacking for advancend hackers
%% but SICStus says:
%% ! Representation error
%% ! compiled representation of clause has more than 256 permanent variables
%% TODO: break this down in three rules
%% np     --> detadj en detadjn
%% detadj --> det adj
%% detadjn--> det adj n

/*
%% "de belijdende of de volwassen leden"
%% "een anoniem of een publiek bestaan"
%% "de gele of de rode bal"
grammar_rule(det_adj_crd_det_adj_n,NP,[Det1,Adj1,En,Det2,Adj2,N2]) :-
    np_det_n_structure(Conj1,Det1,NP1),
    np_det_n_structure(Conj2,Det2,NP2),
    unmarked_n_adj_n_structure(N2,Adj1,NP1),
    unmarked_n_adj_n_structure(N1,Adj2,NP2),

    unify_except_l(N1,N2,[dt:det,dt:mod,dt:ix,cmods,mods,cdets,dets]),
    N1:cmods => [],
    N1:mods <=> N1:dt:mod,
    N1:cdets => [],
    N1:dets <=> N1:dt:det,
    
    En => conj,
    NP0 => np,
    NP  => np,

    H => no_cat,
    assign_new_cat(NP0,conj),

    structure(H,[],[],[],[],[],[],[Conj1,En,Conj2],[],[],[],NP0),
    unify_mods(En),

    Conj1:cmods <=> Cmods,
    NP0:mods <=> Mmods,
    Conj1:mods <=> Lmods,
    alpino_wappend:wappend(Cmods,Mmods,Lmods),
    Conj2:cmods <=> Cmods2,
    Conj2:mods <=> Lmods2,
    alpino_wappend:wappend(Cmods2,Mmods,Lmods2),

    Conj1:cdets <=> Cdets,
    NP0:dets <=> Mdets,
    Conj1:dets <=> Ldets,
    alpino_wappend:wappend(Cdets,Mdets,Ldets),
    Conj2:cdets <=> Cdets2,
    Conj2:dets <=> Ldets2,
    alpino_wappend:wappend(Cdets2,Mdets,Ldets2),

    Conj1:cpredms <=> Cpredms,
    NP0:predms <=> Mpredms,
    Conj1:predms <=> Lpredms,
    alpino_wappend:wappend(Cpredms,Mpredms,Lpredms),
    Conj2:cpredms <=> Cpredms2,
    Conj2:predms <=> Lpredms2,
    alpino_wappend:wappend(Cpredms2,Mpredms,Lpredms2),

    Conj1:capps <=> Capps,
    NP0:apps <=> Mapps,
    Conj1:apps <=> Lapps,
    alpino_wappend:wappend(Capps,Mapps,Lapps),
    Conj2:capps <=> Capps2,
    Conj2:apps <=> Lapps2,
    alpino_wappend:wappend(Capps2,Mapps,Lapps2),

    Conj1:ccat0  <=> Conj1:ccat,
    Conj2:ccat0  <=> Conj2:ccat,
    
    coord_daughter_paths(NP,Conj1),
    coord_daughter_paths(NP,Conj2),
    unify_paths([subn,hstem,meas,wh_reltmploc,sel,neclass],NP,Conj2),
    finish_mexs(NP0),
    overwrite(NP0,NP,mexs,[]),

    En:dt <=> EnDt,
    Conj1:dt <=> Conj1Dt,
    Conj2:dt <=> Conj2Dt,
    NP:dt => dt,
    NP:dt:crd <=> [EnDt],
    NP:dt:cnj <=> [Conj1Dt,Conj2Dt].
*/


%%% right-node-raising, poor man's version
%%% de verkrachting van en de moord op de 11-jarige X
grammar_rule(van_en,NP4,[NP1,Van,En,NP2,Op,NP3]) :-
    NP => np, NP0 => np,
    NP1 => np,
    NP2 => np,
    NP4 => np,
    Conj1 => np,
    Conj2 => np,
    En => conj,
    pp_p_arg_np_structure(VanPP,Van,_,NP3),
    pp_p_arg_np_structure(OpPP,Op,_,NP3),
    pp_modifier(VanPP),
    pp_modifier(OpPP),
    hd_mod_structure(NP1,VanPP,Conj1),
    hd_mod_structure(NP2,OpPP,Conj2),
    non_hd_structure([Conj1,En,Conj2],NP0,conj),
    coord_daughter_paths(NP,Conj1),
    coord_daughter_paths(NP,Conj2),
    unify_paths([subn,hstem,meas,wh_reltmploc,sel,neclass],NP4,Conj1),
    finish_mexs(NP0),
    overwrite(NP0,NP,mexs,[]),
    En:dt <=> EnDt,
    Conj1:dt <=> Conj1Dt,
    Conj2:dt <=> Conj2Dt,
    NP:dt => dt,
    NP:dt:crd <=> [EnDt],
    NP:dt:cnj <=> [Conj1Dt,Conj2Dt],
    unify_except(NP,NP4,hstem).

grammar_rule(start_coord(Name,en), M, [ XP, Clist ]) :-
    start_coord_name_en_structure(Name,M,XP,Clist).

% %% vlak voor en na de oorlog == vlak voor de oorlog + vlak na de oorlog
% %% vlak voor en tijdens de oorlog =/= vlak tijdens de oorlog)
% grammar_rule(start_coord(mod_prep,en), M, [ Pal,Voor, Clist ]) :-
%     Voor => p,
%     XP => p,
%     Pal => modal_adv,
%     Pal:modal_adv_arg => adv_prep,
%     hd_mod_structure(Voor,Pal,XP),
%     Voor:cj <=> XP:cj,
%     start_coord_name_en_structure(prep,M,XP,Clist).

grammar_rule(start_coord(dip,root,en), M, [ XP, COMMA, DIP, Clist ]) :-
    comma(COMMA),
    DIP => dip,
    start_coord_name_en_structure(root,M0,XP,Clist),
    Clist:within_word => no,
    unify_except(M0,M,tags),
    Q => no,
    xp_dip_xp_structure(M0,DIP,M,Q).

grammar_rule(start_coord(dip,np,en), M, [ XP, COMMA, DIP, Clist ]) :-
    M => np,
    M0 => np,
    comma(COMMA),
    DIP => dip,
    start_coord_name_en_structure(np,M0,XP,Clist),
    Clist:within_word => no,
    xy_dep_dt(M0,DIP,M,nucl,tag),
    M:dt:cat ==> du,
    unify_except(M0,M,dt).

grammar_rule(start_coord(dipq1,root,en), M, [ QL, XP, QR, COMMA, DIP, Clist ]) :-
    comma(COMMA),
    DIP => dip,
    ql(QL),
    qr(QR),
    start_coord_name_en_structure(root,M0,XP,Clist),
    Clist:within_word => no,
    unify_except(M0,M,tags),
    Q => no,
    xp_dip_xp_structure(M0,DIP,M,Q).

grammar_rule(start_coord(dipq,root,en), M,
             [QL,XP,QR,COMMA,DIP,COMMA2,QL2,Clist,QR2 ]) :-
    optcomma(COMMA),
    ql(QL),
    qr(QR),
    optcomma(COMMA2),
    ql(QL2),
    optqr(QR2),
    DIP => dip,
    start_coord_name_en_structure(root,M0,XP,Clist),
    Clist:within_word => no,
    unify_except(M0,M,tags),
    Q => no,
    xp_dip_xp_structure(M0,DIP,M,Q).

grammar_rule(start_coord(dipq2,root,en), M,
             [QL,XP,QR,COMMA,DIP,COMMA2,Clist,QR2 ]) :-
    optcomma(COMMA),
    ql(QL),
    qr(QR),
    optcomma(COMMA2),
    optqr(QR2),
    DIP => dip,
    start_coord_name_en_structure(root,M0,XP,Clist),
    Clist:within_word => no,
    unify_except(M0,M,tags),
    Q => no,
    xp_dip_xp_structure(M0,DIP,M,Q).

start_coord_name_en_structure(Name,M,XP,Clist) :-
    Clist => clist,
    Clist:etc <=> ETC,
    start_coord_daughter(Name,XP,M,CrdType,[],ETC),
    CrdType => ~two_crd,
    M:cj <=> CrdType,
    Clist:cat <=> M,
    Clist:conj <=> ConjDt,
    Clist:left_conj => no,
    Clist:cats <=> Dts,
    start_coord_structure(Name,ConjDt,M,XP, [XPdt|Dts], Clist),
    XP:dt <=> XPdt.



%% vervolgens vertrok hij, en liep naar huis
%% todo: also allow DIP here
%% todo: across the board of topicalized constituent?
grammar_rule(start_coord(root_imp,en),M,[XP,ImpList]) :-
    start_coord_name_en_structure(root,M,XP,RootList),
    RootList => clist,
    ImpList => clist,
    ImpList:within_word => no,
    RootList:cat <=> Root,
    ImpList:cat <=> Imp,
    RootList:cats <=> ImpList:cats,
    RootList:conj <=> ImpList:conj,
    RootList:left_conj <=> ImpList:left_conj,
    ImpList:etc => no,
    RootList:cform <=> ImpList:cform,
    Root => root,
    Root:question => no,
    Root:allows_root_imp => yes,
    Root:dt <=> Imp:dt,
    Imp => sv1,
    ImpList:last => last,
    ImpList:last:ccat ==> smain,
    Imp:predms => [],
    Imp:mods => [],
    Imp:dets => [],
    Imp:apps => [],
    
    XP:subj <=> Subj1,
    XP:subj => np,
    XP:subj:case => nom,
    XP:subj:sel => ~to_topic, % spur amb; topic should not be subject, because we
                              % get that one already anyway with normal coord rules?

    Imp:subj <=> Subj,
    Subj1 => np,
    Subj => np,
    unify_except(Subj1,Subj,sel),
    Imp:slash <=> [Subj].

%% klagen mag, maar zeur niet over het tentamen en reken maar dat we je in de gaten houden
grammar_rule(start_coord(root_imparative,en),M,[XP,ImpList]) :-
    start_coord_name_en_structure(root,M,XP,RootList),
    RootList => clist,
    ImpList => clist,
    ImpList:within_word => no,
    RootList:cat <=> Root,
    ImpList:cat <=> Imp,
    Imp => imp,
  
    Imp:mods => [],
    Imp:dets => [],
    Imp:apps => [],
    Imp:predms => [],

    RootList:cats <=> ImpList:cats,
    RootList:conj <=> ImpList:conj,
    RootList:left_conj <=> ImpList:left_conj,
    ImpList:etc => no,
    RootList:cform <=> ImpList:cform,
    Root => root,
    Root:question => no,
    Root:dt <=> Imp:dt,
    ImpList:last => last,
    ImpList:last:ccat ==> sv1.

grammar_rule(start_coord(sv1_imparative,en),M,[XP,ImpList]) :-
    start_coord_name_en_structure(sv1,M,XP,RootList),
    RootList => clist,
    ImpList => clist,
    ImpList:within_word => no,
    RootList:cat <=> Root,
    ImpList:cat <=> Imp,
    Imp => imp,
  
    Imp:mods => [],
    Imp:dets => [],
    Imp:apps => [],
    Imp:predms => [],

    RootList:cats <=> ImpList:cats,
    RootList:conj <=> ImpList:conj,
    RootList:left_conj <=> ImpList:left_conj,
    ImpList:etc => no,
    RootList:cform <=> ImpList:cform,
    Root => sv1,
    Root:dt <=> Imp:dt,
    ImpList:last => last,
    ImpList:last:ccat ==> sv1.


%% hij komt wel maar onder protest en niet van harte
grammar_rule(start_coord(root_modifier,en),M,[XP,ModList]) :-
    start_coord_name_en_structure(root,M,XP,RootList),
    RootList => clist,
    ModList => clist,
    ModList:within_word => no,
    RootList:cat <=> Root,
    ModList:cat <=> Mod,
    max_modifier(Mod),
    Mod:mcat => (mcat_vp;mcat_adv;mcat_pp;mcat_sbar),
    Mod:wh => nwh,
    Mod:cj => one_crd, % !!

    ModList:last => last,
    ModList:last:ccat0 <=> ModList:last:ccat,
    
    Mod:mods => [],
    Mod:dets => [],
    Mod:apps => [],
    Mod:predms => [],

    RootList:cats <=> ModList:cats,
    RootList:conj <=> ModList:conj,
    RootList:left_conj <=> ModList:left_conj,
%    ModList:etc => no,
    RootList:cform <=> ModList:cform,
    Root => root,
    Root:question => no,
    Root:dt <=> Mod:dt,
    unify_subj(M,XP).
 
%% Wie heb je gesproken en wie niet?
grammar_rule(start_coord(quest_short,en),M,[XP,ShortList]) :-
    start_coord_name_en_structure(root,M,XP,QuesList),
    M:dt:stype => whquestion,
    QuesList => clist,
    ShortList => clist,
    ShortList:within_word => no,
    QuesList:cats <=> ShortList:cats,
    QuesList:conj <=> ShortList:conj,
    QuesList:left_conj <=> ShortList:left_conj,
%    QuesList:etc <=> ShortList:etc,
    ShortList:etc => no,
    QuesList:cform <=> ShortList:cform,
    QuesList:cat <=> Root,
    Root => root,
%    Root:question => yes,   % hij komt niet , maar waarom niet ?
    ShortList:cat <=> Short,
    ShortList:last => last,
%    ShortList:last:ccat0 <=> ShortList:last:ccat,
    ShortList:last:ccat <=> XP:ccat,  % cf "dat weet ik , maar welk onderdeel ofzo ."
    Short => sbar,
    Short:mods => [],
    Short:apps => [],
    Short:dets => [],
    Short:predms => [],
    ShortList:last:ctype => c_of_short,
    Short:slash => [],
    Short:tags => [],
    Root:dt <=> Short:dt,
    unify_subj(M,XP).

%% zou kunnen maar dat is dan wel een uitzondering
grammar_rule(start_coord(topic_drop_root,en),M,[Drop,ShortList]) :-
    start_coord_name_en_structure(root,M,XP,ShortList),
    M:topic_hstem ==> none,
    ShortList:within_word => no,
    Drop => max,
    Drop:sv1 => yes,
    Drop:max_type => t_topic_drop,
    Drop:cj => ncj,
    XP => root,
    unify_dt(XP,Drop),
    unify_subj(M,Drop).

unify_subj(M,XP) :-
    (   XP => root,
	XP:subj <=> Subj,
	XP:topic_hstem <=> Topic
    ;   XP /=> root,
	Subj => np,
	Subj:nform => none,
	Topic ==> none
    ),
    M:topic_hstem <=> Topic,
    M:subj <?=?> Subj.


grammar_rule(start_coord(Name,zowel_als),M,[ConjL, XP, Clist]) :-
    zowel_als_start_structure(Name,M,CrdType,ConjL,XP,Clist),
    CrdType => two_crd,
    M:cj <=> CrdType.

zowel_als_start_structure(Name,M,CrdType,ConjL,XP,Clist) :-
    Clist => clist,
    Clist:etc <=> ETC,
    start_coord_daughter(Name,XP,M,CrdType,[],ETC),
    ConjL => lconj,
    unify_mods(ConjL),
    ConjL:dt <=> ConjLDt,    
    Clist:cat <=> M,
    Clist:conj <=> ConjRDt,
    Clist:left_conj => yes,
    Clist:cats <=> Dts,
    Clist:cform <=> ConjL:needs_right_cform,
    start_coord_structure(Name,[ConjLDt|ConjRDt],M,XP,[XPdt|Dts],Clist),
    XP:dt <=> XPdt.

%% zowel in voor- als tegenspoed
%% treat '[zowel PREP NP] als NP' as if '[PREP zowel NP] als NP'
grammar_rule(zowel_swap(Name),PP,[ConjL,PREP,XP,Clist]) :-
    lists:member(Name,[np,within_word_conjunction(np)]),
    zowel_als_start_structure(Name,M,CrdType,ConjL,XP,Clist),
    CrdType => two_crd,
    M:cj <=> CrdType,
    pp_p_arg_np_structure(PP,PREP,_,M).

%% zowel de voor- als nadelen
grammar_rule(zowel_swap(within_word_conjunction,np_det_n),NP,[ConjL,DET,XP,Clist]) :-
    zowel_als_start_structure(within_word_conjunction(n),N,CrdType,ConjL,XP,Clist),
    CrdType => swapped_two_crd,
    N:cj <=> CrdType,
    np_det_n_structure(NP,DET,N).

%% zowel de linker- als de rechterkant
grammar_rule(within_word_conjunction(zowel_als_np),MOTHER,[ConjL,DET,WWCN,Clist]) :-
    zowel_als_start_structure(np,MOTHER,CrdType,ConjL,DEVOOR,Clist),
    CrdType => two_crd,
    MOTHER:cj <=> CrdType,
    WWCN => within_word_conjunct,
    unify_dt(WWCN,N),
    np_det_n_structure(DEVOOR,DET,N).

%% zowel in het enkel- als het dubbelspel
grammar_rule(within_word_conjunction(zowel_als_pp),PP,
             [ConjL,Prep,DET,WWCN,Clist]) :-
    zowel_als_start_structure(np,MOTHER,CrdType,ConjL,DEVOOR,Clist),
    CrdType => two_crd,
    MOTHER:cj <=> CrdType,
    WWCN => within_word_conjunct,
    unify_dt(WWCN,N),
    np_det_n_structure(DEVOOR,DET,N),
    pp_p_arg_np_structure(PP,Prep,_,MOTHER).

%% de linker- en de rechterkant
grammar_rule(within_word_conjunction(en_np),MOTHER,[DET,WWCN,Clist]) :-
    start_coord_name_en_structure(np,MOTHER,DEVOOR,Clist),
    Clist:etc => no,
    CrdType => one_crd,
    MOTHER:cj <=> CrdType,
    WWCN => within_word_conjunct,
    unify_dt(WWCN,N),
    np_det_n_structure(DEVOOR,DET,N).


start_coord_structure(Name1,ConjDt,M,XP,Dts,Clist) :-
    Name1 = within_word_conjunction(Sub),
    !,
    Clist:within_word => yes,
    unify_except(XP,XP1,ccat0),
    start_coord_struct_all(Sub,ConjDt,M,XP1,Dts,Clist),
    Clist:last <=> CLast,
    Clist:last => last,
    one_daughter_unifications(CLast,M).

start_coord_structure(Name1,ConjDt,M,XP,Dts,Clist) :-
     (   Name1 = of(Name)
     ->  E:last => last,
	 E:last <=> CLast,
	 CLast:subn <?=?> M:subn % more features??
     ;   Name1 = Name
     ),
     (   (  Name == sv1
	 ;  Name == vpx
	 ;  Name == vproj
	 )
     ->  XP:ccat0 <=> M:ccat0
     ;   true
     ),
     Clist:last => last,
     Clist:last:ccat0 <=> Clist:last:ccat,
     start_coord_struct_all(Name,ConjDt,M,XP,Dts,Clist).

start_coord_struct_all(Name,ConjDt,M,XP,Dts,Clist) :-
    structure,
    Clist:etc <=> ETC,
    conjunction_cat(Name,M0,CnjType,ETC),
    slash_edeps(M0),
    CnjType => ~ncj,
    M0:dt:crd <=> ConjDt,
    M0:dt:cat ==> conj,
    initialize_dt([cnj,crd],M),
    M:dt:hwrd => [],
    M0:dt:mod => [],
    M0:dt:app => [],
    M0:dt:det => [],
    M0:dt:predm => [],
    M0:cmods   => [],
    M0:capps   => [],
    M0:cdets   => [],
    M0:cpredms => [],
    M0:dt:cnj <=> Dts,
    M0:cj <=> CnjType,
    M0:ppost =?> [],
    add_rel_cj(M0,M1),
    del_exs_imp(M1,M),
    M:prs =?> thi,	% ?? jij of ik *ben/*bent/?is de pineut
			%    dat vragen mijn vrouw en ik ONS af --> first person
                        %    dat moeten jij en je vrouw je maar eens afvragen --> second person
    one_daughter_unifications(M,XP),
    Clist:enzlast => last,
    Clist:enzlast <=> EnzLast,
    one_daughter_unifications(M,EnzLast).

del_exs_imp(M,M) :-
    M /=> sv1.
del_exs_imp(M,M) :-
    M => sv1,
    M:imexs <=> IMEXS,
    alpino_wappend:unify_inout(IMEXS).

mid_coord_structure(Name,Blist,A,Clist) :-
    structure,
    Blist => clist,
    Clist => clist,
    Blist:cform <=> Clist:cform,
    Blist:etc <=> Clist:etc,
    Clist:etc <=> ETC,
    nonfinal_coord_daughter(Name,A,BlistCat,_,[],ETC),
    (   A => within_word_conjunct,
	Blist:within_word => yes
    ;   A /=> within_word_conjunct,
	Blist:within_word => no
    ),
    nonstart_nonfinal_coord_daughter_unifications(Name,A,BlistCat),
    A:tags =?> [],
    A:dt <=> Dt,
    Blist:cat <=> BlistCat,
    Clist:cat <=> BlistCat,
    Blist:cats <=> [Dt|Dts],
    Clist:cats <=> Dts,
    Blist:last <=> Clist:last,
    Clist:enzlast => last,
    Clist:enzlast <=> EnzLast,
    Blist:left_conj <=> Clist:left_conj,
    one_daughter_unifications(A,EnzLast).

grammar_rule(mid_coord(Name),Blist,[COMMA, A, Clist]) :-
    mid_coord_structure(Name,Blist,A,Clist),
    Blist:conj <=> Clist:conj,
    COMMA => punct,
    COMMA:puncttype => komma.

grammar_rule(mid_coord(Name,conj),Blist,[OPTCOMMA, Conj, A, Clist]) :-
    mid_coord_structure(Name,Blist,A,Clist),
    Conj => conj,
    Conj:cform <=> CFORM,
    when((nonvar(CFORM)),
	 (   CFORM == om -> lists:member(Name,[num,np,pred])
	 ;   CFORM == à  -> lists:member(Name,[num,np,pred])
	 ;   true
	 )
	),
    unify_mods(Conj),
    optcomma(OPTCOMMA),
    Conj:dt <=> ConjDt,
    %% new: forbid "Jan en Piet , Kees"
    Blist:cat:cj => ~no_crd,
    Blist:conj <=> [ConjDt|ClistConj],
    Clist:conj <=> ClistConj,
    Conj:left_conj <=> Clist:left_conj.

grammar_rule(end_coord(Name,conj), Blist,
             [ OPTCOMMA_DASH, Conj, OPTDUBB, A, OPTCOMMA_DASH2 ]):-
    optcomma_end(OPTCOMMA_DASH),
    optcomma_dash(OPTCOMMA_DASH2),
    % OPTCOMMA_DASH:cat:puncttype <=> OPTCOMMA_DASH2:cat:puncttype,
    optdubb(OPTDUBB),
    end_coord_conj_structure(Name,Blist,Conj,A,[]).

grammar_rule(bracketed_end_coord(Name,conj),Blist,
                           [OPEN,Conj,A,OPTPUNCT,CLOSE ]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    end_coord_conj_structure(Name,Blist,Conj,A,[]).

end_coord_conj_structure(Name,Blist,Conj,A,ModList) :-
    structure,
    Blist => clist,
    Conj => conj,
    unify_mods(Conj),
    Conj:dt <=> ConjDt,
    Conj:cform <=> Blist:cform,
    Conj:cform <=> CFORM,
    when((nonvar(CFORM)),
	 (   CFORM == om -> lists:member(Name,[num,np,pred])
	 ;   CFORM == à  -> lists:member(Name,[num,np,pred])
	 ;   true
	 )
	),
    Conj:left_conj <=> Blist:left_conj,
    Blist:conj <=> [ConjDt],
    Blist:cat <=> BlistCat,
    BlistCat:cj <=> CrdType,
    CrdType => ~no_crd,
    final_coord_daughter(Name,A,BlistCat,CrdType,ModList,_ETC),
    Blist:cats <=> [DtA],
    Blist:last => last,
    Blist:last <=> BLast,
    one_daughter_unifications(BLast,A),
    A:tags =?> [],
    A:dt <=> DtA.

grammar_rule(end_coord(Name,conj,mod), Blist,
             [ OPTCOMMA_DASH, Conj, MOD, A, OPTCOMMA_DASH2]) :-
    optcomma_end(OPTCOMMA_DASH),
    optcomma_dash(OPTCOMMA_DASH2),
%    OPTCOMMA_DASH:cat:puncttype <=> OPTCOMMA_DASH2:cat:puncttype,
    end_coord_conj_mod_structure(Name,Blist,Conj,MOD,A).

grammar_rule(bracketed_end_coord(Name,conj,mod), Blist,
	     [OPEN,Conj,MOD,A,OPTPUNCT,CLOSE]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    optend_mod_punct(OPTPUNCT),
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    end_coord_conj_mod_structure(Name,Blist,Conj,MOD,A).

%% wat is politiek en , nog belangrijker , wat is beleid
%% wat is politiek en vooral , wat is beleid
grammar_rule(end_coord(Name,conj,c_mod), Blist,
	     [OPTCOMMA_DASH,Conj,Cl,MOD,Cr,A]) :-
    optcomma_end(OPTCOMMA_DASH),
    optcomma_dash(Cl), comma_dash(Cr),
    end_coord_conj_mod_structure(Name,Blist,Conj,MOD,A).

%% wat is politiek en , nog belangrijker , wat is beleid
%% wat is politiek en vooral , wat is beleid
grammar_rule(bracketed_end_coord(Name,conj,c_mod), Blist,
	     [OPEN,Conj,Cl,MOD,Cr,A,CLOSE]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    OPEN => punct, OPEN:puncttype => haak_open,
    CLOSE => punct, CLOSE:puncttype => haak_sluit,
    optcomma(Cl), comma(Cr),
    end_coord_conj_mod_structure(Name,Blist,Conj,MOD,A).

end_coord_conj_mod_structure(Name,Blist,Conj,MOD,A) :-
    MOD => modifier,
    MOD:exs => [],
    finish_mexs(MOD),
    unify_mods(MOD),
    MOD:dt <=> MODdt,
    MOD:mcat => ~mcat_imp,
    MOD:wh => nwh,
    end_coord_conj_structure(Name,Blist,Conj,A,[MODdt]),   
    A /=> vpx, A /=> sv1, A /=> v, 
    %%% A /=> vb,  A /=> vc,   % gives rise to cyclic terms (in generation)!!!
    A /=> rel, A /=> pn, A /=> n, A /=> det, A/=> vproj, A /=> a, A /=> v_noun,
    A /=> vc_noun,
    A /=> comp,
    (  A => adv,
       A:subadv => ~subadv_adj % DIY
    ;  A /=> adv
    ).

grammar_rule(end_coord(Name,noconj),Clist,[COMMA, A, OPTCOMMA]) :-
    structure,
    optcomma(OPTCOMMA),
    Clist => clist,
    Clist:cform => [],
    Clist:conj => [],
    Clist:left_conj => no,
    Clist:cat <=> ClistCat,
    Clist:etc <=> ETC,
    CrdType => no_crd,
    ClistCat:cj <=> CrdType,
    final_coord_daughter(Name,A,ClistCat,CrdType,[],ETC),
    Clist:cats <=> [DtA],
    COMMA => punct,
    COMMA:puncttype => komma,
    Clist:last => last,
    Clist:last <=> CLast,
    one_daughter_unifications(CLast,A),
    A:tags =?> [],
    A:has_app =?> no,
    A:dt <=> DtA.

%% appels, peren , en :
grammar_rule(end_coord(en_hellip),Clist,[OPTCOMMA, Conj, DUBB]) :-
    structure,
    optcomma(OPTCOMMA),
    DUBB => punct,
    DUBB:puncttype => (dubb_punt;hellip),
    Clist => clist,
    Clist:cform <=> Conj:cform,
    Clist:left_conj <=> Conj:left_conj,
    Clist:etc => yes,
    Conj => conj,
    unify_mods(Conj),
    Clist:cats => [],
    Conj:dt <=> ConjDt,
    Clist:conj <=> [ConjDt].

%% een fijne avond en tot ziens
%% ik klap in mijn handen en voila
grammar_rule(end_coord(en_tag),Clist,[OPTCOMMA, Conj, TAG]) :-
    structure,
    optcomma(OPTCOMMA),
    TAG => tag,
    TAG:np => no,
    TAG:dt <=> TagDT,
    unify_mods(TAG),
    Clist => clist,
    Clist:cform <=> Conj:cform,
    Clist:left_conj <=> Conj:left_conj,
    Clist:etc => yes,
    Conj => conj,
    unify_mods(Conj),
    Clist:cats <=> [TagDT],
    Conj:dt <=> ConjDt,
    Clist:conj <=> [ConjDt].

enz_coord_structure(Clist,OPTCOMMA,Conj) :-
    structure,
    optcomma(OPTCOMMA),
    Clist => clist,
    Clist:cform => [],
    Clist:left_conj => no,
    Clist:etc => yes,
    unify_mods(Conj).

grammar_rule(end_coord(enz),Clist,[OPTCOMMA, Conj]) :-
    Conj => etc,
    enz_coord_structure(Clist,OPTCOMMA,Conj),
    Clist:cats => [],
    Conj:dt <=> ConjDt,
    Clist:conj <=> [ConjDt].
%    Clist:last <=> Clist:enzlast.

grammar_rule(end_coord(complex_enz),Clist,[OPTCOMMA, Conj]) :-
    Conj => complex_etc,
    enz_coord_structure(Clist,OPTCOMMA,Conj),
    Clist:conj <=> ConjDt,
    Conj:dt => dt,
    Clist:cats <=> Conj:dt:cnj,
    Conj:dt:crd <=> ConjDt.
%    Clist:last <=> Clist:enzlast.

%% essentially, each conjunct is the head
%% however, this does not work for current treatment of modification
%% (since this would entail that both conjuncts have the same set
%% of adjuncts...). Therefore, we reset mods/cmods for coordination
%% so that further modifiers end up as modifiers of the coordination.

start_coord_daughter(A,B,Mother,D,E,F) :-
    nonfinal_coord_daughter(A,B,Mother,D,E,F).

%% ik vroeg of en (zo ja) met wie hij komt
%% * of of naar waar gaat dat naartoe leiden ?
start_coord_daughter(of(Sub),Cat,Mother,Type,Mods,ETC) :-
    ETC => no,
    Cat => comp,
    Cat:e_deps => [],
    Cat:ctype => c_of,
    Cat:slash => [],
    Cat:sc <=> [_],
    Cat:tags => [],
    unify_mods(Cat),
    Type => of_crd,
    (  Mother => adv
    ;  Mother => pp
    ;  Mother => modifier
    ;  Mother => np
    ),
    LexCat:capps => [],
    LexCat:cmods => [],
    LexCat:cdets => [],
    LexCat:cpredms => [],
    final_coord_daughter(Sub,LexCat,Mother,Type,Mods,ETC),
    LexCat:wh => ywh,
    Cat:dt <=> LexCat:dt.    

nonfinal_coord_daughter(Name,L,M,Type,Mods,ETC) :-
    final_coord_daughter(Name,L,M,Type,Mods,ETC).
%    L:has_app =?> no.

nonfinal_coord_daughter(within_word_conjunction(Name),
			Cat,
			Mother,
			Type,
			Mods,
			ETC) :-
    ETC => no,
    Cat => within_word_conjunct,
    allows_within_word_conjunction(Name),
    final_coord_daughter(Name,LexCat,Mother,Type,Mods,ETC),
    Type => ~no_crd, % wrong for: 'mijn aller- , allerbeste vriend'
    Cat:dt <=> LexCat:dt,
    Cat:ccat0   <=> Mother:ccat0,
    Cat:ccat    <=> Mother:ccat,
    Cat:cdets   <=> LexCat:cdets,
    Cat:dets    <=> LexCat:dets,
    Cat:cmods   <=> LexCat:cmods,
    Cat:mods    <=> LexCat:mods,
    Cat:cpredms <=> LexCat:cpredms,
    Cat:predms  <=> LexCat:predms,
    Cat:capps   <=> LexCat:capps,
    Cat:apps    <=> LexCat:apps.

%% only for a and n, and their unary projections (because of the
%% cj=ncj feature)
allows_within_word_conjunction(num).
allows_within_word_conjunction(adv).
allows_within_word_conjunction(a).
allows_within_word_conjunction(np).
allows_within_word_conjunction(n).
allows_within_word_conjunction(pred).
allows_within_word_conjunction(v_noun).
allows_within_word_conjunction(vc_noun).
%% zowel voor- als achterin
allows_within_word_conjunction(pp).
allows_within_word_conjunction(modifier).

final_coord_daughter(Name,L,M,Type,Mods,ETC) :-
    conjunction_cat(Name,L,Type,ETC),
    slash_edeps(L),
    L:cj => ncj,
    finish_mexs(L),
    L:imexs =?> [],
    functor(L,F,A),
    functor(M,F,A),
    coord_daughter_unifications(L,M,Mods).

%% if a constituent in topic has a dependent in VP
%% via exs or e_deps, then the VP should not be
%% coordinated, otherwise there could be two such
%% dependents with conflicting dt's.
slash_edeps(Cat) :-
    if_defined(Cat:slash,Slash,[]),
    when(nonvar(Slash),
	 (   Slash = []
	 ;   Slash = [Sub],
	     when(nonvar(Sub),( alpino_data:empty_e_deps(Sub)
			      , alpino_data:exs(Sub,[])
			      )
		 )
	 )
	),
    if_defined(Cat:vslash,Vslash,[]),
    when(nonvar(Vslash),
	 alpino_data:vslash_empty(Vslash)
	).

%% since we cannot percolate these upward, we need to unify them locally
%% or else we might end up with non-instantiated cat value. Problem:
%% for within_word_conjunction this should not happen
%%
nonstart_nonfinal_coord_daughter_unifications(sv1,L,M) :-
    !,
    L:ccat <=> M:ccat.
nonstart_nonfinal_coord_daughter_unifications(vpx,L,M) :-
    !,
    L:ccat <=> M:ccat.
nonstart_nonfinal_coord_daughter_unifications(vproj,L,M) :-
    !,
    L:ccat <=> M:ccat.
nonstart_nonfinal_coord_daughter_unifications(within_word_conjunction(_),L,M) :-
    !,
    L:ccat <=> M:ccat.
nonstart_nonfinal_coord_daughter_unifications(_,L,_M) :-
    L:ccat0 <=> L:ccat.

%% those features should somehow percolate upward to the coordination, but they need not
%% unify between daughters.
%% hack: only percolate features of the first daughter, except for within_word_conj, in which
%% we use the last daughter of the coordination...
%% for sv1 ccat0/ccat it is more complicated, becuase of
%% "ik aarzelde even en vertrok" where everyone is smain.
%%
%% passive: voor het geval er iemand wordt gepakt of doorslaat
one_daughter_unifications(Cat0,Cat) :-
    Paths=[case,
	   ccat,subn,adv,prep,part,sv1_mod,vframe,ctype,tmploc,pcat,mcat,sel,
           pro,parg,hebben_zijn,neclass,passive,question,subadv,pp_er,
           can_nominalize,can_marked_attr,can_postv,deverbal,redrel,
	   can_postn,wh_reltmploc,cform,meas,tags,hstem,eps,avform],
    unify_paths(Paths,Cat0,Cat),
    (   Cat => sv1,
        Cat0:subj <?=?> Cat:subj
    ;   Cat => vpx
    ;   Cat => vproj
    ;   Cat => root,
	Cat0:subj <?=?> Cat:subj,
	Cat0:topic_hstem <?=?> Cat:topic_hstem,
	Cat0:ccat0 <=> Cat:ccat0
    ;   Cat /=> root,
	Cat /=> sv1,
        Cat /=> vpx,
        Cat /=> vproj,
        Cat0:ccat0 <=> Cat:ccat0
    ).

coord_daughter_paths(L,M) :-
    % ok: these features require strict identity
    %% removed cform: 'slecht maar beter dan vorig jaar'
    %% removed ctype: 'hij wil weten of je komt en wie er nog meer komt'
    %% removed tmploc: 'overal en altijd'
    %% ccat0 is not right either: 'niet of te weinig'
    %% removed redrel: "Dat zal afhangen van wat je gebruikt en de behoeften van de gebruiker"
    %% removed case: voor mijn vrouw en ik
    Paths = [vform,aform,nform,wh,app,tpart,amount,exs,cleft,
             compar_form,vslash,relform,ld_pc,me_adj,adj_can_postv,
             modifies_a,slash,sc,parts,pro_deps,e_deps,pred,
             % question,
	     % pp_er, %% in de schaatswereld en daarbuiten werd fel gespeculeerd
             allows_root_imp,
             pp_role,haswh],
    unify_paths(Paths,L,M).


%% subj cannot be unified for vp etc in case the subj has
%% been realized in the conjunct already
coord_daughter_unifications(L,M,Mods) :-
    coord_daughter_paths(L,M),

    (	L => v,
	L:subj <=> M:subj
    ;	L => vb,
	L:subj <=> M:subj
    ;	L => vc,
	L:subj <=> M:subj
    ;   L => vp,
	L:vform => ~fin,
	L:subj <=> M:subj
    ;   L => vp,
	L:vform => fin
    ;	L /=> v, L /=> vb, L /=> vc, L /=> vp
    ),

    (   L => rel,
	L:hstem <=> M:hstem
    ;   L /=> rel
    ),

    (   (  L => sv1
        ;  L => vpx
        ;  L => vproj
        ),
        L:ccat <=> M:ccat
    ;   L /=> sv1,
        L /=> vpx,
        L /=> vproj
    ),
    
    (   L => a,
	L:agr <=> M:agr
    ;   L /=> a
    ),

    (  L => comp,
       L:ctype <=> M:ctype
    ;  L /=> comp
    ),

    (  L => n,
       L:hdet <=> M:hdet
    ;  M /=> n
    ),
    
    %% and now add future modifiers/dets/appos to ours...
    
    L:cmods <=> Cmods0,
    M:mods  <=> Mmods,
    L:mods  <=> Lmods,
    alpino_wappend:wappend(Cmods0,Mods,Cmods),
    alpino_wappend:wappend(Cmods,Mmods,Lmods),

    L:capps <=> Capps,
    M:apps  <=> Mapps,
    L:apps  <=> Lapps,
    alpino_wappend:wappend(Capps,Mapps,Lapps),

    L:cpredms <=> Cpredms,
    M:predms  <=> Mpredms,
    L:predms  <=> Lpredms,
    alpino_wappend:wappend(Cpredms,Mpredms,Lpredms),

    L:cdets   <=> Cdets,
    M:dets    <=> Mdets,
    L:dets    <=> Ldets,
    alpino_wappend:wappend(Cdets,Mdets,Ldets).

%% conjunction_cat(Name,Sign,Type,ETC)
%% Type=no_crd    NP , NP , NP , NP
%% Type=one_crd   NP en NP
%% Type=two_crd   zowel NP als NP
%%
%% TypeEnd=end 
conjunction_cat(vp,M,Crd,_) :-
    Crd => ~no_crd,    % niet om te ... maar om te ...
    M => vp,
    M:vform => (om;te;inf;psp),
    M:tags => [].

conjunction_cat(finvp,M,Crd,_) :-
    Crd => one_crd,    
    M => vp,
    M:vform => fin,
    M:tags => [].

conjunction_cat(vpx,M,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    M => vpx,
    no_conjoined_vslash(M),
    no_vc_vp_slash(M),
    M:eps3 => no,  % THIS IS TOO STRICT
                   % ik geef haar een kadootje en jou de roe
                   % on the other hand, "ik geef een kadootje en een bloemetje"
                   % should not be analysed as a VP coordination.
                   % how to say: VP must contain at least two "parts".
    M:tags => [].

%% zo'n twee , drie boeken
conjunction_cat(num,M,_,ETC) :-
    ETC => no,
    M => num.

conjunction_cat(max,M,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    M => max,
    M:max_type => t_part.

%% we cannot treat:
%% geslagen werd ik niet en word ik niet
%% since the vc-dt is supposed to be identical. That doesn't work (problems
%% in second phase), therefore we explicitly forbid vc topicalization in
%% sv1 conjunction :-(
%% Also for vpx conjunction
%% The same is true for vp with control:
%% "te slapen , zwoeren de leden of bleken ze"
conjunction_cat(sv1,M,Crd,ETC) :-
    Crd => one_crd,
    ETC => no,
    M => sv1,
    no_vc_vp_slash(M),
    M:tags => [],
    M:iexs => [].

conjunction_cat(imp,M,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    max_imp(M).

%% zowel binnen als buiten ..
conjunction_cat(prep,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => p,
    M:pp_role /=> pp_pobj1.  % 2nd phase: "Zelf heb ik er problemen mee , maar aan [ commentaren te lezen ]

conjunction_cat(part,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => part.

% vform fin: "omdat ik hem moet en zal hebben"
%            "ik moet en zal hem hebben"
% vform inf: ?"te kopen of verkopen"
conjunction_cat(v,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd, 
    M => v,
    M:eps3 => no,
    M:vslash => [],
    M:vform => (inf;fin).

conjunction_cat(vc,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => vc,
    M:eps3 => no,
    M:vslash => [],
    M:pspslash => [].

%% ik wil geroemd en geprezen worden
%% omdat hij te roemen en te prijzen zou zijn
%% omdat hij aan het vliegeren en aan het fluiten is
%% omdat ik nu eten en drinken wil
conjunction_cat(vb,M,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    M => vb,
    M:vform => (inf;aan_het;psp;pass_te),
    M:eps3 => no,
    M:vslash => [].

conjunction_cat(adv,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => adv,
    M:wk => no,
    M:tmploc => ~wk_er & ~str_er.

conjunction_cat(root,M,Crd,_) :-
    Crd => one_crd,
    max_root(M0),
    unify_except(M0,M,mods),
    M:tags => [],
    M:needs_dip => no.

conjunction_cat(a,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => a,
    M:aform => ~only_n. % problems in case of etc, due to ccat0=/=ccat

conjunction_cat(pp,M,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    M => pp,
    M:slash => [],
    M:nnform => ~refl.

conjunction_cat(np,Np,_,_) :-
    Np => np,
%    Np:subn => ~sub_indef_verb, % to reduce ambiguities
    Np:wkpro => ~weakpro.	     % block coordination with weak pronouns..

conjunction_cat(rel,Rel,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    Rel => rel.

conjunction_cat(pred,P,_,_) :-
    P => pred,
    P:wkpro => ~weakpro.

conjunction_cat(pn,N,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    N => pn.

conjunction_cat(n,N,Crd,_) :-
    Crd => (one_crd;swapped_two_crd),
    N => n,
    %% * de [ Nederlandse Antillen en Aruba ]
    %% * de [ Veluwe en Betuwe ]
    %% however:
    %% ok  de gsm of PDA
    N:hdet <=> HDET,
    YES => yes,
    NO => no,
    SUBN => ~sub_name,
    N:subn <=> NSUBN,
    when(nonvar(HDET),
	 (   HDET=NO
	 ;   HDET=YES,
	     NSUBN = SUBN
	 )
	).

conjunction_cat(sbar,S,Crd,_) :-
    Crd => ~no_crd,
    S => sbar,
    S:tags => [].

%% zijn of haar nationaliteit
%% weinig of geen
%% "die en die"
%% nauwelijks of geen / geen of nauwelijks

conjunction_cat(det,S,Crd,ETC) :-
    ETC => no,
    Crd => ~no_crd,
    S:wkpro => ~weakpro,
    S:neclass ==> none,
    S => det.

% %% dat ik hem kus en haar sla
%%%% (almost?) not necc. with vgap
conjunction_cat(vproj,VP,Crd,ETC) :-
     ETC => no,
     Crd => one_crd,
     VP:sc <=> [_],  % hack...; this rule is mostly useful for cases where
                     % subject is not included in coordinated vp
                     % omdat hij de boeken leest en een plaatje draait
     VP => vproj,
     no_conjoined_vslash(VP),
     no_vc_vp_slash(VP),
     VP:eps3 => no,  % reduce search space and spur. ambiguities
     VP:tags => [].

conjunction_cat(v_noun,V,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    V => v_noun.

conjunction_cat(vc_noun,V,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    V => vc_noun.

conjunction_cat(comp,V,Crd,ETC) :-
    ETC => no,
    Crd => one_crd,
    V => comp.

conjunction_cat(modifier,V,Crd,_) :-
    V => modifier,
    V:mcat => ~mcat_bracket,  % also to prevent "vandaag en vooral (in Assen)"
    Crd => ~no_crd.

conjunction_cat(enumeration,V,Crd,ETC) :-
    ETC => no,
    V => enumeration,
    Crd => one_crd.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% COMPARATIVES %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

comparative_structure(Comp,XP,CompP) :-
    CompP => comparativep,
    Comp => comparative,
    unify_mods(XP),
    XP:tags =?> [],
    cmp_body_structure(Comp,XP,CompP,cp).

grammar_rule(comparative(np), CompP, [ Comp, XP ]) :-
    max_np(XP),
    XP:subn => ~sub_indef_verb,
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(mod_np), CompP, [ Comp, COMMA, MOD, COMMA2, XP ]) :-
    comma_dash(COMMA),
    comma_dash(COMMA2),
    max_modifier(MOD),
    max_np(XP),
    XP:subn => ~sub_indef_verb,
    XP1 => np,
    hd_mod_structure(XP,MOD,XP1),
    comparative_structure(Comp,XP1,CompP).

grammar_rule(comparative(adv_np), CompP, [ Comp, MOD, XP ]) :-
    max_advp(MOD),
    MOD:subadv => ~subadv_adj,
    MOD:subadv => ~subadv_noun,
    max_np(XP),
    XP:subn => ~sub_indef_verb,
    XP1 => np,
    dp_dp_structure(XP,MOD,XP1),
    comparative_structure(Comp,XP1,CompP).

grammar_rule(comparative(pp), CompP, [ Comp, XP ]) :-
    max_pp(XP),
    XP:sel => ~to_topic,
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(adv_pp), CompP, [ Comp, MOD, XP ]) :-
    max_advp(MOD),
    MOD:subadv => ~subadv_adj,
    MOD:subadv => ~subadv_noun,
    max_pp(XP),
    XP1 => pp,
    XP1:sel => ~to_topic,
    dp_dp_structure(XP,MOD,XP1),
    comparative_structure(Comp,XP1,CompP).

grammar_rule(comparative(a), CompP, [ Comp, XP ]) :-
    max_nadv_ap(XP),
    XP:adv => nboth,
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(adv), CompP, [ Comp, XP ]) :-
    max_advp(XP),
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(sbar), CompP, [ Comp, XP ]) :-
    XP => sbar,
    XP:tags => [],
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(vp), CompP, [ Comp, XP ]) :-
    XP => vp,
    XP:vform => (om;fin;te),
    XP:e_deps => [],
    comparative_structure(Comp,XP,CompP).

grammar_rule(comparative(vpx), CompP, [ Comp, XP ]) :-
    XP => vpx,
    XP:vform => (inf;psp),
    no_vslash(XP),
    XP:e_deps => [],
    comparative_structure(Comp,XP,CompP).

%% "ik slaap zoveel [als] ik maar kan"
%% "ik gilde zo hard [als] ik maar kon
%% 
grammar_rule(comparative(empty_als),C,[VP]) :-
    structure,
    C => comparativep,
    C:compar_form => cf_e_als,
    VP => vp,
    VP:vform => fin,
    VP:slash => [],
    VP:tags => [],
    VP:e_deps => [],
    unify_paths([dt,ccat0,ccat,cmods,mods,capps,apps,cdets,dets,
                 cpredms,predms],C,VP).
    

optpunct_structure(OPTPUNCT) :-
    OPTPUNCT => optpunct,
    structure.

grammar_rule(optpunct(e),OPTPUNCT,[]) :-
    optpunct_structure(OPTPUNCT),
    OPTPUNCT:realized => no.

grammar_rule(optpunct(ne),OPTPUNCT,[PUNCT]) :-
    hdrug_util:hdrug_flag(parse_or_generate,parse),
    optpunct_structure(OPTPUNCT),
    OPTPUNCT:realized => yes,
    PUNCT => punct,
    OPTPUNCT:cat <=> PUNCT.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% liever X dan X
grammar_rule(compar_np_dan_obcomp,Start,[MOD0,XP,OBCOMP]) :-
    Start => start,
    MOD0 => modifier,
    MOD => modifier,
    OBCOMP => comparativep,
    MOD0:exs <=> [OBCOMP],
    max_np(XP),
    hd_extra_structure(MOD0,OBCOMP,MOD),
    dp_dp_structure(MOD,XP,Start).

grammar_rule(compar_pp_dan_obcomp,Start,[MOD0,XP,OBCOMP]) :-
    Start => start,
    MOD0 => modifier,
    MOD => modifier,
    OBCOMP => comparativep,
    MOD0:exs <=> [OBCOMP],
    max_pp(XP),
    hd_extra_structure(MOD0,OBCOMP,MOD),
    dp_dp_structure(MOD,XP,Start).

grammar_rule(compar_adv_dan_obcomp,Start,[MOD0,XP,OBCOMP]) :-
    Start => start,
    MOD0 => modifier,
    MOD => modifier,
    OBCOMP => comparativep,
    MOD0:exs <=> [OBCOMP],
    max_advp(XP),
    hd_extra_structure(MOD0,OBCOMP,MOD),
    dp_dp_structure(MOD,XP,Start).

grammar_rule(compar_adj_dan_obcomp,Start,[MOD0,XP,OBCOMP]) :-
    Start => start,
    MOD0 => modifier,
    MOD => modifier,
    OBCOMP => comparativep,
    MOD0:exs <=> [OBCOMP],
    max_ap(XP),
    hd_extra_structure(MOD0,OBCOMP,MOD),
    dp_dp_structure(MOD,XP,Start).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% UTILITIES %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

unify_paths([],_,_).
unify_paths([H|T],A,B) :-
    A:H <?=?> B:H,
    unify_paths(T,A,B).

unify_vb_v(Sign0,Sign) :-
    Sign => vb,
    Sign0 => v,
    alpino_types:type(v,_,Atts),
    unify_each(Atts,Sign,Sign0).

unify_vc_vb(Sign0,Sign) :-
    Sign => vc,
    Sign0 => vb,
    alpino_types:type(vb,_,Atts),
    unify_each(Atts,Sign,Sign0).

unify_each([],_,_).
unify_each([Att|Atts],Sign0,Sign) :-
    Sign0:Att <?=?> Sign:Att,
    unify_each(Atts,Sign0,Sign).

%% macros to construct dependency trees
%dt(Node,Dt) :-
%    Dt => dt,
%    Node:dt <=> Dt.

dts([],[]).
dts([H0|T0],[H|T]) :-
    alpino_data:dt(H0,H),
    dts(T0,T).

add_mf(Mother,Arg,Hd) :-
    Hd:mf <=> Tail,
    Mother:mf <=> [Arg|Tail].

%% only allow wh in situ if there is already another WH.
%% wie is wanneer waarvoor verantwoordelijk?
allow_wh_in_situ(PP,VP) :-
    NWH => nwh,
    YWH => ywh,
    VP:haswh <=> HASWH,
    YES => yes,
    
    if_defined(PP:wh,WH,NWH),

    when( ?=(WH,NWH),
          (  WH=NWH
          ;  WH=YWH,
             HASWH=YES
          )
        ).


%% ik heb de man en de vrouw gezien die hier zijn komen wonen
%%
%% we can't simply pass on mexs, because this would imply requiring
%% identical mexs values; however mexs represents agreement of noun too...
%%
%% perhaps we should do something similar for other categories?
%% pp:
%% ik heb met de jongens en met de meisjes getraind die altijd goed
%%                  hun best deden        
add_rel_cj(N,N) :-
    N /=> np,
    N:mexs =?> [].
add_rel_cj(N0,N) :-
    finish_mexs(N0),
    unify_except(N0,N1,mexs),
    N1:mexs => [],
    add_rel(N1,N).

add_rel(N0,N) :-
    N0 => np,
    N:wkpro => ~weakpro,
    N0:mexs <=> RestMexs,
    unify_except_l(N0,N,[cmods,mexs]),
    N:mexs <=> [Cat|RestMexs],
    Cat => mexs_cat,
    N0:cmods <=> Cmods0,
    N:cmods <=> Cmods,
    Cat:mods <=> Out,
    when((nonvar(Out);?=(Cmods0,Cmods);nonvar(Cmods)),
         ( Out = [], Cmods0=Cmods
         ; Out = [Mod], Cmods=[Mod|Cmods0]
         )
        ),
    Cat:sel <=> N:sel,
    Cat:hstem <=> N:hstem,
    Cat:nform <=> N:nform,
    Cat:tmploc => (loc;non_adv;str_er),
    Cat:agr <=> N:agr.

%% app mod det predm svp are already initialized
initializable_dt_attributes([body,cmp,cnj,crd,dlink,dp,hdf,ld,me,mwp,
                             nucl,obcomp,obj1,obj2,pc,pobj1,predc,
                             rhd,sat,se,su,sup,svp,tag,vc,whd]).
                            
initialize_dt(AttsIn,Sign) :-
    Sign:dt => dt,
    Sign:dt <=> DT,
    initialize_dt_dt(AttsIn,DT).

initialize_dt_dt(AttsIn,DT) :-
    sort(AttsIn,Atts),
    initializable_dt_attributes(Atts0),
    select_all(Atts,Atts0,AttsEmpty),
    empty_dts(AttsEmpty,DT).

empty_dts([],_).
empty_dts([H|T],DT) :-
    DT:H => [],
    empty_dts(T,DT).

select_all([],L,L).
select_all([H|T],L0,L):-
    lists:select(H,L0,L1),
    select_all(T,L1,L).

%% rule out "wij horen en zien hem razen en tieren"
%% with the analysis as if
%% "(wij horen hem razen en wij zien hem razen) en (wij horen hem tieren en wij zien hem tieren)"
%% which also gives rise to
%% error: the positions overlap: [1,2,3] _383228

no_conjoined_vslash(M) :-
    M:vslash <=> VSLASH,
    VSLASH1 => vslash,
    VSLASH1:cj => ncj,
    VSLASH1:vslashparts => [],
%    VSLASH1:vslashhwrd <=> SOME,
%    dif(SOME,[]),
    when(?=(VSLASH,[]),
	 (  VSLASH=[]
	 ;  VSLASH=VSLASH1
	 )
	).

no_vc_vp_slash(M) :-
    M:slash <=> SlashVal,
    SlashCat /=> vc,
    SlashCat /=> vp,
    NP => np, % otherwise we'll get pending constraints in case SlashVal=[]
              % because of inequalities in previous lines
    when(nonvar(SlashVal),
	 (  SlashVal = [], SlashCat = NP 
	 ;  SlashVal = [SlashCat]
	 )).

haspreno(Cat) :-
    hdrug_util:hdrug_flag(parse_or_generate,PG),
    haspreno(PG,Cat).

haspreno(parse,Cat) :-
    Cat:haspre => no.
haspreno(generate,_).

haspreyes(Cat) :-
    hdrug_util:hdrug_flag(parse_or_generate,PG),
    haspreyes(PG,Cat).

haspreyes(parse,Cat) :-
    Cat:haspre => yes.
haspreyes(generate,_).


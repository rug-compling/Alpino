%%           -*-Mode: prolog;-*-

:- expects_dialect(sicstus).

:- discontiguous
    p/2,
    phrasal_subj_of_predicative/2,
    map_dep/5.

%% lexical types
%% these are thought of as types in an inheritance hierarchy.
%%
%% don't use these as templates for e.g. the arguments of a verb
%% in that case use the arg_.. templates. 

%% sign/2
%% the top of the lexical type hierarchy!

sign(Sign,Cat) :-
    Sign:dt =?> dt,
    Sign:dt:svp =?> [],
    Sign:dt:cat <?=?> Sign:ccat,
    Sign:ccat0 ==?> Cat,
    Sign:lex =?> yes,
    Sign:exs =?> [],
    Sign:mexs =?> [],
    Sign:cmods =?> [],
    Sign:mods <?=?> Sign:dt:mod,
    Sign:cpredms =?> [],
    Sign:predms <?=?> Sign:dt:predm,
    Sign:cdets =?> [],
    Sign:dets <?=?> Sign:dt:det,
    Sign:capps =?> [],
    Sign:apps <?=?> Sign:dt:app.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Punctuation %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

punct(Sign) :-
    Sign => punct,
    sign(Sign,punct).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% Particles %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

particle(Part,Sign) :-
    Sign => part,
    sign(Sign,part),
    Sign:part ==> Part,
    initialize_dt([],Sign).

num_na(Sign) :-
    Sign => num_na,
    sign(Sign,detp),
    initialize_dt([],Sign).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% max %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

max(Sign) :-
    Sign => root,
    Sign:needs_dip => no,
    Sign:tags => [],
    sign(Sign,max),
%    unify_mods(Sign),
    initialize_dt([],Sign).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Conjunctions %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conjunction(CJ,Form) :-
    CJ => conj,
    sign(CJ,vg),
    CJ:cform ==> Form,
    initialize_dt([],CJ).

left_conj(CJ,Right) :-
    CJ => lconj,
    sign(CJ,vg),
    initialize_dt([],CJ),
    CJ:needs_right_cform ==> Right.

right_conj(CJ,Form) :-
    conjunction(CJ,Form),
    CJ:left_conj => yes.

within_word_conjunct(Sign) :-
    Sign => within_word_conjunct,
    sign(Sign,_),
    initialize_dt([],Sign).


%% the idea is that words of the 'etc' category can
%% finish a coordination:
%% a , b , c and d
%% a , b , c etc.
%%
%% so 'etc' comes instead of the pair [conj,XP]

etc(Sign) :-
    Sign => etc,
    sign(Sign,vg),
    initialize_dt([],Sign).

complex_etc(Sign) :-
    Sign => complex_etc,
    sign(Sign,vg),
    initialize_dt([],Sign).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% tag %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tag(Sign) :-
    Sign => tag,
    Sign:adv => no,
    Sign:np => no,
    sign(Sign,advp),
    initialize_dt([],Sign).

adv_tag(Sign) :-
    Sign => tag,
    Sign:adv => yes,
    Sign:np => no,
    sign(Sign,advp),
    initialize_dt([],Sign).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% Nouns %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

noun(N) :-
    N => n,
    N:wh => nwh,
    N:subn => sub_noun,
    N:nform => norm,
    N:e_deps => [],
    N:pred => npred,
    N:amount => no,
    sign(N,np),
    initialize_dt([],N).

comp_noun(N,Type) :-
    noun(N0),
    add_comparative_to_exs(N0,N,Type).

iets_noun(N) :-
    N => iets_n,
    sign(N,np),
    initialize_dt([],N),
    N:aform => iets,
    N:wh => nwh,
    N:agr => sg,
    N:dt:num <=> N:agr.

iets_anders_noun(N) :-
    iets_noun(N0),
    overwrite(N0,N,aform,anders).

%% this was meant for
%% 'wie anders dan Jan heb je gezien?'
%% but it doesn't work yet, because np --> n rule requires wh=nwh
wh_iets_noun(N) :-
    iets_noun(N0),
    overwrite(N0,N,wh,ywh).

wh_iets_anders_noun(N) :-
    iets_anders_noun(N0),
    overwrite(N0,N,wh,ywh).

%% takes a noun to its right, but has regular agreement:
%% een zak aardappels
%% twee zakken aardappels
measure_noun(N) :-
    N => app_n,
    % nform inherited from argument "tientallen keren"
    N:amount => no,
    initialize_dt([],N),
    sign(N,np).

%% twee keer de omzet
np_measure_noun(N) :-
    N => app_np_mod,
    % nform inherited from argument "tientallen keren"
    initialize_dt([],N),
    sign(N,np).

%% het woord 'verzoening'
app_measure_noun(N) :-
    N => app_n_app,
    N:nform => norm,
    initialize_dt([],N),
    sign(N,np).

start_app_measure_noun(N) :-
    N => start_app_n_app,
    N:nform => norm,
    initialize_dt([],N),
    sign(N,np).

%% met de bijnaam 'de kromme'
np_app_measure_noun(N) :-
    N => app_np,
    N:nform => norm,
    initialize_dt([],N),
    sign(N,np).

%% begin januari; half december
tmp_app_noun(N) :-
    N => tmp_app_n,
    initialize_dt([],N),
    sign(N,advp).

verbal_arg_noun(N,VerbalArg) :-
    noun(N0),
    unify_except_l(N0,N,[exs,dt:vc]),
    N:exs <=> [VerbalArg],
    VerbalArg:slash => [],
    unify_mods(VerbalArg),
    instantiated_deprel(N,vc,VerbalArg).

dummy_subj(Subj) :-
    Subj => np,
    Subj:nform => none,
    Subj:agr => sg,
    Subj:prs => thi.

subject_verbal_arg_noun(N,VerbalArg) :-
    noun(N0),
    unify_except(N0,N,e_deps),
    N:e_deps <=> [VerbalArg],
    VerbalArg:slash => [],
    VerbalArg:e_deps => [],
    unify_mods(VerbalArg).

sbar_noun(N) :-
    Sbar => sbar,
    Sbar:ctype => (c_of;c_of_short;c_redrel;c_dat;c_als),
    Sbar:e_deps => [],
    verbal_arg_noun(N,Sbar).

dat_sbar_noun(N) :-
    Sbar => sbar,
    Sbar:ctype => c_dat,
    Sbar:e_deps => [],
    verbal_arg_noun(N,Sbar).

van_sbar_noun(N) :-
    Sbar => sbar,
    Sbar:ctype => c_van,
    Sbar:e_deps => [],
    verbal_arg_noun(N,Sbar).

vp_noun(N) :-
    no_subj_vp_arg(VP),
    verbal_arg_noun(N,VP).

subject_sbar_noun(N) :-
    Sbar => sbar,
    Sbar:ctype => (c_of;c_of_short;c_redrel;c_dat;c_dip),  % hij komt wel , was de gedachte
    Sbar:subj_nform => obl_het,
    subject_verbal_arg_noun(N,Sbar).

subject_sbar_no_het_noun(N) :-
    Sbar => sbar,
    Sbar:ctype => (c_of;c_of_short;c_redrel;c_dat;c_dip),  % hij komt wel , was de gedachte
    Sbar:subj_nform => opt_het,
    subject_verbal_arg_noun(N,Sbar).

subject_vp_noun(N) :-
    no_subj_vp_arg(VP),
    VP:subj_nform => obl_het,
    subject_verbal_arg_noun(N,VP).

deverbal_noun(V,N) :-
    N => v_noun,
    V => v,
    V:v_noun => yes,
    V:vform => inf,
    V:slash => [],
    V:e_deps => [],
    V:subj => np,
    V:subj:allows_drop => no,
    V:subj:dt => [],
    N:sc <=> V:sc,
    N:parts <=> V:parts,
    N:dt <=> V:dt,
    N:ccat0 ==> np,
    N:ccat <=> V:ccat,
    N:cmods <=> V:cmods,
    N:mods <=> V:mods,
    N:predms <=> V:predms,
    N:cpredms <=> V:cpredms,
    N:apps <=> V:apps,
    N:capps <=> V:capps,
    N:cdets <=> V:cdets,
    N:dets <=> V:dets,
    N:hstem <=> V:hstem,
    N:subn => (sub_def_verb;sub_indef_verb).

ge_deverbal_noun(V,N) :-
    deverbal_noun(V,N0),
    unify_except(N0,N,subn),
    N:subn => sub_noun.



pred_pp(Prep,subject_vp,N) :-
    subject_vp_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,subject_sbar,N) :-
    subject_sbar_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,subject_sbar_no_het,N) :-
    subject_sbar_no_het_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,vp,N) :-
    vp_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,sbar,N) :-
    sbar_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,measure,N) :-
    measure_noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp(Prep,N) :-
    noun(N0),
    unify_except(N0,N,pred),
    N:pred:predp ==> Prep.

pred_pp_pl_noun(Prep,N) :-
    pred_pp(Prep,N),
    N:agr => pl.

pred_pp_pl_noun(Prep,Sc,N) :-
    pred_pp(Sc,Prep,N),
    N:agr => pl.

pred_pp_noun(Prep,N) :-
    pred_pp(Prep,N),
    N:agr => sg.

pred_pp_noun(Prep,Sc,N) :-
    pred_pp(Prep,Sc,N),
    N:agr => sg.

post_n_n(Num) :-
    Num => post_n_n,
    sign(Num,np),
    initialize_dt([],Num).

enumeration(Num) :-
    Num => enumeration,
    sign(Num,np),
    initialize_dt([],Num).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%% proper names %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

proper_name(Type,PN) :-
    PN => pn,
    PN:neclass ==> Type,
    sign(PN,np),
    initialize_dt([],PN).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% pronouns %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pronoun(NP) :-
    NP => pron,
    NP:nform => norm,
    NP:subn => (sub_def_pron;sub_indef_pron),
    sign(NP,np),
    initialize_dt([],NP).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% np's %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% NB: lexical NP's never combine with a relative clause!

np(NP) :-
    NP => np,
    NP:redrel => no,
    NP:wh => nwh,
    NP:nform => norm,
    NP:e_deps => [],
    NP:case => ~gen,
    NP:pred => npred,
    NP:subn => sub_noun,
    NP:meas => no,
    NP:agr <=> NP:e_agr,
    sign(NP,np),
    initialize_dt([],NP),
    NP:dt:num <=> NP:agr.

%% "intrinsic" temporal NPs are only specified as tmp_np. They
%% are (temp;norm) since they can also be used in normal context
%% such as objects of prepositions or top nodes.
%% they start out as n since they can sometimes combine with
%% post-n modifiers (jongstleden, appositions; cdb/221 cdb/7027 cdb/296)
tmp_np(NP) :-
    noun(NP0),
    unify_except_l(NP0,NP,[nform,subn]),
    NP:subn => sub_tmp,
    NP:can_mod => yes,
    NP:meas => no,
%%    NP:hdet => nhdet,  % het is geen vijf voor twaalf (meer)
    NP:agr => sg&indef,
    NP:agr <=> NP:e_agr,
    NP:nform => (norm;temp).

year_np(NP) :-
    noun(NP0),
    unify_except_l(NP0,NP,[nform,subn]),
    NP:subn => sub_tmp,
    NP:meas => no,
%%    NP:hdet => nhdet,  % het is geen 1990 meer
    NP:agr => sg&indef,
    NP:agr <=> NP:e_agr,
    NP:nform => (norm;year).

%% *het* regent
%% *het* schijnt dat Jan komt
%% *het* waren kinderen die dat gedaan hebben
%% *het* 
het_noun(NP) :-
    np(NP0),
    overwrite(NP0,NP,nform,het_nform),
    NP:prs => thi.

het_noun(NP) :-
    cleft_het_noun(NP).

%% het zijn schurken
%% het zijn schurken die dat doen
%% ik was het
%% ik was het die ..
%% wie was het die daar liep?
%% het was een schurk die daar liep
cleft_het_noun(NP) :-
    np(NP0),
    overwrite(NP0,NP1,nform,cleft_het),
    NP1:prs => thi,
    add_rel_cleft_het(NP1,NP).

add_rel_cleft_het(N,N) :-
    N:cleft_has_rel => pl.
add_rel_cleft_het(N0,N) :-
    N0 => np,
    N0:exs <=> RestExs,
    N0:cmods <=> RestCmods,
    unify_except_l(N0,N,[cmods,exs]),
    N:exs <=> [Cat|RestExs],
    N:cmods <=> [CatDt|RestCmods],
    Cat => rel,
    Cat:relform => relform_fin,
    Cat:dt <=> CatDt,
    Cat:hstem ==> het,
    Cat:nform => norm,
    Cat:agr <=> N:agr.

%% de man *die* ik ontmoet heb
rel_pronoun(NP) :-
    np(NP0),
    overwrite(NP0,NP,wh,rwh),
    NP:wh_reltmploc => non_adv,
    NP:agr <=> NP:wh:relagr,
    NP:prs => thi,
    NP:hstem <=> NP:wh:relhstem.

%% hij heeft *zich* vergist
refl_pronoun(NP) :-
    np(NP0),
    overwrite(NP0,NP,nform,refl).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%% Determiners %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tmp_determiner(Sign) :-
    Sign => tmp_det,
    sign(Sign,detp),
    initialize_dt([],Sign).

determiner(D) :-
    D => det,
    sign(D,detp),
    hstem(D),
    D:sc => [],
    D:nform => norm,
    D:wh => nwh,
    D:subn => sub_det,
    D:neclass ==> none,
    initialize_dt([],D).

name_determiner(D) :-
    determiner(D0),
    unify_except(D0,D,neclass),
    D:neclass ==> 'MISC'.

name_determiner(Class,D) :-
    determiner(D0),
    unify_except(D0,D,neclass),
    D:neclass ==> Class.

gen_determiner(D) :-
    D => gen_det,
    initialize_dt([],D),
    sign(D,detp).

geen_determiner(D) :-
    %%    D:nsubn => ~sub_indef_verb & ~sub_def_verb,
    %% dat is geen doen
    %% we hebben er geen omkijken naar
    %% dat is toch geen hardlopen wat hij doet
    determiner(D).

comp_determiner(D,als) :-
    determiner(D0),
    add_comparative_to_exs(D0,D,als).

comp_determiner(D,dat) :-
    determiner(D0),
    add_dat_to_exs(D0,D).

comp_determiner(D,om) :-
    determiner(D0),
    add_om_to_exs(D0,D).

%% need to set wh:relagr?
wh_determiner(D) :-
    determiner(D0),
    overwrite(D0,D,wh,ywh),
    D:wh_reltmploc => non_adv.

wh_noq_determiner(D) :-
    determiner(D0),
    overwrite(D0,D,wh,ywh),
    D:wh => nq,
    D:wh_reltmploc => non_adv.

%% need to set wh:relagr?
wh_rel_determiner(D) :-
    determiner(D0),
    overwrite(D0,D,wh,rywh),
    D:wh_reltmploc => non_adv.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% Numerals %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pre_det_quant(NUM) :-
    NUM => pre_det_quant,
    sign(NUM,detp),
    initialize_dt([],NUM).

num(NUM) :-
    NUM => num,
    sign(NUM,detp),
    initialize_dt([],NUM).

hoofd_num(NUM) :-
    num(NUM).

rang_num(NUM) :-
    adjective(NUM0),
    NUM0:aform => (attr;nattr),    % we staan derde / de derde overwinning
    NUM0:avform => avform_ap,
    NUM0:can_nominalize => yes,
    NUM0:can_marked_attr => no,
    NUM0:can_postn => no,
    NUM0:tmploc => ntmploc,
    NUM0:adv => nadv,
    NUM0:cform => rang,
    (   NUM0 = NUM
    ;   subject_sbar_adjective(NUM0,NUM,Sbar),
	Sbar:subj_nform => obl_het
    ).

wh_rang_num(NUM) :-
    rang_num(NUM0),
    unify_except(NUM0,NUM,wh),
    NUM:wh => ywh.

adj_number(NUM) :-
    num(NUM),
    NUM:app => no.

score_cat(Sign) :-
    Sign => score_cat,
    sign(Sign,np),
    initialize_dt([],Sign).

pre_np_adverb(Sign) :-
    Sign => pre_np_adv,
    sign(Sign,advp),
    initialize_dt([],Sign).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% adjectives %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

adjective(A) :-
    A0 => a,
    sign(A0,CAT),
    hstem(A0),
    A0:e_deps => [],
    A0:slash => [],
    A0:wh => nwh,
    A0:deverbal => no,
    A0:aform => ~only_n,
    A:can_postv => no,
    initialize_dt([obcomp,me],A0),
    opt_add_compar_to_exs_if_cform(A0,A),
    opt_add_compar_to_obj_if_cform(A),
    adjective_cat(A,CAT).

adjective_cat(A,ppres) :-
    A:avform => avform_ppres.
adjective_cat(A,ppart) :-
    A:avform => avform_ppart.
adjective_cat(A,ap) :-
    A:avform => ~avform_ppres & ~avform_ppart.

nominalized_adjective(A) :-
    A0 => a,
    A0:avform => avform_ap,
    adjective(A0),
    nominalized_adjective(A0,A).

nominalized_adjective(A0,A) :-
    A0 => a,
    A0:avform => avform_ap,
    unify_except(A0,A,aform),
    A0:adv => nadv,
    A0:cform => base,   
    A:aform => only_n.

nominalized_adjective_sg(A) :-
    nominalized_adjective(A),
    A:agr => sg.

nominalized_adjective_pl(A) :-
    nominalized_adjective(A),
    A:agr => pl.

nominalized_super_adjective_sg(A) :-
    nominalized_adjective(A0),
    A:cform => super,
    unify_except(A0,A,cform),
    A:agr => sg.

nominalized_super_adjective_pl(A) :-
    nominalized_adjective(A0),
    unify_except(A0,A,cform),
    A:cform => super,
    A:agr => pl.

%% anderen dan ik
%% ouderen dan 50 jaar
%% * 3 jaar ouderen dan ik
%% but: de iets ouderen mogen vertrekken
nominalized_compar_adjective(A) :-
    A0 => a,
    unify_except(A0,A,aform),
    A0:adv => nadv,
    A0:cform => compar,   
    A:aform => only_n,
    A:avform => avform_ap,
%    A0:sc => [],          
    adjective(A0).

nominalized_compar_adjective_pl(A) :-
    nominalized_compar_adjective(A),
    A:agr => pl.

nominalized_compar_adjective_sg(A) :-
    nominalized_compar_adjective(A),
    A:agr => sg.

wh_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    overwrite(A0,A,wh,ywh),
    A:avform => avform_ap,
    A:cform => base,
    A:adv => yadv,
    A:aform => nattr,
    A:tmploc => ntmploc,
    A:tmploc <=> A:wh_reltmploc.

als_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    unify_except(A0,A1,can_postv),
    A1:can_postv => yes,
    add_als_to_exs(A1,A2),
    add_me_zoveel(A2,A).

add_me_zoveel(A,A).
add_me_zoveel(A2,A) :-
    A2:dt:fwrd:lexical <=> zoveel,
    add_me(A2,A).    

e_als_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    unify_except(A0,A1,can_postv),
    A1:can_postv => yes,
    add_e_als_to_exs(A1,A).

sbar_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    add_dat_to_exs(A0,A).

me_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    opt_add_me(A0,A).

vp_om_me_adjective(A) :-
    me_adjective(A0),
    add_om_to_exs(A0,A).

vp_adjective(A) :-
    A0 => a,
    A0:sc => [],
    A0:exs => [],
    A0:avform => avform_ap,
    adjective(A0),
    add_omte_to_exs(A0,A).

opt_add_me(A,A).
opt_add_me(A0,A) :-
    add_me(A0,A).

add_me(A0,A) :-
    unify_except_l(A0,A,[sc,me_adj,dt:me]),
    A:me_adj => yes,
    A:sc <=> [NP|Asc],
    A0:sc <=> Asc,
    adj_np_me_arg(NP),
    NP:subn => ~sub_def_verb & ~sub_indef_adj & ~sub_def_adj
             & ~sub_rang
             & ~sub_def_pron & ~sub_indef_pron & ~sub_det,
                                % veel teveel ==> me, because
                                % it is me in [veel te] veel...
    NP:exs => [],
    instantiated_deprel(A,me,NP).


%% there are 2x2 types of adjectives that subcategorize for
%% a sentence-like argument.
%% The sentence is either a VP or an SBAR.
%% In addition, the complement is selected `internally' or
%% `externally'. In the latter case, the complement is not
%% selected inside the ap, but inherited by a dominating verb
%% such as copulas - a special 'het' dummy subject is then
%% required.
%% bang: selects sbar internally
%% leuk: selects sbar externally
%%  dat Jan bang dat hij moet komen zou zijn
%%  dat Jan bang zou zijn dat hij moet komen
%% *dat hij moet komen zou Jan bang zijn
%% *dat het bang zou zijn dat hij moet komen
%% *dat hij moet komen zou het bang zijn
%%
%% *dat Jan leuk dat hij moet komen zou zijn
%% *dat Jan leuk zou zijn dat hij moet komen
%% *dat hij moet komen zou Jan leuk moeten zijn
%%  dat het leuk zou zijn dat hij moet komen
%%  dat hij moet komen zou leuk zijn
%%
%% NB
%% in this respect, nouns that subcategorize for an sbar function
%% like external adjectives:
%% het is een feit dat hij komt
%% dat hij komt is een feit
%% *het is een auto dat hij komt

verbal_arg_adjective(A,Sbar) :-
    A0 => a,
    A0:aform => nattr,
    adjective(A0),
    unify_except_l(A0,A,[exs,dt:vc]),
    A0:exs <=> Exs0,
    A:exs <=> Exs,
    Sbar:slash => [],
    unify_mods(Sbar),
    lists:select(Sbar,Exs,Exs0),
    instantiated_deprel(A,vc,Sbar).

object_sbar_adjective(A) :-
    verbal_arg_adjective(A,Sbar),
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:ctype => (c_dat;c_of_short;c_of;c_redrel).
				% ik ben bang dat je komt
				% ik ben benieuwd of je komt
				% ik ben benieuwd waar je woont
van_sbar_adjective(A) :-
    verbal_arg_adjective(A,Sbar),
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:ctype => c_van.

object_vp_adjective(A) :-
    no_subj_vp_arg(Sinf),
    verbal_arg_adjective(A,Sinf).

% er_pp_vp_adjective
% er_pp_sbar_adjective
% ik ben er trots op dat hij komt
% ik ben er trots op bij de Stoters te horen

er_pp_vp_adjective(Prep,A) :-
    no_subj_vp_arg(VP),
    er_pp_adjective(Prep,A,VP).

er_pp_sbar_adjective(Prep,A) :-
    SBAR => sbar,
    SBAR:e_deps => [],
    SBAR:ctype => (c_dat;c_redrel;c_of),
    er_pp_adjective(Prep,A,SBAR).

er_pp_adjective(Prep,A,Sbar) :-
    A0 => a,
    A0:aform => nattr,
    adjective(A0),
    unify_except_l(A0,A,[exs,sc,slash,dt:pc]),
    A0:exs <=> Exs0,
    A:exs <=> Exs,
    lists:select(Sbar,Exs,Exs0),
    Sbar:slash => [], 	
    unify_mods(Sbar),
    pp_pc_arg(PP0,Prep),
    unify_except(PP0,PP,pp_role),
    PP:pp_role => pp_pobj1,
    PP:pp_er => yes,
    PP:sel => ~to_topic,
    PP:wh => nwh,   % * waar ben je trots op dat je bij ons hoort.
    A0:sc => [],
    A:sc <=> [PP],
    A0:slash => [],
    A:slash <=> PP:slash,
    (   PP:slash <=> []
    ;   PP:slash <=> [NP],
        NP => np,
        NP:sel => to_left    % *er/*daar ben ik trots op dat je arriveert
    ),
    instantiated_deprel(A,pc,PP),
    instantiated_deprel(PP,vc,Sbar).

subject_sbar_adjective(A) :-
    subject_sbar_adjective(A,Sbar),
    Sbar:subj_nform => obl_het.

subject_sbar_no_het_adjective(Sign) :-
    subject_sbar_adjective(Sign,Sbar),
    Sbar:subj_nform => opt_het.

pp_subject_sbar_adjective(Prep,A) :-
    subject_sbar_adjective(A0),
    pp_pc_arg(PP,Prep),
    unify_except_l(A0,A,[sc,slash,exs,dt:pc]),
    instantiated_deprel(A,pc,PP),
    select_adjective_arg(A0,A,PP).

pp_subject_sbar_no_het_adjective(Prep,A) :-
    subject_sbar_no_het_adjective(A0),
    pp_pc_arg(PP,Prep),
    unify_except_l(A0,A,[sc,slash,exs,dt:pc]),
    instantiated_deprel(A,pc,PP),
    select_adjective_arg(A0,A,PP).

so_pp_subject_sbar_adjective(Prep,A) :-
    subject_sbar_adjective(A0),
    so_pp_arg(PP,Prep),
    unify_except_l(A0,A,[sc,slash,exs,dt:obj2]),
    instantiated_deprel(A,obj2,PP),
    select_adjective_arg(A0,A,PP).

so_np_subject_sbar_adjective(A) :-
    subject_sbar_adjective(A0),
    dat_np_arg_of_adj(PP),
    unify_except_l(A0,A,[sc,slash,exs,dt:obj2]),
    instantiated_deprel(A,obj2,PP),
    select_adjective_arg(A0,A,PP).

so_np_subject_vp_adjective(A) :-
    subject_vp_adjective(A0),
    dat_np_arg_of_adj(PP),
    unify_except_l(A0,A,[sc,slash,exs,dt:obj2]),
    instantiated_deprel(A,obj2,PP),
    select_adjective_arg(A0,A,PP).

so_pp_subject_sbar_no_het_adjective(Prep,A) :-
    subject_sbar_no_het_adjective(A0),
    so_pp_arg(PP,Prep),
    unify_except_l(A0,A,[sc,slash,exs,dt:obj2]),
    instantiated_deprel(A,obj2,PP),
    select_adjective_arg(A0,A,PP).

subject_sbar_adjective(A,Sbar) :-
    A0 => a,
    A0:aform => (attr;nattr;iets),
    A0:me_adj => no, % ...
    adjective(A0),
    subject_sbar_adjective(A0,A,Sbar).

subject_sbar_adjective(A0,A,Sbar) :-
    unify_except(A,A0,e_deps),
    A0:e_deps => [],
    A:e_deps <=> [Sbar],
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:ctype => (c_of;c_of_short;c_dat;c_redrel),
				% het is fijn dat je komt
				% het is twijfelachtig of je komt
				% het is onzeker wie er komt
                                % het is nog onzeker met wie
				% * ik kom , is leuk
    Sbar:slash => [], 	
    unify_mods(Sbar).

subject_vp_adjective(Sign) :-
    subject_vp_adjective(Sign,Sbar),
    Sbar => vp, % spur.amb.
    Sbar:subj_nform => obl_het.

subject_vp_no_het_adjective(Sign) :-
    subject_vp_adjective(Sign,Sbar),
    Sbar => vp, % spur.amb.
    Sbar:subj_nform => opt_het.

subject_vp_sbar_no_het_adjective(A) :-
    A0 => a,
    A0:aform => (attr;nattr;iets),
    A0:me_adj => no, % ...
    adjective(A0),
    vp_adj_exs(A0,A1),
    subject_sbar_adjective(A1,A,Sbar),
    Sbar:subj_nform => opt_het.

subject_vp_sbar_adjective(A) :-
    A0 => a,
    A0:aform => (attr;nattr;iets),
    A0:me_adj => no, % ...
    adjective(A0),
    vp_adj_exs(A0,A1),
    subject_sbar_adjective(A1,A,Sbar),
    Sbar:subj_nform => obl_het.

subject_vp_adjective(A,Inf) :-
    A0 => a,
    A0:aform => (attr;nattr;iets),
    A0:me_adj => no, % ...
    adjective(A0),
    (  vp_adj_e_deps(A0,A,Inf)
    ;  vp_adj_exs(A0,A)
    ).

vp_adj_e_deps(A0,A,Inf) :-
    unify_except(A,A0,e_deps),
    A0:e_deps => [],
    A:e_deps <=> [Inf],
    no_subj_vp_arg(Inf),
    Inf:slash => [].

vp_adj_exs(A0,A) :-
    A0:aform => ~iets,
    A0:aform => ~attr,
    unify_except_l(A0,A,[dt:vc,exs]),
    A0:exs <=> Exs0,
    A:exs <=> Exs,
    VP => rel,
    VP:relform => relform_inf,
    VP:tmploc => non_adv,
    unify_mods(VP),
    lists:select(VP,Exs,Exs0),
    instantiated_deprel(A,vc,VP).

np_adjective(A) :-
    A0 => a,
    adjective(A0),
    np_adjective(A0,A).

%% ik ben die berichten beu
np_adjective(A0,A) :-
    A0 => a, A => a,
    A0:aform => nattr,
    A0:e_deps => [],
    unify_except_l(A0,A,[dt:obj1,e_deps]),
    np_arg(NP),
    instantiated_deprel(A,obj1,NP),
    A:e_deps <=> [NP].

%% het leven beu schoot hij zich door de kop
np_adjective(A0,A) :-
    A0 => a, A => a,
    A0:aform => nattr,
    A0:sc <=> Sc0,
    unify_except_l(A0,A,[dt:obj1,sc]),
    np_arg(NP),
    instantiated_deprel(A,obj1,NP),
    lists:append(Sc0,[NP],Sc),
    A:sc <=> Sc.

het_np_adjective(A) :-
    A0 => a,
    adjective(A0),
    het_np_adjective(A0,A).

het_np_adjective(A0,A) :-
    A0 => a, A => a,
    A0:aform => nattr,
    A0:e_deps => [],
    unify_except_l(A0,A,[dt:obj1,e_deps]),
    het_np_arg(NP),
    instantiated_deprel(A,obj1,NP),
    A:e_deps <=> [NP].

%% ik ben het beu dat je nooit komt
%% ik ben het beu om altijd jouw rotzooi te moeten opruimen

clause_np_adjective(A) :-
    A0 => a,
    adjective(A0),
    clause_np_adjective(A0,A).

clause_np_adjective(A0,A) :-
    A0:aform => nattr,
    unify_except_l(A0,A1,[exs,dt:vc]),
    A0:exs <=> Exs0,
    A1:exs <=> Exs,
    (  Sbar => sbar, Sbar:ctype => c_dat, Sbar:e_deps => []
    ;  no_subj_vp_arg(Sbar)
    ),
    Sbar:slash => [],
    unify_mods(Sbar),
    lists:select(Sbar,Exs,Exs0),
    instantiated_deprel(A1,vc,Sbar),
    unify_except_l(A1,A,[e_deps,dt:pobj1]),
    A1:e_deps => [],
    het_np_arg(NP),
    NP:sel => to_left,
    instantiated_deprel(A,pobj1,NP),
    A:e_deps <=> [NP].

pp_adjective(Prep,A) :-
    pp_pc_arg(PP,Prep),
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,dt:pc]),
    instantiated_deprel(A,pc,PP),
    select_adjective_arg(A0,A,PP).

ld_pp_adjective(A) :-
    pp_ld_arg(PP),
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,dt:ld]),
    instantiated_deprel(A,ld,PP),
    select_adjective_arg(A0,A,PP).

ld_pp_adjective(Prep,A) :-
    pp_ld_arg(PP,Prep),
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,dt:ld]),
    instantiated_deprel(A,ld,PP),
    select_adjective_arg(A0,A,PP).

mod_pp_adjective(Prep,A) :-
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,cmods]),
    A:cmods <=> [MOD|CMODS0],
    A0:cmods <=> CMODS0,
    PP:dt <=> MOD,
    select_adjective_arg(A0,A,PP).

so_pp_adjective(Prep,A) :-
    so_pp_arg(PP,Prep),
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,dt:obj2]),
    instantiated_deprel(A,obj2,PP),
    select_adjective_arg(A0,A,PP).

als_pred_adjective(A) :-
    pred_arg(PREDC),
    PREDC:pcat => als_pred,
    PREDC:slash => [],
    PREDC:e_deps => [],
    PREDC:exs => [],
    PREDC:wh => nwh,
    adjective(A0),
    unify_except_l(A0,A,[sc,slash,exs,dt:predc]),
    instantiated_deprel(A,predc,PREDC),
    select_adjective_arg(A0,A,PREDC).

transitive_adjective(A) :-
    acc_np_arg(Obj),
    Obj:subn => (sub_name;sub_noun;sub_tmp;sub_indef_pron;sub_def_pron;
                    sub_det;sub_veel;sub_def_verb),
    adjective(A0),
    unify_except_l(A0,A,[sc,dt:obj1]),
    A0:sc => [],
    instantiated_deprel(A,obj1,Obj),
    A:sc <=> [Obj].

np_ld_pp_adjective(A) :-
    acc_np_arg(Obj),
    Obj:subn => (sub_name;sub_noun;sub_tmp;sub_indef_pron;sub_def_pron;
                    sub_det;sub_veel;sub_def_verb),
    ld_pp_adjective(A0),
    unify_except_l(A0,A,[sc,dt:obj1]),
    A0:sc <=> SC0,
    instantiated_deprel(A,obj1,Obj),
    A:sc <=> SC,
    lists:append(SC0,[Obj],SC).

%% de ons achterna lopende meisjes
%% todo:
%% ok: ik loop het bos in
%%  *: ik loop dat     in  Forbid sub_det?
ld_transitive_adjective(A) :-
    acc_np_arg(Obj),
    Obj:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;
                    sub_indef_pron;sub_det;sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:ld]),
    instantiated_deprel(A,ld,Obj),
    A:sc <=> [Obj].

refl_adjective(A) :-
    adjective(A0),
    add_refl_to_adjective(A0,A).

pred_adjective(A) :-
    pred_adjective(A,_).

pred_adjective(A,Obj) :-
    pred_arg(Obj),
    Obj:slash => [],
    Obj:e_deps => [],
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[dt:predc,sc]),
    instantiated_deprel(A,predc,Obj),
    A:sc <=> [Obj].

ap_pred_adjective(A) :-
    pred_adjective(A,Obj),
    Obj:pcat => ap_pred.

ap_pred_adjective(T,A) :-
    pred_adjective(A,Obj),
    Obj:pcat => ap_pred,
    Obj:hstem ==> T.

pp_pred_adjective(A) :-
    pred_adjective(A,Obj),
    Obj:pcat => pp_pred.

pp_pred_adjective(Aan,Slag,A) :-
    pred_adjective(A,Obj),
    Obj:hstem ==> Aan,
    Obj:nhstem ==> Slag,
    Obj:pcat => pp_pred.

nonp_pred_adjective(A) :-
    pred_adjective(A,Obj),
    Obj:pcat => ~np_pred.

pred_np_adjective(A) :-
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    acc_np_arg(Obj),
    Obj:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;
                    sub_indef_pron;sub_det;sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:predc,dt:obj1]),
    instantiated_deprel(A,predc,PRED),
    instantiated_deprel(A,obj1,Obj),
    A:sc <=> [PRED,Obj].

pred_so_np_adjective(A) :-
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    dat_np_arg_of_adj(Obj),
    Obj:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;
                    sub_indef_pron;sub_det;sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:predc,dt:obj2]),
    instantiated_deprel(A,predc,PRED),
    instantiated_deprel(A,obj2,Obj),
    A:sc <=> [PRED,Obj].

%% zich superieur wanende
pred_refl_adjective(A) :-
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    refl_np_arg(Obj),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:predc,dt:se]),
    instantiated_deprel(A,predc,PRED),
    instantiated_deprel(A,se,Obj),
    A:sc <=> [PRED,Obj].

np_np_adjective(A) :-
    dat_np_arg_of_adj(Obj2),
    Obj2:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;sub_indef_pron;sub_det;
                     sub_veel;sub_def_verb),
    acc_np_arg(Obj1),
    Obj2:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;sub_indef_pron;sub_det;
                     sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:obj2,dt:obj1]),
    instantiated_deprel(A,obj2,Obj2),
    instantiated_deprel(A,obj1,Obj1),
    A:sc <=> [Obj1,Obj2].

np_ld_adjective(A) :-
    dat_np_arg_of_adj(Obj2),
    Obj2:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;sub_indef_pron;sub_det;
                     sub_veel;sub_def_verb),
    acc_np_arg(Obj1),
    Obj2:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;sub_indef_pron;sub_det;
                     sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:obj1,dt:ld]),
    instantiated_deprel(A,obj1,Obj2),
    instantiated_deprel(A,ld,Obj1),
    A:sc <=> [Obj1,Obj2].

refl_ld_adjective(A) :-
    refl_np_arg(Obj2),
    acc_np_arg(Obj1),
    Obj2:subn => (sub_name;sub_noun;sub_tmp;sub_def_pron;sub_indef_pron;sub_det;
                     sub_veel;sub_def_verb),
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:se,dt:ld]),
    instantiated_deprel(A,se,Obj2),
    instantiated_deprel(A,ld,Obj1),
    A:sc <=> [Obj1,Obj2].

refl_np_adjective(A) :-
    transitive_adjective(A0),
    add_refl_to_adjective(A0,A).

add_refl_to_adjective(A0,A) :-
    A0 => a,
    A => a,
    refl_np_arg(Obj2),
    (   unify_except_l(A0,A,[sc,dt:se]),
	A0:sc <=> Sc0,
	A:sc <=> Sc,
	alpino_wappend:wselect(Obj2,Sc,Sc0)
    ;   unify_except_l(A0,A,[e_deps,dt:se]),
	A0:e_deps <=> Sc0,
	A:e_deps <=> Sc,
	alpino_wappend:wselect(Obj2,Sc,Sc0),
	A:aform => nattr
    ),
    instantiated_deprel(A,se,Obj2).


%% hij is zich [VP-MODIFIERS] {bewust van deze zaken
refl_pp_adjective(Prep,A) :-
    pp_adjective(Prep,A0),
    add_refl_to_adjective(A0,A).

refl_ld_pp_adjective(A) :-
    ld_pp_adjective(A0),
    add_refl_to_adjective(A0,A).

refl_er_pp_sbar_adjective(Prep,A) :-
    er_pp_sbar_adjective(Prep,A0),
    add_refl_to_adjective(A0,A).

refl_er_pp_vp_adjective(Prep,A) :-
    er_pp_vp_adjective(Prep,A0),
    add_refl_to_adjective(A0,A).

refl_sbar_adjective(A) :-
    object_sbar_adjective(A0),
    add_refl_to_adjective(A0,A).

refl_vp_adjective(A) :-
    object_vp_adjective(A0),
    add_refl_to_adjective(A0,A).

%% de ons aanbevolen tandarts
so_np_adjective(A) :-
    dat_np_arg_of_adj(Obj2),
    adjective(A0),
    unify_except_l(A0,A,[sc,dt:obj2]),
    A0:sc => [],
    instantiated_deprel(A,obj2,Obj2),
    A:sc <=> [Obj2].

fixed_adjective(Deps,A) :-
    adjective(A0),
    map_deps_list(Deps,Deps2,[],A0,A1),
    a_dependents(A1,A,Deps2).

part_adjective(Part,A) :-
    adjective(A0),
    Obj => part,
    Obj:part ==> Part,
    unify_mods(Obj),
    unify_except(A0,A1,sc),
    add_svp(A1,A,Obj),
    A0:sc => [],
    A:sc <=> [Obj].

part_adjective(Part,Subcat,A) :-
    adjective_sc(Subcat,A0),
    Obj => part,
    Obj:part ==> Part,
    unify_mods(Obj),
    unify_except(A0,A1,sc),
    add_svp(A1,A,Obj),
    A0:sc <=> Sc,
    A:sc <=> [Obj|Sc].

%% de voor muizen bange kinderen
%% dat hij [ voor muizen erg bang ] is
%% dat hij [ erg bang voor muizen ] is
%% dat hij daar_i [ erg bang voor_i ] is
%% allows: * dat hij daar_i altijd [ voor_i erg bang ] is
%%%
%%% TODO: disallow "er" to be topicalized
%%% *er is hij zich van bewust
select_adjective_arg(A0,A,PP) :-
    A0:sc => [],
    A:sc <=> [PP],
    A0:slash <=> Slash0,
    if_defined(PP:slash,Slash1,[]),
    A:slash <=> Slash,
    alpino_wappend:wappend_atmost1(Slash0,Slash1,Slash),
    A0:exs <=> A:exs.

%% de maatregelen waartoe wij verpicht zijn
%% tot deze maatregelen zijn wij juridisch verplicht
%% no slash inh: * voor zijn wij daar bang
select_adjective_arg(A0,A,PP) :-
    A:aform => nattr,
    A:sc <=> A0:sc,
    A:exs <=> A0:exs,
    A0:slash => [],
    A:slash <=> [PP].

%% dat wij bang zijn voor muizen
%% no slash inh: * dat wij daar bang zijn voor
select_adjective_arg(A0,A,PP) :-
    A:aform => nattr,
    A:slash <=> A0:slash,
    A:sc <=> A0:sc,
    A0:exs <=> Exs0,
    A:exs <=> Exs,
    lists:select(PP,Exs,Exs0).

np_me_adjective(A) :-
    adjective(A0),
    np_me_adjective(A0,A).

np_me_adjective(A0,A) :-
    unify_except_l(A0,A,[sc,me_adj,dt:me]),
    A:me_adj => yes,
    A0:sc <=> SC,
    A:sc <=> [NP|SC],
    adj_np_me_arg(NP),
    NP:exs => [],
    instantiated_deprel(A,me,NP).

subject_sbar_np_me_adjective(A) :-
    np_me_adjective(A0),
    unify_except(A,A0,e_deps),
    A0:e_deps => [],
    A:e_deps <=> [Sbar],
    Sbar => sbar,
    Sbar:ctype => c_dat,   % het is 3 weken geleden dat/*of/*wanneer je kwam
    Sbar:e_deps => [],
    Sbar:slash => [], 	
    Sbar:subj_nform => opt_het,
    unify_mods(Sbar).

subject_sbar_np_adjective(A) :-
    np_obj1_adjective(A0),
    unify_except(A,A0,e_deps),
    A0:e_deps => [],
    A:e_deps <=> [Sbar],
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:ctype => c_dat,   % het is 3 weken geleden dat/*of/*wanneer je kwam
    Sbar:slash => [], 	
    Sbar:subj_nform => opt_het,
    unify_mods(Sbar).

subject_vp_np_adjective(A) :-
    np_obj1_adjective(A0),
    unify_except(A,A0,e_deps),
    A0:e_deps => [],
    A:e_deps <=> [Sbar],
    no_subj_vp_arg(Sbar),
    Sbar:subj_nform => opt_het,
    Sbar:slash => [].

np_obj1_adjective(A) :-
    adjective(A0),
    np_obj1_adjective(A0,A).

np_obj1_adjective(A0,A) :-
    unify_except_l(A0,A,[sc,dt:obj1]),
    A0:sc <=> SC,
    A:sc <=> [NP|SC],
    adj_np_me_arg(NP),
    NP:exs => [],
    instantiated_deprel(A,obj1,NP).

np_obj1_adjective(A0,A) :-
    unify_except_l(A0,A,[slash,dt:obj1]),
    A0:slash => [],
    A:slash <=> [NP],  
    adj_np_me_arg(NP),
    instantiated_deprel(A,obj1,NP).

aux_psp_hebben_adjective(A) :-
    adjective(A0),
    A0:sc => [],
    unify_except_l(A0,A,[sc,dt:vc]),
    A:sc <=> [PSP|Tail],
    PSP => vb,
    PSP:sc <=> Tail,
    PSP:slash => [],
    PSP:parts => [],
    PSP:vform => psp,
    PSP:vslash => [],
    PSP:e_deps => [],
    unify_mods(PSP),
    PSP:hebben_zijn => hebben,
    instantiated_deprel(A,vc,PSP).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% Complementizers %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

compp(Sign) :-
    Sign => sbar,
    sign(Sign,cp),
    Sign:wh => nwh,
    Sign:slash => [],
    Sign:tags => [],
    initialize_dt([],Sign).

compp_mod(Sign) :-
    compp(Sign),
    Sign:ctype => c_mod.

comp(C,Cat) :-
    C => comp,
    initialize_dt([],C),
    sign(C,Cat),
%    overwrite(C0,C,dt:mod,[]),  % "of je komt en vooral wanneer je komt"
    C:sc <=> [XP],
    if_defined(XP:tags,Tags,[]),
    C:tags <=> Tags,
    if_defined(XP:e_deps,Edeps,[]),
    C:e_deps <=> Edeps,
    if_defined(XP:wh,WH,NWH),
    NWH => nwh,
    C:wh <=> WH,
    unify_mods(XP).

%% "we gaan door [sbar al [imp  kost het ons een vermogen ]]"
%% al: complementizer selecting for inverted sentence
%%
%% weird: doesn't seem to want to be used in topic position:
%% * al kost het ons een vermogen gaan we door
%%
%% although you can put it in first position if the remainder is inverted too:
%% al is de leugen nog zo snel de waarheid achterhaalt hem wel
al_complementizer(C) :-
    C => comp,
    C:slash => [],
    C:sc <=> [IMP],
    C:ctype => c_mod,
    C:wh => nwh,
    IMP:slash => [],
    IMP => sv1,
    comp(C,cp).

inf_vpx_comp(C,Cat) :-
    C => comp,
    C:sc <=> [VP],
    C:wh => nwh,
    VP:slash <=> C:slash,
    VP => vpx,
    VP:vform => te,
    VP:subj => np,
    VP:subj:nform => norm,
    VP:e_deps => [],
    comp(C,Cat).	

%% normal case
vp_comp(C) :-
    C => comp,
    C:wh => nwh,
    VP => vp,
    VP:vform => fin,
    C:sc <=> [VP],
    VP:e_deps => [],
    %% complementizers inherit slash elements of VP
    %% but never nominative non-wh NP's!!
    % * hij wordt gezegd dat komt
    % ? piet denk ik dat komt
    % wie denk je dat er komt
    C:slash <=> VP:slash,
    (   C:slash <=> []
    ;   C:slash <=> [CAT],
        (   CAT => np,
            CAT:wh => nwh,
            CAT:case => ~nom
        ;   CAT => np,
            CAT:wh => ywh
        ;   CAT /=> np
        )
    ),
    comp(C,cp).

datti_complementizer(C) :-
    C => comp,
    C:wh => nwh,
    VP => vp,
    VP:vform => fin,
    C:sc <=> [VP],
    VP:e_deps => [],
    C:slash => [],
    VP:slash <=> [NP],
    NP:wh => nwh,
    NP:case => nom,
    NP:prs => thi,
    comp(C,cp).

xp_complementizer(C,XP) :-
    C => comp,
    C:ctype => c_mod,
    C:sc <=> [XP],
    XP:slash =?> [],
    unify_mods(XP),
    if_defined(XP:wh,WH,NWH),
    NWH => nwh,
    C:wh <=> WH,
    comp(C,cp).

pp_complementizer(C) :-
    ARG => pp,
    ARG:pp_role => pp_obj1,
    ARG:nnform => ~refl,
    xp_complementizer(C,ARG).

a_complementizer(C) :-
    ARG => a,
    xp_complementizer(C,ARG).

adv_complementizer(C) :-
    ARG => adv,
    ARG:subadv => subadv_adv,
    xp_complementizer(C,ARG).

np_complementizer(C) :-
    ARG => np,
    xp_complementizer(C0,ARG),
    unify_except(C0,C,ctype),
    C:ctype => (c_mod;c_mod_np).

%% hoewel
complementizer(C) :-
    vp_comp(C),
    C:slash => [],
    C:ctype => c_mod.

%% zoals: special, because it appears to 'consume' slashed sbar of
%% vp argument:
%% [[zoals ik zei/dacht/hoopte/..] werd Feyenoord kampioen]
%% TODO: 'het' appears, unexpectedly:
%% 'zij speelden, zoals het een kampioen betaamt'
%%
%% also: een man zoals ik (nominative)
zoals_complementizer(C) :-
    C => comp,
    C:slash => [],
    C:wh => nwh,
    C:sc <=> [ComparativeArg],
    C:ctype => (c_compare;c_adv;c_compare_np;c_mod),
    comp(C,cp),
    unify_mods(ComparativeArg),
    ComparativeArg:wh =?> nwh,
    (   ComparativeArg => adv,                    % zoals gisteren
        ComparativeArg:subadv => subadv_adv
    ;   ComparativeArg => np                      % een man zoals Piet
    ;   ComparativeArg => pp                      % zoals in Amsterdam
    ;   ComparativeArg => a                       % zoals genoegzaam bekend ...
    ;   ComparativeArg => vp,                     %  zoals ik al dacht ...
        comparative_arg(ComparativeArg),
        ComparativeArg:vform => fin               %  een gesprek zoals ik dat voer
                                                  %  hij is zoals hij is
    ;   ComparativeArg => vpx,                    % zoals door ons al voorspeld ..
        ComparativeArg:slash <=> [SBAR],
        SBAR => sbar,
        SBAR:ctype => c_none,
        SBAR:dt => [],
	SBAR:e_deps => [],
        ComparativeArg:vform => (psp;te)
    ).

als_complementizer(C) :-
    C => comp,
    C:slash => [],
    C:sc <=> [ComparativeArg],
    C:ctype => (c_als;c_adv;c_compare_np;c_mod),
    % +wh: "als wie ga jij naar het carnaval?
    comp(C,cp),
    unify_mods(ComparativeArg),
    (   comparative_arg(ComparativeArg),
        (   ComparativeArg => adv, % als gisteren
            ComparativeArg:wh => nwh,
            ComparativeArg:subadv => subadv_adv,
            C:wh => nwh,
            C:ctype => (c_adv;c_compare_np;c_mod)
        ;   ComparativeArg => np % een man als Piet
                                 % als wie
        ;   ComparativeArg => pp, % als in Amsterdam
            ComparativeArg:wh => nwh,
            C:wh => nwh,
            C:ctype => ~c_als
        ;   ComparativeArg => a % als genoegzaam bekend ...
                                % als hoe belangrijk beschouw jij hem?
        ;   ComparativeArg => vp,
            C:wh => nwh,
            ComparativeArg:slash => [],
            C:ctype => c_mod,
            ComparativeArg:vform => (om;psp;fin)
        )
    ;				% bescheiden als we zijn
	                        % todo: should be PADV!
	ComparativeArg => vp,
	C:wh => nwh,
	C:ctype => c_compare_np,
	ComparativeArg:slash <=> [PRED],
	PRED => pred,
	PRED:e_deps => [],
	PRED:dt => [],
	ComparativeArg:vform => fin
    ;   ComparativeArg => sv1,
        C:ctype => ~c_adv,
        C:wh => nwh,
        ComparativeArg:iexs => [],
        ComparativeArg:imexs => [],
        ComparativeArg:slash => [],
        ComparativeArg:tags => []
    ).


sbar_complementizer(C) :-
    C => comp,
    XP => sbar,
    xp_complementizer(C,XP).

vp_complementizer(C) :-
    C => comp,
    C:wh => nwh,
    VP => vp,
    VP:e_deps => [],
    unify_mods(VP),
    VP:vform => om,
    xp_complementizer(C,VP).

%% of
of_complementizer(C) :-
    vp_comp(C),
    C:ctype => (c_of;c_alsof;c_mod).

%% het is alsof hij slaapt
alsof_complementizer(C) :-
    vp_comp(C),
    C:slash => [],
    C:ctype => (c_alsof;c_mod).

%% omdat we maar doen alsof (to the right of vc)
alsof_complementizer(C) :-
    compp(C),
    C:ctype => c_alsof.

%% dat
dat_complementizer(C) :-
    vp_comp(C),
    C:ctype => c_dat.

%% te
te_complementizer(C) :-
    C => te_comp,
    sign(C,ti),
    initialize_dt([],C).

%% naar wij verwachten ...
naar_complementizer(C) :-
    complementizer(C0),
    unify_except(C0,C1,sc:h:slash),
    unify_except(C1,C,ctype),
    C:ctype => (c_mod;c_adv),
    SBAR => sbar,
    SBAR:dt => [], 
    SBAR:e_deps => [],
    SBAR:ctype => c_naar,
    C:sc:h:slash <=> [SBAR].

%% te-infinitival complementizers (creating an adjunct)
%% "[door [vp een dijk aan te leggen]] werd de dreiging bezworen"
inf_complementizer(C) :-
    inf_vpx_comp(C,cp),
    C:ctype => c_mod.

%% `om' can introduce both vp-complement or te-infinitival adjunct
om_complementizer(C) :-
    inf_vpx_comp(C,oti),
    C:ctype => c_om.

%% want wie denk je dat ik zag?
root_complementizer(C) :-
    C => comp,
    C:wh => nwh,
    C:sc <=> [Root],
    C:ctype => c_root,
    Root => start,
    comp(C,du),
    unify_mods(Root),
    C:hstem <=> Val,
    (   Val = dus,
        Root:sv1 => no
    ;   dif(Val,dus)
    ).

van_complementizer(C) :-
    C => comp,
    C:wh => nwh,
    C:sc <=> [Root],
    Root => start,
    comp(C,svan),
    C:ctype => c_van,
    unify_mods(Root).

start_complementizer(C) :-
    C => comp,
    C:wh => nwh,
    C:ctype => c_compare_np,
    comp(C,smain),
    C:sc <=> [START],
    START => start,
    unify_mods(START).

comparative(W,C) :-
    C => comparative,
    initialize_dt([],C),
    compar_form(W,Wform),
    C:compar_form <=> Wform,
    sign(C,comparative),
    C:sc <=> [XP],
    XP:haswh =?> no,
    comparative_arg(XP),
    unify_mods(XP).

compar_form(als,Form) :-
    Form => cf_als.

compar_form(dan,Form) :-
    Form => cf_dan.

compar_form(e_als,Form) :-
    Form => cf_e_als.

comparative_arg(XP) :-
    XP => np.

comparative_arg(XP) :-
    XP => pp,
    XP:pp_role => pp_obj1.

comparative_arg(XP) :-
    XP => a.

comparative_arg(XP) :-
    XP => adv.

%% een leuker boek dan (dat) ik dacht
%% een leuker boek dan (dat) ik nodig heb
comparative_arg(XP) :-
    XP => sbar,
    XP:slash <=> [Arg],
    (	Arg => sbar,
	Arg:e_deps => [],
        Arg:ctype => c_none
    ;	Arg => np,
	Arg:nform => (norm;meas_mod), % * een leuker boek dan dat regent
	Arg:prs => thi                % * een leuker boek dan dat besta
    ),
    Arg:dt => [].

%% hij slaapt langer dan dat Piet slaapt
comparative_arg(XP) :-
    XP => sbar,
    XP:e_deps => [],
    XP:slash => [].

%% een leuker boek dan ik dacht
%% een leuker boek dan ik nodig heb
%% een leuker boek dan beschikbaar is
comparative_arg(XP) :-
    XP => vp,
    XP:cleft => no,
    XP:slash <=> [Arg],
    XP:vform => fin,
    (	Arg => sbar,
	Arg:e_deps => [],
        Arg:ctype => c_none
    ;	Arg => np,
	Arg:nform => (norm;meas_mod),  % * een leuker boek dan regent
	Arg:prs => thi                 % * een leuker boek dan beschikbaar ben
    ),
    Arg:dt => [].

%% hij slaapt langer dan Piet slaapt
comparative_arg(XP) :-
    XP => vp,
    XP:vform => fin,
    XP:slash => [].

comparative_arg(XP) :-
    XP => vp,
    XP:slash => [],
    XP:vform => (te;om).

%%  een leuker boek dan verwacht
%%  hij heeft meer boeken gestolen dan gekocht
comparative_arg(XP) :-
    XP => vpx,
    XP:vform => psp,
    XP:slash <=> [Arg],
    (	Arg => sbar,
        Arg:ctype => c_none,
	Arg:e_deps => []
    ;	Arg => np
    ),
    Arg:dt => [].

%% ik ga liever boeken lezen dan platen kopen
comparative_arg(XP) :-
    XP => vpx,
    XP:vform => inf,
    XP:slash <=> [].

%% this doens't treat yet:
%% - more than a single xp (ellipsis?)
%%   hij koopt meer boeken dan ik platen
%% - sentential complement with missing adjunct:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% aan het %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

aan_het_comp(V) :-
    V => aan_het_comp,
    initialize_dt([],V),
    sign(V,ahi).

op_comp(V) :-
    V => op_comp,
    initialize_dt([],V),
    sign(V,ahi).

uit_comp(V) :-
    V => uit_comp,
    initialize_dt([],V),
    sign(V,ahi).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Adverbs %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

adverb(ADV) :-
    adverb0(ADV),
    hstem(ADV).
%%% Niet is gebleken dat ...
%%% Niet valt in te zien dat ...
    % ADV:hstem <=> STEM,
    % (   STEM = niet,
    %     ADV:sel => ~to_topic
    % ;   dif(STEM,niet)
    % ).

adverb0(ADV) :-   
    ADV => adv,
    initialize_dt([],ADV),
    ADV:adj_can_postv => no,
    ADV:can_postv => no,
    ADV:subadv => subadv_adv,
    sign(ADV,advp),
    ADV:tmploc => ntmploc,
    ADV:redrel => no,
    ADV:wh => nwh.

sentence_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,tmploc,sent),
    not_topic_adverb(ADV).

not_topic_adverbs(['±',
                   echter,
                   godverdomme,
                   maar,
                   immers,
                   kortom,
                   namelijk,
                   potverdomme,
                   potverdorie,
                   trouwens,
                   verdomme,
                   verdorie
                   ]).

not_topic_adverb(ADV) :-
    ADV:hstem <=> H,
    not_topic_adverbs(List),
    ADV:sel <=> SEL,
    NTT => ~to_topic,
    when(nonvar(H),
	 (   lists:member(H,List)
	 ->  SEL=NTT
	 ;   true
	 )
	).

hoe_adv(ADV) :-
    ADV => hoe_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

intensifier(ADV) :-
    ADV => int_adv,
    initialize_dt([],ADV),
    ADV:sc => [],
    sign(ADV,advp).

intensifier(e,ADV) :-
    ADV => int_adv,
    initialize_dt([],ADV),
    ADV:sc => [],
    sign(ADV,advp),
    ADV:agr => ~(het & indef & sg).

vp_om_intensifier(ADV) :-
    intensifier(ADV0),
    add_om_to_exs(ADV0,ADV).

me_intensifier(ADV) :-
    ADV => int_adv,
    initialize_dt([me],ADV),
    sign(ADV,advp),
    ADV:sc <=> [NP],
    adj_np_me_arg(NP),
    NP:subn => ~sub_def_verb  & ~sub_def_adj & ~sub_rang &
               ~sub_indef_adj & ~sub_def_pron & ~sub_indef_pron & ~sub_det,
    NP:exs => [],
    instantiated_deprel(ADV,me,NP).

vp_om_me_intensifier(ADV) :-
    me_intensifier(ADV0),
    add_om_to_exs(ADV0,ADV).

als_me_intensifier(ADV) :-
    me_intensifier(ADV0),
    add_als_to_exs(ADV0,ADV).

comp_adverb(Sub,ADV) :-
    adverb0(ADV0),
    unify_except(ADV0,ADV1,adj_can_postv),
    ADV1:adj_can_postv => yes,  % ik heb gelezen zo geconcentreerd [als] ik kon
    add_comparative_to_exs(ADV1,ADV,Sub).

vp_adverb(ADV) :-
    adverb0(ADV0),
    add_omte_to_exs(ADV0,ADV).

vp_om_adverb(ADV) :-
    adverb0(ADV0),
    add_om_to_exs(ADV0,ADV).

dip_sbar_adverb(ADV) :-
    ADV => dip_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

vandaar_adverb(ADV) :-
    ADV => vandaar_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

zo_van_adverb(ADV) :-
    ADV => zo_van_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

%% NB: we do not allow extraposed temporal relatives:
%% ik moet altijd geeuwen wanneer/als ik jouw zie
%% is analysed as cp modifier

tmp_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,tmploc,tmp).

wk_tmp_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,tmploc,tmp),
    ADV:sel => ~to_topic,
    ADV:wk => yes.

loc_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV1,tmploc,loc),
    add_rel(ADV1,ADV).

er_loc_adverb(ADV) :-
    adverb0(ADV0),
    ADV0:pron => yes,  % even if it is used as loc, we want to be able
                       % to know if it is +R "*ik reken op daar"
    overwrite(ADV0,ADV1,tmploc,loc),
    add_rel(ADV1,ADV).

%% if er, no rel: "*daar waar ik slapen reken ik op"
er_loc_adverb(ADV) :-
    adverb0(ADV0),
    ADV0:pron => yes,
    overwrite(ADV0,ADV,tmploc,str_er).

add_rel(N0,N) :-
    unify_except_l(N0,N,[cmods,mexs]),
    N0:mexs <=> Rels,
    N:mexs <=> [Rel|Rels],
    Rel => mexs_cat,
    Rel:nform => norm,
    Rel:tmploc => (loc;non_adv;str_er),
    N0:cmods <=> Cmods0,
    N:cmods <=> Cmods,
    Rel:mods <=> Out,
    when((nonvar(Out);?=(Cmods0,Cmods);nonvar(Cmods)),
         ( Out = [], Cmods0=Cmods
         ; Out = [Mod], Cmods=[Mod|Cmods0]
         )
        ).

dir_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,tmploc,ld_dir).

%er_adverb(ADV) :-
%    adverb(ADV0),
%    overwrite(ADV0,ADV,er,yer).

%% this was rywh...
wh_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,wh,ywh),
    ADV:modifies_a => no,
    ADV:tmploc => ~non_adv & ~hoe_hoe & ~wk_er & ~str_er & ~postp,
    ADV:tmploc <=> ADV:wh_reltmploc.

/*
%% hij is zoals hij is
zoals_rel_adverb(ADV) :-
    wh_adjective(ADV0),
    unify_except(ADV0,ADV1,wh),
    ADV1:wh => nq,
    ADV1:wh => ywh,
    unify_except(ADV1,ADV,wh_reltmploc),
    ADV:wh_reltmploc => zoals,
    ADV:modifies_a => no,
    ADV:wh => nq.  % *zoals ken ik die man?
*/

%% wanneer...
wh_tmp_adverb(ADV) :-
    tmp_adverb(ADV0),
    overwrite(ADV0,ADV,wh,ywh),
    ADV:modifies_a => no,
    ADV:tmploc <=> ADV:wh_reltmploc.

%% waar ergens
wh_loc_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV1,tmploc,loc),
    overwrite(ADV1,ADV,wh,rywh),
    ADV:modifies_a => no,
    ADV:tmploc <=> ADV:wh_reltmploc.

%% waar
er_wh_loc_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV1,tmploc,(str_er;loc)),
    overwrite(ADV1,ADV,wh,rywh),
    ADV:modifies_a => no,
    ADV:tmploc <=> ADV:wh_reltmploc.

%% alwaar
rwh_loc_adverb(ADV) :-
    wh_loc_adverb(ADV),
    ADV:modifies_a => no,
    ADV:wh => nq.

%% er
er_vp_adverb(ADV) :-
    adverb0(ADV0),
    overwrite(ADV0,ADV,tmploc,wk_er).

postadv_adverb(ADV) :-
    ADV => post_adv_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

post_loc_adv_adv(ADV) :-
    ADV => post_loc_adv_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

iets_adverb(ADV) :-
    ADV => iets_adv,
    initialize_dt([],ADV),
    ADV:wh => nwh,
    sign(ADV,advp).

wh_iets_adverb(ADV) :-
    ADV => iets_adv,
    initialize_dt([],ADV),
    ADV:wh => ywh,
    sign(ADV,advp).

postadj_adverb(ADV) :-
    ADV => post_adj_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

om_postadj_adverb(ADV) :-
    postadj_adverb(ADV0),
    add_om_to_exs(ADV0,ADV).

pre_num_adv(ADV) :-
    ADV => pre_num_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

postnp_adverb(ADV) :-
    ADV => post_np_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

postn_adverb(ADV) :-
    ADV => post_n_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

postp_adverb(ADV) :-
    ADV => post_p_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

post_wh_adverb(ADV) :-
    ADV => post_wh_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

pre_wh_adverb(ADV) :-
    ADV => pre_wh_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

modal_adverb(ADV) :-
    ADV => modal_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

predm_adverb(ADV) :-
    ADV => predm_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

eenmaal_adverb(ADV) :-
    ADV => eenmaal_adv,
    initialize_dt([],ADV),
    sign(ADV,advp).

predm_adverb_num(ADV) :-
    ADV => predm_adv_num,
    initialize_dt([],ADV),
    sign(ADV,np).

zo_mogelijk_zo(ADV) :-
    ADV => zom_adv,
    initialize_dt([obcomp],ADV),
    sign(ADV,advp).

zo_mogelijk_mogelijk(ADJ) :-
    ADJ => zom_a,
    initialize_dt([],ADJ),
    ADJ:aform => (attr;nattr),
    sign(ADJ,ap).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Prepositions %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

post_p(Sign) :-
    Sign => post_p,
    sign(Sign,pp),
    initialize_dt([obj1],Sign),
    Sign:sc <=> [NP],
    acc_np_arg(NP),
    instantiated_deprel(Sign,obj1,NP).

preptype(Prep,Sign) :-
    r_ld_prep(Prep),
    Sign:preptype => ld_prep,
    Sign:preptype => r_prep.

preptype(Prep,Sign) :-
    r_no_ld_prep(Prep),
    Sign:preptype => no_ld_prep,
    Sign:preptype => r_prep.

preptype(Prep,Sign) :-
    no_r_ld_prep(Prep),
    Sign:preptype => ld_prep,
    Sign:preptype => no_r_prep.

preptype(Prep,Sign) :-
    \+ r_ld_prep(Prep),
    \+ r_no_ld_prep(Prep),
    \+ no_r_ld_prep(Prep),
    Sign:preptype => no_ld_prep,
    Sign:preptype => no_r_prep.

r_ld_prep(aan).
r_ld_prep(achterin).
r_ld_prep(achterop).
r_ld_prep(achter).
r_ld_prep(beneden).
r_ld_prep(bij).
r_ld_prep(binnen).
r_ld_prep(boven).
r_ld_prep(bovenaan).
r_ld_prep(bovenin).
r_ld_prep(bovenop).
r_ld_prep(buiten).
r_ld_prep(dichtbij).
r_ld_prep(door).
r_ld_prep(doorheen).
r_ld_prep(in).
r_ld_prep(langs).
r_ld_prep(middenin).
r_ld_prep(naar).
r_ld_prep(naast).
r_ld_prep(nabij).
r_ld_prep(na).
r_ld_prep(om).
r_ld_prep(omheen).
r_ld_prep(onder).
r_ld_prep(onderaan).
r_ld_prep(onderin).
r_ld_prep(onderop).
r_ld_prep(onderuit).
r_ld_prep(op).
r_ld_prep(over).
r_ld_prep(overheen).
r_ld_prep(rond).
r_ld_prep(te).
r_ld_prep(ter).
r_ld_prep(tegenaan).
r_ld_prep(tegenover).
r_ld_prep(tegen).
r_ld_prep(tot).
r_ld_prep(tussen).
r_ld_prep(tussenuit).
r_ld_prep(uit).
r_ld_prep(van).
r_ld_prep(vandaan).
r_ld_prep(vandoor).
r_ld_prep(vanonder).
r_ld_prep([van,onder]).
r_ld_prep([van,tussen]).
r_ld_prep(vanop). % Vlaams: je kunt er vanop aan
r_ld_prep(vanuit).
r_ld_prep(vlakbij).
r_ld_prep(voorbij).
r_ld_prep(voor).
r_ld_prep(voorin).
r_ld_prep([op,weg,naar]).
r_ld_prep([temidden,van]).
r_ld_prep([te,midden,van]).
r_ld_prep([midden,in]).
r_ld_prep([ten,huize,van]).
r_ld_prep([ten,noorden,van]).
r_ld_prep([ten,noordoosten,van]).
r_ld_prep([ten,noordwesten,van]).
r_ld_prep([ten,'noord-oosten',van]).
r_ld_prep([ten,'noord-westen',van]).
r_ld_prep([ten,oosten,van]).
r_ld_prep([ten,westen,van]).
r_ld_prep([ten,zuidoosten,van]).
r_ld_prep([ten,zuidwesten,van]).
r_ld_prep([ten,'zuid-oosten',van]).
r_ld_prep([ten,'zuid-westen',van]).
r_ld_prep(vanaf).

r_no_ld_prep(met).
r_no_ld_prep(zonder).

r_no_ld_prep(af).
r_no_ld_prep(doorheen).
r_no_ld_prep(omtrent).   % VL?
r_no_ld_prep(tegenaan).
r_no_ld_prep(tegenin).
r_no_ld_prep(tegenop).
r_no_ld_prep(naartoe).
r_no_ld_prep([op,los]).

no_r_ld_prep(benoorden).
no_r_ld_prep(bezuiden).
no_r_ld_prep(elders).
no_r_ld_prep(halfweg).
no_r_ld_prep(halverwege).
no_r_ld_prep(hartje).
no_r_ld_prep([op,het,gebied,van]).
no_r_ld_prep(richting).
%no_r_ld_prep(rond).  % ?Vlaams wel +R
no_r_ld_prep(rondom).
no_r_ld_prep(vanachter).
no_r_ld_prep(vanonder).
no_r_ld_prep(via).

p(P,Word) :-
    NP => np,
    special_p(Word,P,NP),
    p_(P,NP).

special_p(Word,_P,NP) :-
    dif(Word,per),
    dif(Word,als),
    dif(Word,in),
    NP:bmeas => no,
    NP:case => obl.

special_p(als,_,NP) :-
    NP:bmeas => no,
    NP:case => ~gen.    % als ik

special_p(in,_,NP) :-   % in hertz/kilo/dollar
    NP:case => obl.
    
special_p(per,_,NP) :-  % per jaar/maand/week/kilo/ons
    NP:case => obl.
    
p_(P,NP) :-
    P => p,
    NP => np,
    P:nagr <=> NP:prs,
    P:nnform <=> NP:nform,
    P:wh <=> NP:wh,
    P:wh_reltmploc <=> NP:wh_reltmploc,
    NP:nform => (norm;refl;meas_mod),
    P:slash => [],
    P:sc <=> [NP],
    unify_mods(NP),
    sign(P,pp),
    NP:dt <=> P:ndt,
    p_role(P,NP).

p_role(P,NP) :-
    initialize_dt([hdf,obj1,pobj1,se,vc],P),
    NP:dt <=> NPDT,
    P:dt => dt,
    P:dt:obj1 <=> OBJ1,
    P:dt:pobj1 <=> POBJ1,
    P:dt:se <=> SE,
    P:dt:vc <=> VC,
    P:pp_role <=> ROLE,
    O1 => pp_obj1,
    O2 => pp_pobj1,
    O3 => pp_se,
    when((nonvar(ROLE);(nonvar(OBJ1),nonvar(SE),nonvar(POBJ1),nonvar(VC))),
         ( ROLE=O1, NPDT=OBJ1, SE=[],POBJ1=[],VC=[]
         ; ROLE=O2, NPDT=POBJ1,OBJ1=[], SE=[]
         ; ROLE=O3, NPDT=SE,   OBJ1=[],POBJ1=[],VC=[]
         )).

%% *waar zou je met willen meedoen?  ok: mee
%% *waar noodzaakt dit je tot?       ok: toe
%% ?waar belde hij naar?             ok: heen / naar toe
p(P,Word) :-
    dif(Word,met), dif(Word,tot), 
    p_with_extracted_np(P,Word).

p_with_extracted_np(P,_Word) :-
    P => p,
    P:slash <=> [NP],
    P:sc => [],
    P:wh => nwh,  % !
    P:nagr <=> NP:prs,
    P:nnform <=> NP:nform,
    P:preptype => r_prep,
    NP => np,
    NP:nform => er,
    NP:passivizes => no, % !!
    NP:dt <=> P:ndt,
    /* is incorrect for parsing, "Ze vliegt overal en nergens heen"
    NP:dt <=> NPDT,
    when(nonvar(NPDT),          % for generation
         (   NPDT=[]           % een boek om op te rekenen
         ;   alpino_data:dt(NPDT,Hwrd,_,Cat,_),
             Cat \== np,
	     alpino_data:label(Hwrd,Root,_,_),
             when(nonvar(Root),
		  (  lists:member(Root,[daar,hier,er,ergens,nergens,overal,waar])
		  ;   Cat==conj % ik reken overal en nergens op
		  )
		 )
	 )
        ),
    */
    unify_mods(NP),
    sign(P,pp),
    p_role(P,NP).

%% what is the prep-form of the prepositions that take a
%% particle to the right of the XP?  For pc complements,
%% such a particle indicates that it's not the right pform:
%%  hij hield van Marietje
%%  *hij hield van Marietje vandaan
%% however, for ld complements, the particle is allowed.
%%  hij gaat naar Assen
%%  hij gaat naar Assen toe
%%
%% also, ununderstood contrast:
%% *waar ga je naar?
%% waar kijk je naar?
%% waar ga je naar toe/heen?
%% ?waar kijk je naar toe?
%% ?waar kijk je heen?
%% both are LD, currently.

preposition(Word,P,List) :-
    p(P,Word),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List.

preposition_pp(Word,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:slash => [],
    PP => pp,
    P:nnform => none,
    PP:e_deps => [],
    PP:slash => [],
    PP:ld_pc => ~pred_pp,
    PP:pp_role => pp_obj1,
    P:wh <=> PP:wh,   % ik vroeg [tot [aan wiens limiet]] we gekomen waren
    P:wh_reltmploc <=> PP:wh_reltmploc,
    P:sc <=> [PP],
    unify_mods(PP),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List,
    instantiated_deprel(P,obj1,PP).

%% ik reken op vanavond
preposition_adv(Word,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:slash => [],
    ADV => adv,
    ADV:pron => no,
    ADV:wk => no,
    ADV:tmploc => ~tmp_n & ~meas_n & ~hoe_hoe & ~wk_er & ~str_er & ~postp,
    (   dif(Word,van),
        dif(Word,als),
        P:ld_pc => pc_pp
    
    ;   Word = van,   % een voorbeeld van hoe ..
                      %                   abstract
        ADV:tmploc => ~tmp & ~loc
    ;   Word = als
    ;   Word = met,		% een verschil/vergelijking met nu/vandaag/achterlangs/buiten
	P:ld_pc => n_pp
    ),
    P:nnform => none,
    P:wh <=> ADV:wh,   % ik vroeg [op [wanneer]] ze gerekend hadden
    P:wh_reltmploc <=> ADV:wh_reltmploc,
    P:sc <=> [ADV],
    unify_mods(ADV),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List,
    instantiated_deprel(P,obj1,ADV).

preposition_pc_vp(Word,P) :-
    P => p,
    initialize_dt([vc],P),
    P:slash => [],
    no_subj_vp_arg(VP),
    VP:slash => [],
    VP:vform => te,
    P:ld_pc => pc_pp,
    P:nnform => none,
    P:wh => nwh,
    P:sc <=> [VP],
    unify_mods(VP),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> [],
    instantiated_deprel(P,vc,VP).

preposition_sbar(P) :-
    P => p,
    initialize_dt([vc],P),
    P:slash => [],
    P:nnform => none,
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:slash => [],
    Sbar:ctype => c_dat,
    unify_mods(Sbar),
    P:wh => nwh,
    P:sc <=> [Sbar],
    sign(P,pp),
    P:prep ==> [],
    preptype(none,P),
    P:ppost ==> [],
    instantiated_deprel(P,vc,Sbar).

preposition_mod_sbar(P) :-
    preposition_sbar(P0),
    overwrite(P0,P,sc:h:ctype,(c_als;c_mod)).

%% ongeacht of hij komt
%% ongeacht wie er komt
preposition_of_sbar(P) :-
    preposition_sbar(P0),
    overwrite(P0,P,sc:h:ctype,(c_of;c_of_short;c_redrel)).

%% iets willen weten over hoe dat moet
preposition_redrel(PREP,P) :-
    preposition_sbar(P0),
    overwrite(P0,P1,sc:h:ctype,c_redrel),
    unify_except(P1,P,prep),
    P:prep ==> PREP.

pred_preposition(Word,P) :-
    P => p,
    initialize_dt([obj1],P),
    P:slash => [],
    P:nnform => none,
    Pred => a,   % if pred, then spurious ambiguities for np args
                 % hm. Not anymore since we now have pcat. But leave as is.
    Pred:aform => nattr,
    Pred:sc => [],
    Pred:slash => [],
    Pred:adv => ~oadv & ~detadv,
    unify_mods(Pred),
    P:wh => nwh,
    P:sc <=> [Pred],
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> [],
    P:ld_pc => pred_pp,
    instantiated_deprel(P,obj1,Pred).

voor_pred_preposition(Word,P) :-
    pred_preposition(Word,P).

preposition_loc_adv(Word,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:nnform => none,
    ADV => adv,
    ADV:wk => no,
    ADV:tmploc => loc,
    P:wh <=> ADV:wh,   % ik vroeg [tot waar] we gekomen waren
    P:wh_reltmploc <=> ADV:wh_reltmploc,
    P:sc <=> [ADV],
    P:slash => [],
    P:ld_pc => (n_pp;mod_pp;ld_pp),
    unify_mods(ADV),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List,
    instantiated_deprel(P,obj1,ADV).

preposition_tmp_adv(Word,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:nnform => none,  % use ordinary preposition for that
    ADV => adv,
    P:ld_pc => (pc_pp;mod_pp;n_pp),
    ADV:tmploc => tmp,
    ADV:wk => no,
    P:wh <=> ADV:wh,   % ik vroeg [sinds wanneer] we ..
    P:wh_reltmploc <=> ADV:wh_reltmploc,
    P:sc <=> [ADV],
    P:slash => [],
    unify_mods(ADV),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List,
    instantiated_deprel(P,obj1,ADV).

preposition_vp(Word,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:nnform => none,  % use ordinary preposition for that
    no_subj_vp_arg(VP),
    VP:vform => om,
    P:ld_pc => (pc_pp;mod_pp;n_pp),
    P:wh => no,
    P:sc <=> [VP],
    P:slash => [],
    unify_mods(VP),
    sign(P,pp),
    P:prep ==> Word,
    preptype(Word,P),
    P:ppost ==> List,
    instantiated_deprel(P,obj1,VP).

preposition_with_extracted_np(Pform,P,List) :-
    p_with_extracted_np(P,Pform),
    P:prep ==> Pform,
    preptype(Pform,P),
    P:ppost ==> List.

%% wegens te oud
preposition_adj(Pform,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:prep ==> Pform,
    P:slash => [],
    P:ppost ==> List,
    P:nnform => none,
    Pred => a,
    Pred:aform => nattr,
    Pred:sc => [],
    Pred:slash => [],
    Pred:adv => ~oadv & ~detadv,
    unify_mods(Pred),
    P:wh => nwh,
    P:sc <=> [Pred],
    sign(P,pp),
    preptype(Pform,P),
    P:ld_pc => (mod_pp;n_pp),
    instantiated_deprel(P,obj1,Pred).

%% van twee weken oud
preposition_me_adj(Pform,P,List) :-
    P => p,
    initialize_dt([hdf,obj1],P),
    P:prep ==> Pform,
    P:ppost ==> List,
    P:nnform => none,
    ADJ => a,
    ADJ:me_adj => yes,
    ADJ:sc => [],
    ADJ:aform => nattr,
    ADJ:slash => [],
    unify_mods(ADJ),
    P:sc <=> [ADJ],
    P:slash => [],
    P:wh => nwh,
    sign(P,pp),
    P:preptype => no_ld_prep,
    P:preptype => no_r_prep,
    instantiated_deprel(P,obj1,ADJ).

waar_adverb(Prep,PP) :-
    PP => pp,
    p_role(PP),
    sign(PP,pp),
    PP:nnform => er,
    PP:wh => rywh,
    PP:wh_reltmploc => non_adv,
    PP:slash => [],
    PP:pp_er => yes,
    preptype(Prep,PP),
    PP:prep ==> Prep.

%% ik wil daaraan niet denken
%% "I want about-that not think"
%% I don't want to think about that
er_adverb(Prep,PP):-
    PP => pp,
    p_role(PP),
    initialize_dt([vc],PP),
    sign(PP,pp),
    PP:wh => nwh,
    PP:slash => [],
    PP:pp_er => yes,
    preptype(Prep,PP),
    PP:prep ==> Prep.

%% as p_role/2, but there is no NP now.
p_role(P) :-
    initialize_dt([vc],P),
    P:dt => dt,
    P:dt:vc <=> VC,
    P:pp_role <=> ROLE,
    O1 => pp_obj1,
    O2 => pp_pobj1,
    when(nonvar(ROLE),
         ( ROLE=O1, VC=[]
         ; ROLE=O2
         )).

%% a few prepositions select a noun projection without a determiner
%% "ter", "te", "der"
%% historically, these are apparantly formed as [p+det]
nodet_preposition(P,Prep) :-
    P => p,
    initialize_dt([obj1],P),
    N => n,
    P:nnform <=> N:nform,
    P:nagr => thi,
    P:wh => nwh,
    P:sc <=> [N],
    P:slash => [],
    unify_mods(N),
    sign(P,pp),
    P:ppost ==> [],
    P:prep ==> Prep,
    te_requires_name(Prep,N),
    preptype(Prep,P),
    instantiated_deprel(P,obj1,N).

nodet_preposition(P,Prep) :-
    lists:member(Prep,[te,ten,ter]),
    P => p,
    initialize_dt([obj1],P),
    N => np,
    N:case => gen,  % ter uwer...
    P:nnform <=> N:nform,
    P:nagr => thi,
    P:wh => nwh,
    P:sc <=> [N],
    P:slash => [],
    unify_mods(N),
    sign(P,pp),
    P:ppost ==> [],
    P:prep ==> Prep,
    preptype(Prep,P),
    instantiated_deprel(P,obj1,N).

te_requires_name(te,N) :-
    N:hdet => no,
    N:subn => (sub_name;sub_tmp).  % also 'te 19.00'
te_requires_name(NotTe,_) :-
    dif(NotTe,te).


%% van voren, van onderen
pp(Prep,Sign) :-
    Sign => pp,
    initialize_dt([],Sign),
    Sign:nnform => none,
    Sign:slash => [],
    Sign:wh => nwh,
    Sign:prep ==> Prep,
    preptype(Prep,Sign),
    Sign:pp_er => no,
    Sign:e_deps => [],
    sign(Sign,pp).

%% np or ap
absolute_preposition(Sign) :-
    Sign => abs_p,
    initialize_dt([obj1,predc],Sign),
    sign(Sign,pp),
    Obj1 => np,
    Obj1:case => obl,
    Obj1:nform => (norm;meas_mod),
    Obj1:pred => npred,
    Obj1:e_deps => [],
    unify_mods(Obj1),
    Predc => pred,
    unify_mods(Predc),
    instantiated_deprel(Sign,obj1,Obj1),
    instantiated_deprel(Sign,predc,Predc),
    Sign:sc <=> [Obj1,Predc].

absolute_preposition(Sign) :-
    Sign => abs_p,
    initialize_dt([obj1],Sign),
    sign(Sign,pp),
    Obj1 => np,
    Obj1:case => obl,
    Obj1:nform => (norm;meas_mod),
    Obj1:pred => npred,
    Obj1:e_deps => [],
    unify_mods(Obj1),
    instantiated_deprel(Sign,obj1,Obj1),
    Sign:dt:mod <=> [_|_],  % at least one..
    Sign:sc <=> [Obj1].

absolute_preposition(Sign) :-
    Sign => abs_p,
    initialize_dt([vc,predc],Sign),
    sign(Sign,pp),
    (   Obj1 => sbar,
        Obj1:ctype => c_dat,
	Obj1:e_deps => []
    ;   Obj1 => vp,
        Obj1:vform => (om;te)
    ),
    Obj1:slash => [],
    unify_mods(Obj1),
    Predc => pred,
    unify_mods(Predc),
    instantiated_deprel(Sign,vc,Obj1),
    instantiated_deprel(Sign,predc,Predc),
    Sign:sc <=> [Obj1,Predc].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%% VERBS %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

v(V) :-
    V0 => v,
    sign(V0,_),
    unify_except(V0,V,mods),
    V:vslash => [],
    V:eps1 => no,
    V:eps2 => no,
    V:sv1_mod => no.

main_v_subj(V) :-
    V:subj <=> Subj,
    Subj => np,
    Subj:pred => npred,
    Subj:e_deps => [],
    deprel(V,su,Subj),
    Subj:nform => (norm;meas_mod),
    unify_mods(Subj).

aux_v_subj(V) :-
    V:subj <=> Subj,
    Subj => np,
    deprel(V,su,Subj).

main_v(V) :-
    v(V),
    main_v_subj(V),
    V:e_deps => [],
    V:tpart => no,
    V:vtype => vmain,
    V:parts => [].

aux_v(V,VP) :-
    v(V),
    aux_v_subj(V),
    V:passive => no_passive,
    VP => vc,
    VP:fixed_dep => no,
    V:e_deps <=> VP:e_deps,
    VP:vslash => [],
    instantiated_deprel(V,vc,VP),
    VP:ccat0 <=> VP:ccat,
    V:tpart <=> VP:tpart, % vast zou staan dat ik kom
    V:parts <=> VP:parts.

%% utilities

%% control
%% NB the control feature of the VP is only used, to ensure that vc
%% with VP on subcat are only coordinated if their corresponding control
%% is the same.
%% Otherwise we would get 'second phase fails' for:
%% "Ze zouden een collega hebben verteld en gevraagd te gaan"

%% the dt of the subject of VP is identical to dt of Arg
%% in addition, control implies that both subject of VP and arg
%% are np's with nform=norm
control(VP,Arg) :-
    VP:pro_deps <=> [Subj],
    Subj => np,
    Arg => np,
    Subj:dt <=> Arg:dt,
    Subj:nform <=> Arg:nform.

so_control_relation(VP,Arg) :-
    VP:pro_deps <=> [Subj],
    Subj => np,
    Arg => pp,
    Subj:dt <=> Arg:ndt,
    Subj:nform <=> Arg:nnform.

dependents(V,Dependents) :-
    dependents(V,V,Dependents).

dependents(V0,V,Dependents) :-
    dependents_(V0,V,Dependents,Deps),
    dep_roles(Dependents,Roles),
    initialize_dt([su,sup|Roles],V),
    V:deps <=> Deps.

dep_roles([],[]).
dep_roles([Role/_|T],[Role|Roles]) :-
    dep_roles(T,Roles).

dependents_(V,V,[],[]).
dependents_(V0,V,[X|Dependents],[Dep|Deps]) :-
    dependent(X,V0,V1,Dep),
    dependents_(V1,V,Dependents,Deps).


%% predc: keurig als we zijn veroordelen we racisme
%% su, obj1, obj2: topic-drop
%% vc: dip
dependent(DepRel/Dep,V0,V,Dep) :-
    (   DepRel == none
    ->  V0=V
    ;   DepRel == mod
    ->  add_mod_dep(V0,V,Dep)
    ;   DepRel == obj1
    ->  (   V0:vtype => (inf;psp),
	    V0=V,
	    instantiated_deprel(V,obj1,Dep)
	;   V0:vtype /=> (inf;psp),
	    V0=V,
	    deprel(V,obj1,Dep)
	)
    ;   DepRel == obj2
    ->  (   V0:vtype => (inf;psp),
	    V0=V,
	    instantiated_deprel(V,obj2,Dep)
	;   V0:vtype /=> (inf;psp),
	    V0=V,
	    deprel(V,obj2,Dep)
	)
    ;   DepRel == pc
    ->  V0=V, instantiated_deprel(V,pc,Dep)
    ;   DepRel == ld
    ->  V0=V, instantiated_deprel(V,ld,Dep)
    ;   DepRel == me
    ->  V0=V, instantiated_deprel(V,me,Dep)
    ;   DepRel == se
    ->  V0=V, instantiated_deprel(V,se,Dep)
    ;   V0=V,
        deprel(V,DepRel,Dep)
    ).

add_mod_dep(V0,V,PP) :-
    unify_except(V0,V,cmods),
    V0:cmods <=> MODS,
    V:cmods <=> [MOD|MODS],
    PP:dt => dt,
    PP:dt <=> MOD.

    
%dependents(_,[],[]).
%dependents(V,[DepRel/Dep|Dependents],[Dep|Deps]) :-
%    deprel(V,DepRel,Dep),
%    dependents(V,Dependents,Deps).

%% common argument types

refl_np_arg(NP) :-
    NP => np,
    unify_mods(NP),
    NP:nform => refl,
    NP:passivizes => no,
    NP:case => acc,
    NP:sel => to_left,
    NP:pred => npred.

refl_np_arg(NP,V) :-
    refl_np_arg(NP),
    V:subj:agr <?=?> NP:agr, % added GvN, 19 juni 2019
    V:subj:prs <?=?> NP:prs.

np_arg(NP) :-
    NP => np,
    NP:e_deps => [],
    unify_mods(NP),
    NP:pred => npred,
    NP:nform => (norm;meas_mod),
    NP:bmeas => no,
    NP:case => (dat;acc;obl).

np_me_arg(NP) :-
    np_arg(NP),
    NP:passivizes => no,
    NP:case => acc,
    NP:redrel => no,
    %% NP:wh_reltmploc => ntmploc, % really, should only allow hoeveel kost/hoelang duurt
    %% no: Wat kost een kaartje?
    %%     Wat bedraagt de schade?
    %%     Wat wegen die appels? (but "wegen" is transitive too)
    %%    *Wat duurt een wedstrijd?
    NP:subn => (sub_noun;sub_tmp;sub_num;sub_indef_pron;
                   sub_det;sub_veel;sub_def_adj).
				% flo X is a num now too
                                % sub_adj: dit kost "het dubbele"
				% sub_indef_pron: wat kost een ...

adj_np_me_arg(NP) :-
    np_me_arg(NP),
    NP:subn => ~sub_det.

het_np_subj(NP) :-
    NP => np,
    unify_mods(NP),
    NP:e_deps => [],
    NP:nform => het_nform,
    NP:pred => npred,
%%    NP:case => nom,  % zij lieten het gebeuren dat ...
    NP:passivizes => no,
    NP:agr => sg,
    NP:e_agr => sg,
    NP:prs => thi.

het_np_arg(NP) :-
    NP => np,
    unify_mods(NP),
    NP:e_deps => [],
    NP:agr => sg,
    NP:e_agr => sg,
    NP:prs => thi,
    NP:nform => het_nform,
    NP:case => acc,
    NP:pred => npred,
    NP:passivizes => no,
    NP:sel => to_left.

dat_np_arg(NP) :-
    NP:can_mod => no,  % de partij
    np_arg(NP), % num: Cohen besloot 13 van hen een verg. te g.
    NP:case => dat.

dat_np_arg_of_adj(NP) :-
    dat_np_arg(NP),
    NP:subn => (sub_noun;sub_def_pron;sub_indef_pron;sub_name).

nowh_exp_dat_np_arg(NP) :-
    exp_dat_np_arg(NP),
    NP:wh => nwh.

exp_dat_np_arg(NP) :-
    exp_amb_np_arg(NP),
    NP:allows_drop => no,
    NP:dt => dt,
    dat_np_arg(NP).

exp_amb_np_arg(NP) :-
    np_arg(NP),
%    NP:redrel => no,  % wie zeurt krijgt niet betaald
    NP:case => (acc;dat),
    NP:subn => (sub_name;sub_noun;sub_def_pron;sub_indef_pron;
                sub_def_adj;sub_adj_pl;sub_rang;sub_num).
                                % num: twee van ons beviel dat niet
				% adj: verpleegkundige
                                % adj_pl: dat is velen een doorn in het oog
                                % det: het lukte geen van de aanwezigen ...
				% but this gives too many additional false readings

acc_np_arg(NP) :-
    np_arg(NP),
    % NP:passivizes => yes,
    NP:case => acc.

ld_np_arg(NP) :-
    np_arg(NP),
    NP:passivizes => no,
    NP:case => acc.

er_np_arg(NP) :-
    np_arg(NP0),
    unify_except(NP0,NP,nform),
    NP:nform => er,
    NP:e_deps => [],
    NP:passivizes => no,
    NP:case => acc,
    NP:wh => nwh,
    NP:sel => to_left,
    NP:hstem ==> er.

r_np_arg(NP) :-
    np_arg(NP0),
    unify_except(NP0,NP,nform),
    NP:nform => er,
    NP:e_deps => [],
    NP:passivizes => no.

pp_ld_arg(PP) :-
    pp_ld_arg(PP,_).

pp_ld_arg(PP,Prep) :-
    pp_arg(PP,Prep),
    PP:ld_pc => ld_pp,
    PP:preptype => ld_prep,
    PP:nnform => ~refl.

pp_pc_arg(PP,Prep) :-
    pp_arg(PP,Prep),
    PP:ld_pc => pc_pp,
    PP:nnform => ~refl,
    PP:haspart => no.

so_pp_arg(PP,Prep) :-
    pp_pc_arg(PP,Prep).

pp_refl_pc_arg(PP,Prep) :-
    pp_arg(PP0,Prep),
    unify_except(PP0,PP,pp_role),
    PP:pp_role => pp_se,
    PP:nnform => refl,
    PP:haspart => no.

pp_arg(PP,Prep) :-
    PP => pp,
    PP:pp_role => pp_obj1,
    unify_mods(PP),
    PP:e_deps => [],
    PP:prep ==> Prep. 

pred_arg(PRED) :-
    PRED => pred,
    PRED:deverbal => no,
    PRED:pcat => ~voor_pred,
%    PRED:dt => dt,
    unify_mods(PRED).

me_adv_arg(ADV) :-
    ADV => adv,
    unify_mods(ADV),
    ADV:tmploc => me.

ld_adv_arg(ADV):-
    ADV => adv,
    unify_mods(ADV),
    ADV:tmploc => loc.

ld_dir_arg(ADV):-
    ADV => adv,
    unify_mods(ADV),
    ADV:tmploc => ld_dir.

vp_arg(VP) :-
    VP => vp,
    VP:e_deps => [],
    ( VP:slash => []       % added GvN 2009-03-21
                          % sometimes violated: cdb/2707
                          % een bedrag dat ik gedwongen werd hem te geven
                          % dat weiger ik te aanvaarden
    ; VP:slash <=> [NP],
        acc_np_arg(NP)
    ),
    unify_mods(VP),
    VP:ctype => ~c_mod,   % forbid: de verplichting [vc cmp:na body:te komen]
    VP:vform => (om;te).

no_subj_vp_arg(VP) :-
    vp_arg(VP),
    %% forbid clefts in contexts where subj is ignored:
    VP:cleft => no,
    VP:subj => np,
%%    VP:subj:dt => [], don't filter on dt
    VP:subj:hstem => [],
    VP:subj:nform => norm,
    VP:subj:agr => sg,
    VP:subj:prs => thi,
    VP:subj:subn => sub_noun.

subj_control_vp_arg(VP,V) :-
    vp_arg(VP),
    V:subj <=> Subj,
    control(VP,Subj),
    VP:control => control_subj.

obj_control_vp_arg(VP,Obj) :-
    vp_arg(VP),
    control(VP,Obj),
    VP:control => control_obj.

so_control_vp_arg(VP,Obj) :-
    vp_arg(VP),
    so_control_relation(VP,Obj),
    VP:control => control_so.

dip_sbar_arg(Sbar):-
    Sbar => sbar,
    Sbar:ctype => c_dip,
    Sbar:e_deps => [],
    unify_mods(Sbar),
    Sbar:slash => [].

sbar_arg(Sbar):-
    transparant_sbar_arg(Sbar),
    Sbar:slash => [].

transparant_sbar_arg(Sbar) :-
    Sbar => sbar,
    Sbar:e_deps => [],
    Sbar:ctype => (c_of;c_of_short;c_redrel;c_dat;c_dip;c_none;c_naar),
    unify_mods(Sbar).

alsof_sbar_arg(Sbar):-
    Sbar => sbar,
    Sbar:ctype => c_alsof,
    unify_mods(Sbar),
    Sbar:slash => [].

van_sbar_arg(Sbar):-
    Sbar => sbar,
    Sbar:ctype => c_van,
    unify_mods(Sbar),
    Sbar:slash => [].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% subcat frames %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

intransitive(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    dependents(V,[]).

transitive(V,C,C) :-
    main_v(V),
    acc_np_arg(Obj),
    V:passive => norm_passive,
    dependents(V,[obj1/Obj]).

num_pred(V,C,C) :-
    main_v(V),
    acc_np_arg(Obj),
    Obj:subn => sub_num,  % should be score_cat!
    V:passive => no_passive,
    dependents(V,[predc/Obj]).

ndev(Obj) :-
    (   Obj:sel => ~to_topic,
	Obj:subn => ~sub_indef_verb
    ;   Obj:sel => to_topic
    ).

transitive_ndev(V,C,C) :-
    main_v(V),
    acc_np_arg(Obj),
    ndev(Obj),
    V:passive => norm_passive,
    dependents(V,[obj1/Obj]).

transitive_ndev_ndev(V,C0,C) :-
    transitive_ndev(V,C0,C),
    V:subj <=> Subj,
    Subj:subn => ~sub_indef_verb.

%% *de oplossing wordt door ons gekund
transitive_ndev_ndev_npas(V,C0,C) :-
    transitive_ndev_ndev(V0,C0,C),
    overwrite(V0,V,passive,no_passive).

%% for "dat wordt lachen geblazen"
transitive_ydev(V,C,C) :-
    main_v(V),
    acc_np_arg(Obj),
    Obj:subn => sub_indef_verb,
    V:passive => norm_passive,
    dependents(V,[obj1/Obj]).

%% for 'omdat hij de verkeerde kant opgaat'
%% which we analyse as ld:[[verkeerde kant] op]
ld_transitive(V,C0,C) :-
    ld_np_arg(Obj),
    ld(V0,Obj,C0,C),
    unify_except(V0,V,passive),
    V:passive => no_passive.   % * er wordt de verkeerde kant opgegaan

%% for 'omdat er iets tussenkomt'
ld_er_transitive(V,C0,C) :-
    r_np_arg(Obj),
    ld(V0,Obj,C0,C),
    unify_except(V0,V,passive),
    V:passive => no_passive.   % * er wordt de verkeerde kant opgegaan

%% for 'omdat er iets afstraalt'
%%     'zijn we er toch ingetuind' (Herman Kuiphof)
pc_er_transitive(V,C,C) :-
    main_v(V),
    r_np_arg(Obj),
    dependents(V,[pc/Obj]),
    V:passive => no_passive.   % * er wordt de verkeerde kant opgegaan

np_ld_transitive(V,C,C) :-
    main_v(V),
    ld_np_arg(LD),
    V:passive => norm_passive,
    acc_np_arg(Obj),
    Obj:allows_drop => no,
    dependents(V,[ld/LD,obj1/Obj]).

np_ld_er_transitive(V,C,C) :-
    main_v(V),
    r_np_arg(LD),
    V:passive => norm_passive,
    acc_np_arg(Obj),
    (   dependents(V,[ld/LD,obj1/Obj])
    ;   dependents(V,[obj1/Obj,ld/LD]),
        Obj:sel => to_left,
        LD:sel => to_left,
        Obj:passivizes => no
    ).

np_pc_er_transitive(V,C,C) :-
    main_v(V),
    r_np_arg(LD),
    V:passive => norm_passive,
    acc_np_arg(Obj),
    (   dependents(V,[pc/LD,obj1/Obj])
    ;   dependents(V,[obj1/Obj,pc/LD]),
        Obj:sel => to_left,
        LD:sel => to_left,
        Obj:passivizes => no
    ).

refl_ld_transitive(V,C0,C) :-
    ld_np_arg(Obj),
    refl_ld(V,Obj,C0,C),
    V:passive => no_passive.

me_ld_transitive(V,C0,C) :-
    ld_np_arg(Obj),
    me_ld(V,Obj,C0,C).

so_np(V,C,C) :-
    main_v(V),
    V:passive => no_passive, % ons staan problemen te wachten
    exp_dat_np_arg(Obj),
    dependents(V,[obj2/Obj]).

so_np_pass(V,C,C) :-
    main_v(V),
    V:passive => norm_passive, % ik krijg wel uitgekeerd
    dat_np_arg(Obj),           % het uitbetaald krijgen bevalt me wel
    dependents(V,[obj2/Obj]).

amb_so_np_pass(V,C,C) :-
    main_v(V),
    V:passive => norm_passive, % ik word doorbetaald
    exp_amb_np_arg(Obj),
    dependents(V,[obj2/Obj]).

amb_so_np_pass_pc_pp(Prep,V,C,C) :-
    main_v(V),
    pp_pc_arg(PP,Prep),
    V:passive => norm_passive, % ik word betaald voor NP
    exp_amb_np_arg(Obj),
    (   dependents(V,[pc/PP,obj2/Obj])
    ;   dependents(V,[obj2/Obj,pc/PP]),
	PP:sel => to_left,
	PP:slash => [],
	Obj:sel => to_left,
	Obj:passivizes => no
    ).

meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    np_me_arg(Obj),
    dependents(V,[me/Obj]).

adv_meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    me_adv_arg(Obj),
    dependents(V,[me/Obj]).

%% dit duurde ons te lang
so_adv_meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    dat_np_arg(Obj2),
    me_adv_arg(Obj),
    dependents(V,[me/Obj,obj2/Obj2]).

pp_meas(Prep,V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,Prep),
    np_me_arg(Obj),
    (	dependents(V,[pc/PP,me/Obj])
    ;	Obj:sel => to_left,
	PP:sel => to_left,
	PP:slash => [],
	dependents(V,[me/Obj,pc/PP])
    ).

ld_pp_meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_ld_arg(PP),
    np_me_arg(Obj),
    (	dependents(V,[ld/PP,me/Obj])
    ;	Obj:sel => to_left,
	PP:sel => to_left,
	PP:slash => [],
	dependents(V,[me/Obj,ld/PP])
    ).

%% we hebben de race twee weken  uitgesteld
np_meas(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    np_me_arg(Obj),
    dependents(V,[me/Obj,obj1/Obj1]).

%% dit kost me een fortuin
so_meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    dat_np_arg(Obj2),
    np_me_arg(Obj),
    dependents(V,[me/Obj,obj2/Obj2]).

so_pp_meas(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    so_pp_arg(Obj2,aan),
    np_me_arg(Obj),
    dependents(V,[me/Obj,obj2/Obj2]).

%% de veranderingen hebben zich aangekondigd
%% NB: toen hebben zich vele veranderingen voorgedaan
refl(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    refl_np_arg(Obj,V),
    dependents(V,[se/Obj]).

%% dat ik hem van de noodzaak doordring
np_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    acc_np_arg(Obj),
    (	dependents(V,[pc/PP,obj1/Obj])
    ;	PP:sel => to_left,
	Obj:sel => to_left,
	Obj:passivizes => no,
	PP:slash => [],
	dependents(V,[obj1/Obj,pc/PP])
    ).

%% dat hij zich de vingers niet wil branden aan de kwestie
refl_np_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    acc_np_arg(Obj),
    refl_np_arg(Refl),
    (	dependents(V,[pc/PP,obj1/Obj,se/Refl])
    ;	PP:sel => to_left,
	Obj:sel => to_left,
	Obj:passivizes => no,
	PP:slash => [],
	dependents(V,[obj1/Obj,pc/PP,se/Refl])
    ;	PP:sel => to_left,
	Obj:sel => to_left,
	Obj:passivizes => no,
	PP:slash => [],
	dependents(V,[obj1/Obj,se/Refl,pc/PP])
    ).

meas_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,Prep),
    np_me_arg(Obj),
    (	dependents(V,[pc/PP,me/Obj])
    ;	PP:sel => to_left,
	Obj:sel => to_left,
	PP:slash => [],
	dependents(V,[me/Obj,pc/PP])
    ).

adv_meas_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,Prep),
    me_adv_arg(Obj),
    (	dependents(V,[pc/PP,me/Obj])
    ;	PP:sel => to_left,
	Obj:sel => to_left,
	PP:slash => [],
	dependents(V,[me/Obj,pc/PP])
    ).

np_np_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    acc_np_arg(Obj1),
    dat_np_arg(Obj2),
    acc_dat_args(Obj1,Obj2,Dependents0),
    add_pp(Dependents0,pc,PP,Dependents),
    dependents(V,Dependents).

acc_dat_args(Obj1,Obj2,[obj1/Obj1,obj2/Obj2]).
acc_dat_args(Obj1,Obj2,[obj2/Obj2,obj1/Obj1]) :-
    Obj1:sel => to_left,
    Obj1:passivizes => no,
    Obj1:subn => (sub_def_pron;sub_indef_pron;sub_det), % LvdB
    Obj2:passivizes => no,
    Obj2:sel => to_left.

add_pp([ObjA,ObjB],pc,PP,[pc/PP,ObjA,ObjB]).
add_pp([ObjA,ObjB],pc,PP,[ObjA,pc/PP,ObjB]) :-
    PP:sel => to_left,
    PP:slash => [].
add_pp([ObjA,ObjB],pc,PP,[ObjA,ObjB,pc/PP]) :-
    PP:sel => to_left,
    PP:slash => [].

%% hij vraagt hem naar/om een oplossing
%% * hij vraagt om een oplossing sommigen
%% ok: hij vraag er sommigen om
so_np_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(PP,Prep),
    exp_dat_np_arg(Obj),
    (   dependents(V,[pc/PP,obj2/Obj])
    ;   PP:sel => to_left,
	PP:slash => [],
	Obj:sel => to_left,
	dependents(V,[obj2/Obj,pc/PP])
    ).

%% de roem stijgt hem naar het hoofd
%% * de roem stijgt naar het hoofd sommigen
%% ?? de roem stijgt er sommigen naar
so_np_ld_pp(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_ld_arg(PP),
    exp_dat_np_arg(Obj),
    dependents(V,[ld/PP,obj2/Obj]).

np_er_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    acc_np_arg(Obj),
    dependents(V,[pc/PP,obj1/Obj]).

np_mod_pp(Prep,V,C,C) :-
    main_v(V0),
    V0:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    acc_np_arg(Obj),
    dependents(V0,V,[mod/PP,obj1/Obj]).

np_np_mod_pp(Prep,V,C,C) :-
    main_v(V0),
    V0:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    acc_np_arg(Obj1),
    dat_np_arg(Obj2),
    acc_dat_args(Obj1,Obj2,List0),
    lists:select(mod/PP,List,List0),
    dependents(V0,V,List).

meas_er_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    np_me_arg(Obj),
    dependents(V,[pc/PP,me/Obj]).

adv_meas_er_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    me_adv_arg(Obj),
    dependents(V,[pc/PP,me/Obj]).

refl_er_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    refl_np_arg(Obj),
    dependents(V,[pc/PP,se/Obj]).

%% dat ik kriegel/een ander mens van dat gezeur word
%% dat ik van dat gezeur kriegel word
%% also: ik word er gek van dat je zo zeurt
%%                          naar jou te moeten luisteren
pred_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,Prep),
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    (	PRED:sel => to_left,
	PP:sel => to_left,
	PP:slash => [],
	dependents(V,[predc/PRED,pc/PP])
    ;	dependents(V,[pc/PP,predc/PRED])
    ).

pc_pp_refl(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_refl_pc_arg(PP,Prep),
    PP:nagr <=> V:subj:prs,
    dependents(V,[pc/PP]).

%% hij houdt het voor zich
np_pc_pp_refl(Prep,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    pp_refl_pc_arg(PP,Prep),
    acc_np_arg(Obj),
    PP:nagr <=> V:subj:prs,
    dependents(V,[pc/PP,obj1/Obj]).
    
%% dat behoort aan hem toe

so_pp(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    so_pp_arg(PP,aan),
    dependents(V,[obj2/PP]).

so_pp(PREP,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    so_pp_arg(PP,PREP),
    dependents(V,[obj2/PP]).

%% adviseren, toebedelen, beloven, berichten, ...
%% dat ik aan hem de winst beloofde
%% dat ik de winst aan hem beloofde
so_pp_np(V,C,C) :-
    so_pp_np(aan,V,C,C).

so_pp_np(PREP,V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    so_pp_arg(PP,PREP),
    acc_np_arg(Obj),
    (	dependents(V,[obj2/PP,obj1/Obj])
    ;	Obj:sel => to_left,
	PP:sel => to_left,
        PP:slash => [],
	Obj:passivizes => no,
	dependents(V,[obj1/Obj,obj2/PP])
    ).

%%  dat ik me afreageer op het meubilair
refl_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,Prep),
    refl_np_arg(Obj,V),
    dependents(V,[pc/PP,se/Obj]).

% refl_aan_pc_pp
so_pp_refl(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pp_pc_arg(PP,aan),
    refl_np_arg(Obj,V),
    dependents(V,[obj2/PP,se/Obj]).

%% bladeren in...
mod_pp(Prep,V,C,C) :-
    main_v(V0),
    V0:passive => imp_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    dependents(V0,V,[mod/PP]).

%% dat ik aan haar denk
%% dat ik met haar mee ga
%% de zoon aardt naar zijn vader (toe)!
pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(PP,Prep), 
    dependents(V,[pc/PP]).

er_pc_pp(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    dependents(V,[pc/PP]).

ld(V,LD,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    dependents(V,[ld/LD]).

ld_pp(V,C0,C) :-
    pp_ld_arg(PP),
    ld(V,PP,C0,C).

ld_pp(Prep,V,C0,C) :-
    pp_ld_arg(PP,Prep),
    ld(V,PP,C0,C).

ld_adv(V,C0,C) :-
    ld_adv_arg(ADV),
    ld(V,ADV,C0,C).

ld_dir(V,C0,C) :-
    ld_dir_arg(ADV),
    ld(V0,ADV,C0,C),
    unify_except(V0,V,passive),
    V:passive => no_passive.

np_ld(V,LD,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj),
    (	dependents(V,[ld/LD,obj1/Obj])
    ;	Obj:sel => to_left,
	LD:sel => to_left,
	Obj:passivizes => no,
        LD:slash =?> [],
	dependents(V,[obj1/Obj,ld/LD])
    ).

%% wij duwen hem een microfoon onder de neus
%% wij duwen het hem onder de neus
%% de microfoon wordt hem onder zijn neus geduwd
%% hij krijgt de microfoon onder zijn neus geduwd
np_np_ld(V,LD,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    dat_np_arg(Obj2),
    acc_np_arg(Obj),
    acc_dat_args(Obj,Obj2,List),
    dependents(V,[ld/LD|List]).

refl_np_ld(V,LD,C,C) :-
    main_v(V),
    V:passive => no_passive,
    refl_np_arg(Obj2),
    acc_np_arg(Obj1),
    dependents(V,[ld/LD,obj1/Obj1,se/Obj2]).

np_ld_pp(V,C0,C) :-
    pp_ld_arg(PP),
    np_ld(V,PP,C0,C).

np_ld_pp(Prep,V,C0,C) :-
    pp_ld_arg(PP,Prep),
    np_ld(V,PP,C0,C).

np_np_ld_pp(V,C0,C) :-
    pp_ld_arg(PP),
    np_np_ld(V,PP,C0,C).

refl_np_ld_pp(V,C0,C) :-
    pp_ld_arg(PP),
    refl_np_ld(V,PP,C0,C).

np_np_ld_adv(V,C0,C) :-
    ld_adv_arg(PP),
    np_np_ld(V,PP,C0,C).

np_ld_adv(V,C0,C) :-
    ld_adv_arg(ADV),
    np_ld(V,ADV,C0,C).

np_ld_dir(V,C0,C) :-
    ld_dir_arg(ADV),
    np_ld(V,ADV,C0,C).

me_ld_dir(V,C0,C) :-
    ld_dir_arg(ADV),
    me_ld(V,ADV,C0,C).

refl_ld(V,LD,C,C) :-
    main_v(V),
    V:passive => no_passive,
    refl_np_arg(Obj,V),
    dependents(V,[ld/LD,se/Obj]).

me_ld(V,LD,C,C) :-
    main_v(V),
    V:passive => no_passive,
    np_me_arg(Obj),
    dependents(V,[ld/LD,me/Obj]).

refl_ld_pp(V,C0,C) :-
    pp_ld_arg(PP),
    refl_ld(V,PP,C0,C).

refl_ld_adv(V,C0,C) :-
    ld_adv_arg(ADV),
    refl_ld(V,ADV,C0,C).

refl_ld_dir(V,C0,C) :-
    ld_dir_arg(ADV),
    refl_ld(V,ADV,C0,C).

%% ik geef de kinderen een boek  (obj2 < obj  )
%% ?ik geef het boek de kinderen (obj  < obj2 )
%% ik geef ze het                (obj2 < obj  )
%% ik geef het ze                (obj  < obj2 )
%% ik geef het de kinderen       (obj  < obj2 )
%%
np_np(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    dat_np_arg(Obj2),
    ndev_if_aux_inf(V,Obj1),
    ndev_if_aux_inf(V,Obj2),
    acc_dat_args(Obj1,Obj2,List),
    dependents(V,List).

%% ik laat ze INF: no v_noun reading
ndev_if_aux_inf(V,Obj1) :-
    V:hstem <=> Stem,
    aux_inf(List),
    Obj1:subn <=> SUBN,
    S => ~sub_indef_verb,
    when(nonvar(Stem),
        (   lists:member(Stem,List)
        ->  SUBN=S
        ;   true
        )
       ).

aux_inf([doe,heb,hoor,laat,leer,vind]).

%% ?? these are bitrans : ik schrik me een hoedje ??
%% ik beeld me die ellende in  ?no-passive?
%% ik beeld het me in
%% ik meet me een pak aan
%% ik meet het me aan
%% always refl < obj1, except pronominals
refl_np(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    acc_np_arg(Obj1),
    refl_np_arg(Obj2,V),
    (   dependents(V,[obj1/Obj1,se/Obj2])
    ;   Obj1:sel => to_left,
	Obj2:sel => to_left,
        Obj1:subn => (sub_def_pron;sub_indef_pron;sub_det),
	dependents(V,[se/Obj2,obj1/Obj1])
    ).

phrasal_subj_of_predicative(sbar,Sdat) :-
    Sdat => sbar,		  
    unify_mods(Sdat),
    Sdat:slash => [],
    Sdat:e_deps => [],
    Sdat:ctype => (c_dat;c_redrel;c_of;c_of_short;c_dip). 


phrasal_subj_of_predicative(sbar,Sdat,su) :-
    Sdat => sbar,		  
    unify_mods(Sdat),
    Sdat:slash => [],
    Sdat:e_deps => [],
    Sdat:ctype => (c_dat;c_redrel;c_of;c_of_short;c_dip). 

%%
%% phrasal_subj_of_predicative(sbar,Sdat,none) :-
%%    Sdat => sbar,		  
%%    unify_mods(Sdat),
%%    Sdat:slash => [],
%%    Sdat:ctype => c_dip.

phrasal_subj_of_predicative(vp,VP,su) :-
    phrasal_subj_of_predicative(vp,VP).

phrasal_subj_of_predicative(vp,VP) :-
    VP => vp,
    unify_mods(VP),
    VP:slash => [],
    VP:cleft => no,
    VP:vform => (om;te).

%% ik ben/word ziek
%% number agreement tussen subject en object?
%% no particle cases? 
copula(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pred_arg(Pred),
    %% GvN: require there is no subject, otherwise
    %% 'ik ben aardig' yields two parse trees
    Pred:e_deps => [],
    dependents(V,[predc/Pred]).

%% die man is 'm
%% dat was 'r
%% ik ben 't
%% ik ben het
%% todo: *hij is zich
%% Angenent was nuchter en hij blééf het .
copula(V,C,C) :-
    main_v(V),
    V:v_noun => no,
    V:hstem ==> Hstem,  % too strong? all copulas that can be clefts?
    when(nonvar(Hstem),
	 lists:member(Hstem,[ben,word,blijf,zijn,worden,blijven])  % also full-form for treex lemma instead of root :-(
	),
    V:passive => no_passive,
    acc_np_arg(Predc),
    Predc:allows_drop => no,
    Predc:wkpro => weakpro,
    Predc:subn => (sub_def_pron;sub_indef_pron;sub_det),
    Predc:nform => norm,
    Predc:redrel => no,
    Predc:hstem ==> Hstem2,
    Predc:prs => (u;thi),  %% added 2012-12-14 'directeur werd je niet ...'
    dif(Hstem2,zich),
    V:subj => np,
    V:subj:nform => norm,
    V:subj:allows_drop => no,
    dependents(V,[predc/Predc]).

incorporated_subj_topic(Frame,V,C0,C) :-
    Frame =.. [F|Args],
    lists:append(Args,[V0,C0,C],Args1),
    Goal =.. [F|Args1],
    call(Goal),
    unify_except_l(V0,V,[subj,ccat,tpart]),
    V:dt:cat ==> smain,		% mark this here, otherwise sv1 is assigned
    V:inv => yes,		% requires V to be fronted
    V:subj => np,
    V:dt:su => [],
    V:tpart => yes,
    V:subj:nform => none.

fixed_dep(Frame,V,C0,C) :-
    Frame =.. [F|Args],
    lists:append(Args,[V,C0,C],Args1),
    Goal =.. [F|Args1],
    call(Goal),
    V:vform => ~fin,
    V:fixed_dep => yes.

nonp_copula(V,C0,C) :-
    copula(V,C0,C),
    V:deps <=> [Pred],
    Pred:pcat => ~np_pred.

ap_copula(V,C0,C) :-
    copula(V,C0,C),
    V:deps <=> [Pred],
    Pred:pcat => ap_pred.

ap_copula(Stem,V,C0,C) :-
    copula(V,C0,C),
    V:deps <=> [Pred],
    Pred:hstem ==> Stem,
    Pred:pcat => ap_pred.

als_copula(V,C0,C) :-
    copula(V,C0,C),
    V:deps <=> [Pred],
    Pred:pcat => als_pred.

pp_copula(Aan,Slag,V,C0,C) :-
    pp_copula(V,Pred,C0,C),
    Pred:hstem ==> Aan,
    Pred:nhstem ==> Slag.

pp_copula(V,C0,C) :-
    pp_copula(V,_Pred,C0,C).
    
pp_copula(V,Pred,C0,C) :-
    copula(V,C0,C),
    V:deps <=> [Pred],
    Pred:pcat => pp_pred.

so_nonp_copula(V,C0,C) :-
    so_copula(V,C0,C),
    V:imper => no,
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

%% het is waarschijnlijk dat hij komt
%% dat hij komt is waarschijnlijk
%% het is bespottelijk om nu te vertrekken
%% om nu te vertrekken is bespottelijk
copula_sbar(V,C0,C) :-
    copula(V,sbar,C0,C).

copula_vp(V,C0,C) :-
    copula(V,vp,C0,C).

nonp_copula_sbar(V,C0,C) :-
    copula_sbar(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

nonp_copula_vp(V,C0,C) :-
    copula_vp(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

ap_copula_sbar(V,C0,C) :-
    copula_sbar(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ap_pred.

ap_copula_vp(V,C0,C) :-
    copula_vp(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ap_pred.

pp_copula_sbar(V,C0,C) :-
    copula_sbar(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => pp_pred.

pp_copula_sbar(Aan,Orde,V,C0,C) :-
    copula_sbar(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:hstem ==> Aan,
    Pred:nhstem ==> Orde,
    Pred:pcat => pp_pred.

pp_copula_vp(V,C0,C) :-
    copula_vp(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => pp_pred.

pp_copula_vp(Aan,Orde,V,C0,C) :-
    copula_vp(V,C0,C),
    V:deps <=> [Pred|_],
    Pred:hstem ==> Aan,
    Pred:nhstem ==> Orde,
    Pred:pcat => pp_pred.

copula(V,Type,C0,C) :-
    copula(V,Type,[],C0,C).

copula(V,Type,MoreArgs,C,C) :-
    main_v(V0),
    V0:passive => no_passive, % consequently, there is no need to mark deps
                              % for passivizability
    unify_except(V0,V,subj),
    pred_arg(Pred),
    (  Pred:slash => []
    ;  Pred:slash <=> [ARG],
       ARG /=> np
    ;  Pred:slash <=> [NP],  %% hoeveel is het waard dat ...
       NP => np,
       NP:nform => ~er & ~cleft_het & ~het_nform & ~refl  
    ),
    
    Pred:e_deps <=> [Sdat],
    phrasal_subj_of_predicative(Type,Sdat),
    lists:append(MoreArgs,[SdatRole/Sdat],Args),
    V:subj <=> Subj,
    Subj => np,
    Subj:pred => npred,
    unify_mods(Subj),
    choice_het_subj_or_topicalize(V,Sdat,SdatRole,Subj,Pred),
    dependents(V,[predc/Pred|Args]).

%% ik ben die lui beu
copula_np(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pred_arg(Pred),
    Pred:e_deps <=> [NP],
    NP => np,
    NP:nform => (norm;het_nform;refl), % het for "eens" etc
                                       % refl for "bewust" etc
    NP:case => acc,
    NP:pred => npred,
    NP:e_deps => [],
    NP:passivizes => no,
    NP:allows_drop => no,
    dependents(V,[predc/Pred,none/NP]).

nonp_copula_np(V,C,C) :-
    copula_np(V,C,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

%% hij lijkt mij die lui beu
so_copula_np(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pred_arg(Pred),
    Pred:e_deps <=> [NP],
    nowh_exp_dat_np_arg(OBJ),
    NP => np,
    NP:case => acc,
    NP:pred => npred,
    NP:e_deps => [],
    NP:nform => (norm;het_nform;refl), % het for "eens"
                                       % refl for "bewust" etc
    NP:passivizes => no,
    NP:allows_drop => no,
    OBJ:dt => dt,
    dependents(V,[predc/Pred,none/NP,obj2/OBJ]).

%% het zijn schurken
%% het zijn schurken die dat doen
%%            relative now introduced by cleft_het_noun
%% DONE: relative ought to be obligatory for sg subjects,
%% because now "het is NP[sg]" is ambiguous :-(
%% DONE: "dat zijn het" in "schurken, dat zijn het allemaal"
%% DONE  "wat zijn dat?"
simple_cleft(V,C,C) :-
    main_v(V0),
    unify_except(V0,V,subj:nform),
    V:cleft => yes,
    V:passive => no_passive,
    V:subj:nform => cleft_het,
    V:subj:cleft_has_rel <=> V:subj:agr,
    acc_np_arg(Predc),
    %    Predc:agr <=> V:subj:agr
    %    this is not required for other copula constructions either
    %    and we need it for "dat zijn het" and "wat zijn het"
    dependents(V,[predc/Predc]).

cleft(V,C0,C) :-
    simple_cleft(V,C0,C).

%% ik ben het die slaapt
%% zij zijn het die het gezicht van de maatschappij bepalen...
cleft(V,C,C) :-
    main_v(V),
    V:cleft => yes,
    V:passive => no_passive,
    V:subj <=> Subj,
    Subj => np,
    Subj:subn => (sub_def_pron;sub_indef_pron;sub_det),  % deze/die waren het, die ...
    acc_np_arg(Predc0),
    unify_except(Predc0,Predc,nform),
    Predc:nform => cleft_het,
    Predc:sel => to_left,         % *het ben ik die dat doet
                                  % nb: leuven_yellow_pages/168:
                                  % *het zijn wij niet die rommel verkopen
    Predc:cleft_has_rel => sg,  % "het" can again be ordinary PREDC
    Subj:agr <=> Predc:agr,  % !
    dependents(V,[predc/Predc]).

%% we no longer allow clefts with sbar-sentences:
%% ?het is op Piet dat ik reken
%% ?het is vandaag dat ik vertrek
%% ?het is naar Assen dat ik fiets
%% etc.

cleft_np(V,C,C) :-
    main_v(V0),
    unify_except(V0,V,subj:nform),
    V:cleft => yes,
    V:passive => no_passive,
    V:subj:nform => cleft_het,
    V:subj:cleft_has_rel <=> V:subj:agr,
    acc_np_arg(Predc),
    dat_np_arg(Obj2),
    %    Predc:agr <=> V:subj:agr
    %    this is not required for other copula constructions either
    %    and we need it for "dat zijn het" and "wat zijn het"
    dependents(V,[predc/Predc,obj2/Obj2]).

%% leuk is dat we niet naar school hoeven
%% ons streven is de wereldvrede dichterbij te brengen
%% de algemene opvatting is dat de WK door zullen gaan
%% logisch is dat de WK worden afgelast
%% dat de kampioenschappen doorgaan verbaast ons
%% but: zoals het ons betaamt
%%
het_subj_or_topicalize(V,Sdat,Subj,Pred) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    het_subj_or_topicalize(V,Sdat,Subj,Pred,HetSubj).

het_subj_or_topicalize(V,Sdat,Subj,_Pred,Subj):-
    (   Sdat => vp
    ;   Sdat => sbar,  Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
                                % Pred *might* be extracted
    deprel(V,sup,Subj).

het_subj_or_topicalize(V,Sdat,Subj,_Pred,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
                                % Pred *might* be extracted
    deprel(V,su,Subj).

het_subj_or_topicalize(_V,Sdat,Subj,Pred,_) :-
    Sdat:sel => to_topic,	% if 'het' is not present, then
                                % either Sdat or Pred is topicalized
    Pred:sel => ~to_topic,
    dummy_subj(Subj).           % and no subject possible

het_subj_or_topicalize(_V,Sdat,Subj,Pred,_) :-
    Pred:sel => to_topic,	% if 'het' is not present, then
                                % either Sdat or Pred is topicalized
    Sdat:sel => ~to_topic,
    dummy_subj(Subj).         % and no subject possible

het_subj_or_topicalize_no_alt(V,Sdat,Subj) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj,HetSubj).

het_subj_or_topicalize_no_alt(V,Sdat,Subj,Subj):-
    (   Sdat => vp
    ;   Sdat => sbar,  Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
    deprel(V,sup,Subj).

het_subj_or_topicalize_no_alt(V,Sdat,Subj,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
    deprel(V,su,Subj).

het_subj_or_topicalize_no_alt(_V,Sdat,Subj,_) :-
    Sdat:sel => to_topic,	% if 'het' is not present, then Sdat topicalized
    dummy_subj(Subj).

%%%%%%%%%%%
opt_het_subj_or_topicalize(V,Sdat,Subj) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    opt_het_subj_or_topicalize(V,Sdat,Subj,HetSubj).

opt_het_subj_or_topicalize(V,Sdat,Subj,Subj):-
    (   Sdat => vp
    ;   Sdat => sbar, Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
                                % Pred *might* be extracted
    deprel(V,sup,Subj).

opt_het_subj_or_topicalize(V,Sdat,Subj,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
                                % Pred *might* be extracted
    deprel(V,su,Subj).

opt_het_subj_or_topicalize(_V,_,Subj,_) :-
    dummy_subj(Subj).         % and no subject possible

het_subj_or_topicalize_or_both(V,Sdat,Subj) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    het_subj_or_topicalize_or_both(V,Sdat,Subj,HetSubj).

het_subj_or_topicalize_or_both(V,Sdat,Subj,Subj):-
    (  Sdat => vp
    ;  Sdat => sbar, Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    deprel(V,sup,Subj).

het_subj_or_topicalize_or_both(V,Sdat,Subj,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    deprel(V,su,Subj).

het_subj_or_topicalize_or_both(_V,Sdat,Subj,_Pred) :-
    Sdat:sel => to_topic,
    dummy_subj(Subj).
%%
opt_het_subj_or_topicalize_or_both(V,Sdat,Subj) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    opt_het_subj_or_topicalize_or_both(V,Sdat,Subj,HetSubj).

%% wel het
opt_het_subj_or_topicalize_or_both(V,Sdat,Subj,Subj):-
    (  Sdat => vp
    ;  Sdat => sbar, Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    deprel(V,sup,Subj).

opt_het_subj_or_topicalize_or_both(V,Sdat,Subj,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    deprel(V,su,Subj).

%% geen het
opt_het_subj_or_topicalize_or_both(_V,_Sdat,Subj,_Pred) :-
    dummy_subj(Subj).

choice_het_subj_or_topicalize(V,Sdat,SdatRole,Subj,Pred) :-
    het_np_subj(HetSubj),
    unify_mods(Subj),
    choice_het_subj_or_topicalize(V,Sdat,SdatRole,Subj,Pred,HetSubj).

%% "het"-subject is present, sbar is realized
%% --> sbar is not realized in topic
%% het is logisch dat hij komt
%% logisch is het dat hij komt
choice_het_subj_or_topicalize(V,Sdat,su,Subj,_Pred,Subj):-
    (   Sdat => vp
    ;   Sdat => sbar, Sdat:ctype => ~c_naar & ~c_dip & ~c_none
    ),
    Sdat:sel => ~to_topic,	% if 'het' is present, Sbar not topicalized
                                % Pred *might* be extracted
    deprel(V,sup,Subj).

%% sbar not realized
%% --> sbar not assigned a role
%%     subject assigned su role
choice_het_subj_or_topicalize(V,Sdat,none,Subj,_Pred,Subj):-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_naar;c_dip;c_none),
    Sdat:sel => ~to_topic,
    deprel(V,su,Subj).

%% "het"-subject is not present then:
%%  either subj_nform => opt_het,
%%      or ( Sdat or Pred ) is topicalized
%% nu is duidelijk merkbaar dat hij komt (opt_het)
%% leuk is dat hij komt
choice_het_subj_or_topicalize(_,Sdat,su,Subj,Pred,_) :-
    dummy_subj(Subj),
    Sdat:subj_nform <=> SJNF,
    Sdat:sel <=> SDATSEL,
    Pred:sel <=> PREDSEL,
    TOPIC => to_topic,
    NTOPIC => ~to_topic,
    OPT_HET => opt_het,
    OBL_HET => obl_het,
    when(nonvar(SJNF),
         ( SJNF = OPT_HET
         ; SJNF = OBL_HET,
           (  SDATSEL = TOPIC,
              PREDSEL = NTOPIC
           ;  SDATSEL = NTOPIC,
              PREDSEL = TOPIC
           )
         )
        ).

%% 'het' subject, or no subject
maybe_het_subj(V,Subj,Sbar) :-
    Sbar:ctype => ~c_dip & ~c_none,
    deprel(V,su,Sbar),
    deprel(V,sup,Subj),
    het_np_subj(Subj).
maybe_het_subj(V,Subj,Sbar) :-
    deprel(V,su,Subj),
    Sbar:ctype => (c_dip;c_none),
    het_np_subj(Subj).
maybe_het_subj(V,Subj,Sbar) :-
    deprel(V,su,Sbar),
    Sbar:ctype => ~c_dip & ~c_none,
    dummy_subj(Subj).

%% dat lijkt me leuk
so_copula_sbar(V,C0,C) :-
    so_copula(V,sbar,C0,C).

so_copula_vp(V,C0,C) :-
    so_copula(V,vp,C0,C).

so_nonp_copula_sbar(V,C0,C) :-
    so_copula(V,sbar,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

so_nonp_copula_vp(V,C0,C) :-
    so_copula(V,vp,C0,C),
    V:deps <=> [Pred|_],
    Pred:pcat => ~np_pred.

so_copula(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    pred_arg(Pred),
    %% GvN: require there is no subject, otherwise
    %% 'dat lijkt me aardig' yields two parse trees
    Pred:e_deps => [],
    nowh_exp_dat_np_arg(OBJ),
    dependents(V,[predc/Pred,obj2/OBJ]).

%% het lijkt me leuk dat hij komt
%% dat hij komt lijkt me leuk
%% het lijkt me bespottelijk om nu te vertrekken
%% om nu te vertrekken lijkt me bespottelijk
so_copula(V,Type,C0,C) :-
    nowh_exp_dat_np_arg(OBJ),
    OBJ:dt => dt,
    copula(V,Type,[obj2/OBJ],C0,C).

%% hij maakt ons het leven moeilijk
%% hij maakt het ons moeilijk
so_pred_np(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    pred_arg(Pred),
    Pred:pcat => (ap_pred;pp_pred),  % we maken het jullie naar de zin
    exp_dat_np_arg(Obj2),
    Pred:e_deps => [],
    acc_dat_args(Obj1,Obj2,List),
    dependents(V,[predc/Pred|List]).

%% hij maakt aan ons de som duidelijk
pp_so_pred_np(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    pred_arg(Pred),
    Pred:pcat => (ap_pred;pp_pred),  
    pp_pc_arg(Obj2,aan),
    Pred:e_deps => [],
    (   dependents(V,[predc/Pred,obj1/Obj1,obj2/Obj2])
    ;   dependents(V,[predc/Pred,obj2/Obj2,obj1/Obj1]),
        Obj1:sel => to_left,
	Obj1:passivizes => no,
        Obj2:sel => to_left
    ).

%% zij maakten het ons aantrekkelijk om te blijven
so_pred_vp(V,C0,C) :-
    so_pred(V,vp,_VP,_OBJ2,C0,C).

%% zij maken het acceptabel dat hij blijft
so_pred_sbar(V,C0,C) :-
    so_pred(V,sbar,_,_,C0,C).

so_pred(V,Type,Sdat,Obj2,C,C) :-
    main_v(V),
    pred_arg(Pred),
    Pred:pcat => ap_pred,
    Pred:slash => [],
    Pred:e_deps <=> [Sdat],
    phrasal_subj_of_predicative(Type,Sdat),
    exp_dat_np_arg(Obj2),
    het_obj_or_topicalize(V,Pred,Sdat,[predc/Pred,obj2/Obj2]).

pp_so_pred_vp(V,C0,C) :-
    pp_so_pred(V,vp,_VP,_OBJ2,C0,C).

pp_so_pred_sbar(V,C0,C) :-
    pp_so_pred(V,sbar,_,_,C0,C).

pp_so_pred(V,Type,Sdat,Obj2,C,C) :-
    main_v(V),
    pred_arg(Pred),
    Pred:pcat => ap_pred,
    Pred:slash => [],
    Pred:e_deps <=> [Sdat],
    phrasal_subj_of_predicative(Type,Sdat),
    pp_pc_arg(Obj2,aan),
    het_obj_or_topicalize(V,Pred,Sdat,[predc/Pred,obj2/Obj2]).

%% ik vind hem eng
%% no part cases?
%% apparantly there are two types of pred_np. Compare:
%% bang: object_sbar_adjective
%% leuk: subject_sbar_adjective
%%
%% ik vind hem leuk
%% ik vind het leuk dat je komt
%% *ik vind het bang dat je komt
%% *het vind hem leuk dat je komt
%% je maakt me bang
%% het maakt me bang dat je komt
%% dat maakt het leuk dat je komt
%% *je maakt het leuk dat je komt
%% *het maakt me leuk dat je komt
pred_np(V,C0,C) :-
    PCAT:pcat => ~voor_pred,
    pred_np(V,PCAT,C0,C).

pred_np(V,Obj2,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    pred_arg(Obj20),
    unify_except(Obj20,Obj2,pcat),
    Obj2:e_deps => [],
%    ndev_if_aux_inf(V,Obj2),  % ik vind dat spijkers op laag water zoeken
    dependents(V,[predc/Obj2,obj1/Obj1]).

%% other ordering only for als_pred
%% ik kies als bestemming dit jaar de eilanden
%% waar is die als_word voor??? vergeten..
pred_np(V,Obj2,[als_word|C],C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    Obj1:sel => to_left,
    Obj1:passivizes => no,
    pred_arg(Obj2),
    Obj2:pcat => als_pred,    
    Obj2:e_deps => [],
    Obj2:sel => to_left,
    dependents(V,[obj1/Obj1,predc/Obj2]).

pred_np_ndev(V,Obj2,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    ndev(Obj1),
    pred_arg(Obj20),
    unify_except(Obj20,Obj2,pcat),
    Obj2:e_deps => [],
    Obj2:avform => ~avform_ppart,
    dependents(V,[predc/Obj2,obj1/Obj1]).

%% other ordering only for als_pred
%% ik kies als bestemming dit jaar de eilanden
pred_np_ndev(V,Obj2,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    ndev(Obj1),
    Obj1:sel => to_left,
    Obj1:passivizes => no,
    pred_arg(Obj2),
    Obj2:pcat => als_pred,    
    Obj2:e_deps => [],
    Obj2:sel => to_left,
    Obj2:avform => ~avform_ppart,
    dependents(V,[obj1/Obj1,predc/Obj2]).


/*
%% ik heb hem gekregen
%% don't use this frame..
pred_np_ndev(V,Obj2,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj1),
    ndev(Obj1),
    pred_arg(Obj2),
    Obj2:e_deps => [],
    Obj2:avform => ~avform_ppart,
    dependents(V,[predc/Obj2,obj1/Obj1]).
*/

nonp_pred_np_ndev(V,C0,C) :-
    pred_np_ndev(V,PCAT,C0,C),
    PCAT:pcat => ~np_pred & ~voor_pred.

nonp_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => ~np_pred & ~voor_pred.

als_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => als_pred.

voor_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => voor_pred.

ap_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => ap_pred.

pp_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => pp_pred.

pp_pred_np(In,Gevaar,V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => pp_pred,
    PCAT:hstem ==> In,
    PCAT:nhstem ==> Gevaar.

np_pred_np(V,C0,C) :-
    pred_np(V,PCAT,C0,C),
    PCAT:pcat => np_pred.

pred_np_sbar(V,C0,C) :-
    Pred:pcat => ~voor_pred,
    pred_np(V,sbar,Pred,C0,C).

pred_np_vp(V,C0,C) :-
    Pred:pcat => ~voor_pred,
    pred_np(V,vp,Pred,C0,C).

pp_pred_np_sbar(V,C0,C) :-
    Pred:pcat => pp_pred,
    pred_np(V,sbar,Pred,C0,C).

pp_pred_np_vp(V,C0,C) :-
    Pred:pcat => pp_pred,
    pred_np(V,vp,Pred,C0,C).

pp_pred_np_sbar(In,Gevaar,V,C0,C) :-
    Pred:pcat => pp_pred,
    pred_np(V,sbar,Pred,C0,C),
    Pred:hstem ==> In,
    Pred:nhstem ==> Gevaar.

pp_pred_np_vp(In,Gevaar,V,C0,C) :-
    Pred:pcat => pp_pred,
    pred_np(V,vp,Pred,C0,C),
    Pred:hstem ==> In,
    Pred:nhstem ==> Gevaar.

als_pred_np_sbar(V,C0,C) :-
    pred_np(V,sbar,Pcat,C0,C),
    Pcat:pcat => als_pred.

voor_pred_np_sbar(V,C0,C) :-
    pred_np(V,sbar,Pcat,C0,C),
    Pcat:pcat => voor_pred.

als_pred_np_vp(V,C0,C) :-
    pred_np(V,vp,Pcat,C0,C),
    Pcat:pcat => als_pred.

voor_pred_np_vp(V,C0,C) :-
    pred_np(V,vp,Pcat,C0,C),
    Pcat:pcat => voor_pred.

pred_np(V,Type,Pred,C,C) :-
    main_v(V),
    pred_arg(Pred0),
    unify_except(Pred0,Pred,pcat),
    Pred:slash => [],
    Pred:e_deps <=> [Sdat],
    phrasal_subj_of_predicative(Type,Sdat),
    het_obj_or_topicalize(V,Pred,Sdat,[predc/Pred]).

%% ik vind het leuk dat je komt
%% leuk vind ik het dat je komt
%% het wordt leuk gevonden dat je komt
%% leuk wordt het gevonden dat je komt
het_obj_or_topicalize(V,_Pred,Sdat,Deps0) :-
    V:passive => norm_passive,
    Obj => np,
    Obj:pred => npred,
    Obj:nform => het_nform,
    Obj:e_deps => [],
    Obj:sel => to_left,
    unify_mods(Obj),
    Sdat:sel => ~to_topic,      % if 'het' obj, then not slashed sbar
                                % Pred *might* be topicalized
    (  lists:append(Deps0,[pobj1/Obj,vc/Sdat],Deps),
       Obj:passivizes => yes
    ;  % if there is obj2, also allow free word-order pobj1/obj2
       % cf: cdb/5527
       lists:append(DepsP0,[obj2/Obj2],Deps0),
       lists:append(DepsP0,[pobj1/Obj,obj2/Obj2,vc/Sdat],Deps),
       Obj:sel => to_left,
       Obj2:sel => to_left,
       Obj2:passivizes => no,
       Obj:passivizes => no
    ),
    dependents(V,Deps).

%% dat je komt vind ik leuk
%% dat je komt wordt leuk gevonden
het_obj_or_topicalize(V,_Pred,Sdat,Deps0) :- 
    V:passive => imp_passive,
    Sdat:sel => to_topic,	% if no 'het' obj, then slashed sbar ..
    lists:append(Deps0,[vc/Sdat],Deps),
    dependents(V,Deps).

%% leuk vind ik dat je komt
%% ?* leuk wordt gevonden dat je komt
het_obj_or_topicalize(V,Pred,Sdat,Deps0) :-
    V:passive => no_passive,
    Pred:sel => to_topic,	% .. or (if no 'het' obj) then slashed pred
    lists:append(Deps0,[vc/Sdat],Deps),
    dependents(V,Deps).

%% some predicates don't need "het"
%% we achten bewezen dat hij komt
het_obj_or_topicalize(V,_Pred,Sdat,Deps0) :-
    Sdat:subj_nform => opt_het,
    V:passive => imp_passive,
    lists:append(Deps0,[vc/Sdat],Deps),
    dependents(V,Deps).

su_ap_pred_sbar(V,C0,C) :-
    su_ap_pred(V,sbar,C0,C).

su_ap_pred_vp(V,C0,C) :-
    su_ap_pred(V,vp,C0,C).

su_ap_pred(V,Arg,C,C) :-
    main_v(V0),
    V:passive => no_passive,
    exp_dat_np_arg(OBJ),
    unify_except(V0,V,subj),
    pred_arg(Pred),
    Pred:slash => [],
    Pred:e_deps => [],
    Pred:pcat => ap_pred,
    phrasal_subj_of_predicative(Arg,Sdat,SuRole),
    (   Arg=sbar,
        Sdat:ctype => (c_dat;c_of;c_redrel)
    ;   Arg=vp
    ),
    dependents(V,[predc/Pred,obj2/OBJ,SuRole/Sdat]),
    V:subj <=> Subj,
    Subj => np,
    Subj:pred => npred,
    het_subj_or_topicalize(V,Sdat,Subj,Pred).

%% dat ik me voorstel(?) om te komen  // niet verpl refl...
%% dat ik me beijver te komen
%% dat ik me voorneem om ..
refl_vp(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    refl_np_arg(Obj2,V),
    subj_control_vp_arg(Obj1,V),
%    Obj1:slash => [],   allow DIP
    % ik kom , haast hij zich te zeggen
    dependents(V,[vc/Obj1,se/Obj2]),
    instantiated_deprel(V,vc,Obj1). 

%% ik voel me goed
pred_refl(V,C0,C) :-
    pred_refl(V,_,C0,C).

pred_refl(V,PCAT,C,C) :-
    main_v(V),
    V:passive => no_passive,
    refl_np_arg(Obj2,V),
    pred_arg(Obj1),
    Obj1:pcat <=> PCAT,
    Obj1:e_deps => [],
    dependents(V,[predc/Obj1,se/Obj2]).

nonp_pred_refl(V,C0,C) :-
    pred_refl(V,PCAT,C0,C),
    PCAT => ~np_pred & ~voor_pred.

np_pred_refl(V,C0,C) :-
    pred_refl(V,PCAT,C0,C),
    PCAT => np_pred.

als_pred_refl(V,C0,C) :-
    pred_refl(V,PCAT,C0,C),
    PCAT => als_pred.

ap_pred_refl(V,C0,C) :-
    pred_refl(V,PCAT,C0,C),
    PCAT => ap_pred.

%% dat ik probeer (om) te komen
%% subject control
vp(V,C,C):-
    main_v(V),
    V:passive => imp_passive,
    subj_control_vp_arg(VP,V),
    dependents(V,[vc/VP]),
    instantiated_deprel(V,vc,VP).

%% dat ik verzoek (om) de uitzending te verbieden
%% no control 
vp_no_control(V,C,C):-
    main_v(V),
    V:passive => imp_passive,
    no_subj_vp_arg(VP),
    dependents(V,[vc/VP]),
    instantiated_deprel(V,vc,VP).

%% ik heb met jou afgesproken niet te komen
pp_vp(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    subj_control_vp_arg(VP,V),
    pp_pc_arg(PP,Prep),
    dependents(V,[vc/VP,pc/PP]),
    instantiated_deprel(V,vc,VP).

%% dat ik hem beloof te komen
%% subject control, with an object
np_vp_subj(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    %%   dative, because the object does not passivize
    %%   *ik werd beloofd te komen
    %%
    dat_np_arg(Obj),
    subj_control_vp_arg(VP,V),
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,vc,VP).

%% dat ik hem beloof te komen
%% subject control, with an object
np_vp_no_control(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    %%   dative, because the object does not passivize
    %%   *ik werd beloofd te komen
    %%
    dat_np_arg(Obj),
    no_subj_vp_arg(VP),
    VP:control => control_none,
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,vc,VP).

%% (indirect) object control
np_vp_obj(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    dat_np_arg(Obj),
    %%   dative, because the object cannot passivize
    obj_control_vp_arg(VP,Obj),
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,vc,VP).

%% todo: control between np in aan-pp and vp... ???
so_vp_subj(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(Obj,aan),
    %%   dative, because the object cannot passivize
    subj_control_vp_arg(VP,V),
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,vc,VP).

%% todo: control between np in aan-pp and vp... ???
so_vp_no_control(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(Obj,aan),
    %%   dative, because the object cannot passivize
    no_subj_vp_arg(VP),
    VP:control => control_none,
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,vc,VP).

so_vp_obj(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_pc_arg(Obj,aan),
    %%   dative, because the object cannot passivize
    so_control_vp_arg(VP,Obj),
    dependents(V,[vc/VP,obj2/Obj]),
    instantiated_deprel(V,obj2,Obj),
    instantiated_deprel(V,vc,VP).

%% (direct) object control
np_vp_obj1(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    acc_np_arg(Obj),
    %%   accusative, because the object can passivize
    obj_control_vp_arg(VP,Obj),
    dependents(V,[vc/VP,obj1/Obj]),
    instantiated_deprel(V,vc,VP).

%% dat ik weet dat ze komt
%% dat ik me inbeeld dat ze komt ?? (niet verpl refl) 
sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    sbar_arg(Obj),
    dependents(V,[vc/Obj]).

dip_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    dip_sbar_arg(Obj),
    dependents(V,[vc/Obj]).

alsof_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    alsof_sbar_arg(Obj),
    dependents(V,[predc/Obj]).

van_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    van_sbar_arg(Obj),
    dependents(V,[vc/Obj]),
    instantiated_deprel(V,vc,Obj).

so_van_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    van_sbar_arg(Obj),
    pp_pc_arg(PP,aan),
    dependents(V,[obj2/PP,vc/Obj]).

so_pp_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    sbar_arg(Obj),
    pp_pc_arg(PP,aan),
    dependents(V,[obj2/PP,vc/Obj]).

so_pp_vp(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    subj_control_vp_arg(VP,V),
    pp_pc_arg(PP,aan),
    dependents(V,[vc/VP,obj2/PP]).

tr_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    transparant_sbar_arg(Obj),
    dependents(V,[vc/Obj]).

%% dat ik haar vertel dat jan komt
np_sbar(V,C,C) :-
    main_v(V),
    sbar_arg(Obj),
    dat_np_arg(Obj2),
    dependents(V,[vc/Obj,obj2/Obj2]).

%% dat hij er achterkwam dat..
er_sbar(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    sbar_arg(SBAR),
    SBAR:ctype => ~c_dip & ~c_none,
    er_np_arg(ER),
    ER:sel => to_left,
    dependents(V,[pobj1/ER,vc/SBAR]).

%% dat hij er niet ingeslaagd was een oplossing te vinden
er_vp(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    no_subj_vp_arg(SBAR),
    SBAR:control => control_subj,
    V:subj <=> Subj,
    control(SBAR,Subj),
    er_np_arg(ER),
    ER:sel => to_left,
    dependents(V,[pobj1/ER,vc/SBAR]).

np_alsof_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    alsof_sbar_arg(Obj),
    dat_np_arg(Obj2),
    dependents(V,[predc/Obj,obj2/Obj2]).

acc_np_sbar(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    sbar_arg(Obj),
    acc_np_arg(Obj1),
    dependents(V,[vc/Obj,obj1/Obj1]).
%% TODO?: require Obj:slash => [] in case not a `bridge-verb'

acc_np_dip_sbar(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,
    dip_sbar_arg(Obj),
    acc_np_arg(Obj1),
    dependents(V,[vc/Obj,obj1/Obj1]).

%% dat ik van jou aanneem dat ze niet komt
pp_sbar(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    sbar_arg(Obj),
    pp_pc_arg(PP,Prep),
    dependents(V,[vc/Obj,pc/PP]).

ld_pp_sbar(V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    sbar_arg(Obj),
    pp_ld_arg(PP),
    dependents(V,[vc/Obj,ld/PP]).

pp_dip_sbar(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    dip_sbar_arg(Obj),
    pp_pc_arg(PP,Prep),
    dependents(V,[vc/Obj,pc/PP]).

%% dat brengt met zich mee dat we te laat komen
pp_refl_sbar(Prep,V,C,C) :-
    main_v(V),
    V:passive => imp_passive,
    pp_refl_pc_arg(PP,Prep),
    PP:nagr <=> V:subj:prs,
    sbar_arg(Obj),
    dependents(V,[pc/PP,vc/Obj]).

%% dat ik me afvraag of ze komt
refl_sbar(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    sbar_arg(Obj),
    refl_np_arg(Refl,V),
    dependents(V,[vc/Obj,se/Refl]).

%% het regent
het_subj(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    dependents(V,[]),
    V:subj <=> Subj,
    het_np_subj(Subj),
    deprel(V,su,Subj).

%% het vriest dat het kraakt
%% het regent dat het giet
het_subj_sbar_obcomp(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    dependents(V,[obcomp/SBAR]),
    V:subj <=> Subj,
    het_np_subj(Subj),
    deprel(V,su,Subj),
    sbar_arg(SBAR),
    SBAR:slash => [],
    SBAR:ctype => c_dat.

%% zo geschiedde
no_subj(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    dependents(V,[]),
    V:subj <=> Subj,
    Subj => np,
    dummy_subj(Subj).

% er zijn er die [relative clause]
% 'er' obligatory
% always plural
% todo: according to ANS there could also be a PP
% er zijn er ook met stippeltjes
% todo: er zijn er ook bij die ..
%       je hebt er ook bij die ..
er_er(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    V:subj <=> Subj,
    Subj => np,
    Subj:nform => none,
    Subj:agr => pl,
    Subj:prs => thi,
    Rel => rel,
    Rel:dt <=> RelDt,
    Rel:relform => relform_fin,
    unify_mods(Rel),
    Rel:agr <=> Subj:agr, % * er zijn er die slaapt
    Er => np,
    dependents(V,[none/Rel,su/Er]),
    Er:wh => nwh,
    Er:nform => er,
    Er:hstem ==> er,
    Er:sel => to_left,
    Er:mods <=> [RelDt|Mods],
    Er:cmods <=> Mods,
    Er:e_deps => [],
    Er:dets <=> Er:cdets,
    Er:apps <=> Er:capps,
    Er:predms <=> Er:cpredms,
    Er:ccat0 <=> Er:ccat.

obj_er_er(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    dependents(V,[none/Rel,obj1/Er]),
    V:subj <=> Subj,
    Subj => np,
    Subj:prs => (invje;ninvje),
    Subj:agr => sg,
    Subj:wkpro => weakpro,
    Rel => rel,
    Rel:dt <=> RelDt,
    Rel:relform => relform_fin,
    unify_mods(Rel),
    Rel:agr => pl,
    Er => np,
    Er:nform => er,
    Er:hstem ==> er,
    Er:wh => nwh,
    Er:sel => to_left,
    Er:mods   <=> [RelDt|Mods],
    Er:cmods  <=> Mods,
    Er:e_deps => [],
    Er:dets   <=> Er:cdets,
    Er:apps   <=> Er:capps,
    Er:predms <=> Er:cpredms,
    Er:ccat0  <=> Er:ccat.

%% in fact, these can *either* take a temporary 'het' subject
%%                    *or* topicalize the sbar phrase
%%
%% het valt me op dat Arie komt
%% dat Arie komt valt me op


%% TODO: add constraint if real SBAR is selected
s_subj(V,Sdat,Subj,Deps) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    (   (  Sdat => vp
        ;  Sdat => sbar, Sdat:ctype => ~c_naar & ~c_dip & ~c_none
        ),
        lists:append(Deps,[su/Sdat],VDeps)
    ;   Sdat => sbar,
	Sdat:e_deps => [],
        Sdat:ctype => (c_naar;c_dip;c_none),
        lists:append(Deps,[none/Sdat],VDeps)
    ),
    dependents(V,VDeps),
    Sdat:slash => [],           % *jan bleek het dat ik kuste
    unify_mods(Sdat),
    V:subj <=> Subj,
    Subj => np,
    Subj:pred => npred.

naar_sbar_subj_arg(Sdat,su) :-
    Sdat => sbar,
    Sdat:slash => [],
    Sdat:e_deps => [],
    unify_mods(Sdat),
    Sdat:ctype => (c_dat;c_of;c_redrel).

naar_sbar_subj_arg(Sdat,none) :-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:slash => [],
    unify_mods(Sdat),
    Sdat:ctype => c_naar.

sbar_subj_arg(Sdat) :-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:slash => [],
    unify_mods(Sdat),
    Sdat:ctype => (c_dat;c_of;c_of_short;c_redrel).

dip_sbar_subj_arg(Sdat) :-
    Sdat => sbar,
    Sdat:slash => [],
    Sdat:e_deps => [],
    unify_mods(Sdat),
    Sdat:ctype => (c_dat;c_of;c_of_short;c_redrel;c_dip;c_naar).

sbar_subj(V,Sdat,Subj,Deps) :-
    sbar_subj_arg(Sdat),
    s_subj(V,Sdat,Subj,Deps).

dip_sbar_subj(V,Sdat,Subj,Deps) :-
    dip_sbar_subj_arg(Sdat),
    s_subj(V,Sdat,Subj,Deps).

vp_subj(V,Sdat,Subj,Deps) :-
    no_subj_vp_arg(Sdat),
    s_subj(V,Sdat,Subj,Deps).

sbar_subj_no_het(V,C,C) :-
    sbar_subj(V,_Sdat,Subj,[]),
    dummy_subj(Subj).

dip_sbar_subj_no_het(V,C,C) :-
    dip_sbar_subj(V,_Sdat,Subj,[]),
    dummy_subj(Subj).

%% we moeten , lijkt , naar huis
%% we moeten , lijkt het , naar huis
%% 'het' is possible even in case of topicalization. If het is
%% not present, then topicalization of sbar is obligatory
dip_sbar_subj(V,C,C) :-
    dip_sbar_subj(V,Sdat,Subj,[]),
    het_np_subj(Subj),
    Sdat:ctype => ~c_naar & ~c_dip & ~c_none,
    deprel(V,sup,Subj).

dip_sbar_subj(V,C,C) :-
    dip_sbar_subj(V,Sdat0,Subj,[]),
    unify_except(Sdat0,Sdat,dt),
    het_np_subj(Subj),
    Sdat:ctype => (c_naar;c_dip;c_none),
    deprel(V,su,Subj).

dip_sbar_subj_so_np(V,C,C) :-
    exp_dat_np_arg(Obj),
    dip_sbar_subj(V,Sdat,Subj,[obj2/Obj]),
    het_np_subj(Subj),
    Sdat:ctype => ~c_naar & ~c_dip & ~c_none,
    deprel(V,sup,Subj).

dip_sbar_subj_so_np(V,C,C) :-
    exp_dat_np_arg(Obj),
    dip_sbar_subj(V,Sdat0,Subj,[obj2/Obj]),
    unify_except(Sdat0,Sdat,dt),
    het_np_subj(Subj),
    Sdat:ctype => (c_naar;c_dip;c_none),
    deprel(V,su,Subj).

dip_sbar_subj_opt_het(V,C0,C) :-
    dip_sbar_subj(V,C0,C).

dip_sbar_subj_opt_het(V,C0,C) :-
    dip_sbar_subj_no_het(V,C0,C).

van_sbar_subj_no_het(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    dependents(V,[su/Sdat]),
    van_sbar_arg(Sdat),
    V:subj <=> Subj,
    Subj => np,
    dummy_subj(Subj).
    
van_sbar_subj_so_np_no_het(V,C,C) :-
    main_v(V0),
    V0:passive => no_passive,
    unify_except(V0,V,subj),
    exp_dat_np_arg(Obj),
    dependents(V,[obj2/Obj,su/Sdat]),
    van_sbar_arg(Sdat),
    V:subj <=> Subj,
    Subj => np,
    dummy_subj(Subj).
    
%% vast staat dat hij komt
sbar_subj_no_het_tpart(V,C0,C) :-
    sbar_subj_no_het(V0,C0,C),
    unify_except(V0,V,tpart),
    V:tpart => yes.

pp_sbar_subj_no_het(Prep,V,C,C) :-
    pp_pc_arg(PP,Prep),
    dip_sbar_subj(V,_Sdat,Subj,[pc/PP]),
    dummy_subj(Subj).

er_sbar_subj_no_het(V,C,C) :-
    r_np_arg(NP),
    dip_sbar_subj(V,_Sdat,Subj,[pc/NP]),
    dummy_subj(Subj).

%% hij komt , zo staat in het rapport
ld_pp_sbar_subj_no_het(V,C,C) :-
    pp_ld_arg(PP),
    dip_sbar_subj(V,_Sdat,Subj,[ld/PP]),
    dummy_subj(Subj).

ld_adv_sbar_subj_no_het(V,C,C) :-
    ld_adv_arg(ADV),
    dip_sbar_subj(V,_Sdat,Subj,[ld/ADV]),
    dummy_subj(Subj).

sbar_subj_so_np_no_het(V,C,C) :-
    exp_dat_np_arg(Obj),
    sbar_subj(V,_Sdat,Subj,[obj2/Obj]),
    dummy_subj(Subj).

sbar_subj_np_no_het(V,C,C) :-
    acc_np_arg(Obj),
    sbar_subj(V,_Sdat,Subj,[obj1/Obj]),
    dummy_subj(Subj).

sbar_subj_refl_no_het(V,C,C) :-
    refl_np_arg(Obj),
    sbar_subj(V,_Sdat,Subj,[se/Obj]),
    dummy_subj(Subj).

sbar_subj_refl_opt_het(V,C,C) :-
    refl_np_arg(Obj),
    sbar_subj(V,Sdat,Subj,[se/Obj]),
    opt_het_subj_or_topicalize(V,Sdat,Subj).

sbar_subj(V,C,C) :-
    sbar_subj(V,Sdat,Subj,[]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

%% "het" required
%% "dat" required
%%
%% het is, dat ik je vader ben (maar anders ..)
%% het is, dat ik je mag (maar anders ..)
%% het is, of ik je al jaren ken
sbar_subj_het(V,C,C) :-
    sbar_subj(V,Sdat,Subj,[]),
    Subj:nform => het_nform,
    Subj:e_deps => [],
    unify_mods(Subj),
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => (c_dat;c_of),
    Sdat:sel => ~to_topic,
    Sdat:e_deps => [],
    deprel(V,sup,Subj).

sbar_subj_opt_het(V,C,C) :-
    sbar_subj(V,Sdat,Subj,[]),
    opt_het_subj_or_topicalize(V,Sdat,Subj).

alsof_sbar_subj(V,C,C) :-
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => c_alsof,
    s_subj(V,Sdat,Subj,[]),
    Sdat:sel => ~to_topic,
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

sbar_obj(V,C,C) :-
    main_v(V),
    V:passive <=> Passive,   % het wordt betreurd dat je komt
    sbar_arg(Sdat),
    Sdat:slash => [],
    Sdat:ctype => (c_of;c_dat),
    het_obj_or_topicalize(Sdat,Deps,Passive),
    dependents(V,Deps).

sbar_obj_opt_het(V,C,C) :-
    main_v(V),
    V:passive <=> Passive,   % het wordt betreurd dat je komt
    sbar_arg(Sdat),
    Sdat:slash => [],
    Sdat:ctype => (c_of;c_dat),
    opt_het_obj_or_topicalize(Sdat,Deps,Passive),
    dependents(V,Deps).

sbar_obj_no_het(V,C,C) :-
    main_v(V),
    V:passive => no_passive,
    sbar_arg(Sdat),
    Sdat:sel => ~to_topic,  % already by sbar_obj()
    Sdat:ctype => (c_of;c_dat),
    dependents(V,[vc/Sdat]).

pp_sbar_obj(Prep,V,C,C) :-
    main_v(V),
    pp_pc_arg(PP,Prep),
    V:passive <=> Passive,
    sbar_arg(Sdat),
    Sdat:ctype => (c_of;c_dat),
    het_obj_or_topicalize(Sdat,Deps,Passive),
    dependents(V,[pc/PP|Deps]).

so_pp_sbar_obj(V,C,C) :-
    main_v(V),
    so_pp_arg(PP,aan),
    V:passive <=> Passive,
    sbar_arg(Sdat),
    Sdat:ctype => (c_of;c_dat),
    het_obj_or_topicalize(Sdat,Deps,Passive),
    dependents(V,[obj2/PP|Deps]).

so_np_sbar_obj(V,C,C) :-
    main_v(V),
    exp_dat_np_arg(Obj2),
    V:passive <=> Passive,
    sbar_arg(Sdat),
    Sdat:ctype => (c_of;c_dat),
    het_obj_or_topicalize(Sdat,Deps,Passive),
    dependents(V,[obj2/Obj2|Deps]).

%% hij waagde het , de minster aan te vallen
vp_obj(V,C,C) :-
    main_v(V),
    V:passive => norm_passive,   % ?? het werd gewaagd de minster aan te vallen
    V:subj <=> Subj,
    vp_arg(VP),
    VP:slash => [],
    het_obj_or_topicalize(VP,Deps),
    dependents(V,Deps),
    VP:control => control_subj,
    control(VP,Subj).

%% ik gun het hem, om ...
so_np_vp_obj(V,C,C) :-
    main_v(V),
    exp_dat_np_arg(Obj2),
    V:passive <=> Passive,  % het werd hem gegund...
    vp_arg(VP),
    VP:slash => [],
    het_obj_or_topicalize(VP,Deps,Passive),
    dependents(V,[obj2/Obj2|Deps]),
    VP:control => control_subj,
    control(VP,Obj2).

%% hij haalde het in zijn hoofd om...
pp_vp_obj(Prep,V,C,C) :-
    main_v(V),
    pp_pc_arg(PP,Prep),
    V:passive => norm_passive,	% ?? het werd in het hoofd gehaald
				% de minster aan te vallen
    V:subj <=> Subj,
    vp_arg(VP),
    VP:slash => [],
    het_obj_or_topicalize(VP,Deps),
    dependents(V,[pc/PP|Deps]),
    VP:control => control_subj,
    control(VP,Subj).

%% hij neemt het op zich om...
refl_pp_vp_obj(Prep,V,C,C) :-
    main_v(V),
    pp_refl_pc_arg(PP,Prep),
    V:passive => norm_passive,	% ?? het werd in het hoofd gehaald
				% de minster aan te vallen
    V:subj <=> Subj,
    vp_arg(VP),
    VP:slash => [],
    het_obj_or_topicalize(VP,Deps),
    dependents(V,[pc/PP|Deps]),
    VP:control => control_subj,
    control(VP,Subj).

het_obj_or_topicalize(A,B) :-
    het_obj_or_topicalize(A,B,_).

het_obj_or_topicalize(Sdat,[vc/Sdat,pobj1/Obj],Passive):-
    Passive => norm_passive,
    Obj => np,
    unify_mods(Obj),
    Obj:case => acc,
    Obj:sel => to_left,
    Obj:nform => het_nform,
    Obj:e_deps => [],
    Sdat:sel => ~to_topic.
het_obj_or_topicalize(Sdat,[vc/Sdat],Passive) :-
    Passive => imp_passive,
    Sdat:sel => to_topic.

opt_het_obj_or_topicalize(Sdat,[vc/Sdat,pobj1/Obj],Passive):-
    Passive => norm_passive,
    Obj => np,
    unify_mods(Obj),
    Obj:case => acc,
    Obj:sel => to_left,
    Obj:nform => het_nform,
    Obj:e_deps => [],
    Sdat:sel => ~to_topic.
opt_het_obj_or_topicalize(Sdat,[vc/Sdat],Passive) :-
    Passive => imp_passive.

pp_sbar_subj(Prep,V,C,C) :-
    pp_pc_arg(PP,Prep),
    sbar_subj(V,Sdat,Subj,[pc/PP]),
    het_subj_or_topicalize(V,Sdat,Subj,PP).

pp_sbar_subj_opt_het(Prep,V,C,C) :-
    pp_pc_arg(PP,Prep),
    sbar_subj(V,Sdat,Subj,[pc/PP]),
    opt_het_subj_or_topicalize(V,Sdat,Subj).

sbar_subj_so_np(V,C,C) :-
    exp_dat_np_arg(Obj),
    sbar_subj(V,Sdat,Subj,[obj2/Obj]),
    het_subj_or_topicalize(V,Sdat,Subj,Obj).

sbar_subj_so_pp(V,C,C) :-
    so_pp_arg(Obj,aan),
    sbar_subj(V,Sdat,Subj,[obj2/Obj]),
    het_subj_or_topicalize(V,Sdat,Subj,Obj).

sbar_subj_so_np_opt_het(V,C,C) :-
    exp_dat_np_arg(Obj),
    sbar_subj(V,Sdat,Subj,[obj2/Obj]),
    opt_het_subj_or_topicalize(V,Sdat,Subj).

dip_sbar_subj_so_np_no_het(V,C,C) :-
    exp_dat_np_arg(Obj),
    dip_sbar_subj(V,_Sdat,Subj,[obj2/Obj]),
    dummy_subj(Subj).

dip_sbar_subj_so_np_opt_het(V,C,C) :-
    exp_dat_np_arg(Obj),
    dip_sbar_subj(V,Sdat,Subj,[obj2/Obj]),
    opt_het_subj_or_topicalize_or_both(V,Sdat,Subj).

alsof_sbar_subj_so_np(V,C,C) :-
    exp_dat_np_arg(Obj),
    Sdat => sbar,
    Sdat:e_deps => [],
    Sdat:ctype => c_alsof,
    s_subj(V,Sdat,Subj,[obj2/Obj]),
    Sdat:sel => ~to_topic,
    het_subj_or_topicalize(V,Sdat,Subj,Obj).

sbar_subj_np(V,C,C) :-
    acc_np_arg(Obj),
    sbar_subj(V,Sdat,Subj,[obj1/Obj]),
    het_subj_or_topicalize(V,Sdat,Subj,Obj).

sbar_subj_np_np(V,C,C) :-
    acc_np_arg(Obj1),
    dat_np_arg(Obj2),
    sbar_subj(V,Sdat,Subj,[obj1/Obj1,obj2/Obj2]),
    het_subj_or_topicalize(V,Sdat,Subj,Obj2).
 
sbar_subj_meas(V,C,C) :-
    np_me_arg(Obj),
    sbar_subj(V,Sdat,Subj,[me/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

sbar_subj_dat_meas(V,C,C) :-
    np_me_arg(Meas),
    dat_np_arg(Obj),
    sbar_subj(V,Sdat,Subj,[me/Meas,obj2/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_no_het(V,C,C) :-
    vp_subj(V,_Sdat,Subj,[]),
    dummy_subj(Subj).

pp_vp_subj_no_het(Prep,V,C,C) :-
    pp_pc_arg(PP,Prep),
    vp_subj(V,_Sdat,Subj,[pc/PP]),
    dummy_subj(Subj).
    
vp_subj_np_no_het(V,C,C) :-
    acc_np_arg(Obj),
    vp_subj(V,_Sdat,Subj,[obj1/Obj]),
    dummy_subj(Subj).

vp_subj_so_np_no_het(V,C,C) :-
    exp_dat_np_arg(Obj),
    vp_subj(V,_Sdat,Subj,[obj2/Obj]),
    dummy_subj(Subj).

vp_subj(V,C,C) :-
    vp_subj(V,Sdat,Subj,[]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

pp_vp_subj(Prep,V,C,C) :-
    pp_pc_arg(PP,Prep),
    vp_subj(V,Sdat,Subj,[pc/PP]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_np(V,C,C) :-
    acc_np_arg(Obj),
    vp_subj(V,Sdat,Subj,[obj1/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_np_np(V,C,C) :-
    acc_np_arg(Obj1),
    dat_np_arg(Obj2),
    vp_subj(V,Sdat,Subj,[obj1/Obj1,obj2/Obj2]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_so_np(V,C,C) :-
    exp_dat_np_arg(Obj),
    vp_subj(V,Sdat,Subj,[obj2/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_so_pp(V,C,C) :-
    so_pp_arg(Obj,aan),
    vp_subj(V,Sdat,Subj,[obj2/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_meas(V,C,C) :-
    np_me_arg(Obj),
    vp_subj(V,Sdat,Subj,[me/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_adv_meas(V,C,C) :-
    me_adv_arg(Obj),
    vp_subj(V,Sdat,Subj,[me/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

sbar_subj_adv_meas(V,C,C) :-
    me_adv_arg(Obj),
    sbar_subj(V,Sdat,Subj,[me/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

vp_subj_dat_meas(V,C,C) :-
    np_me_arg(Meas),
    dat_np_arg(Obj),
    vp_subj(V,Sdat,Subj,[me/Meas,obj2/Obj]),
    het_subj_or_topicalize_no_alt(V,Sdat,Subj).

%% hij slaagt er vandaag niet in het debat te ontwijken
%% * het debat slaagt hij er vandaag niet in te ontwijken
%% * daar is hij in geslaagd het debat te ontwijken
%% * het debat te ontwijken is hij daar in geslaagd
%% * in is hij daar geslaagd het debat te ontwijken

%% die oplossing komt er op neer dat hij komt
%% DONE: sbar ==> edeps waar het om gaat is dat hij komt
er_pc_pp(Prep,V,VP,PP,C,C) :-
    main_v(V),
    VP:slash => [], 
    pp_pc_arg(PP0,Prep),
    unify_except(PP0,PP,pp_role),
    PP:pp_role => pp_pobj1,
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:cj => ncj,
    PP:hcj => ncj,
    PP:sel => ~to_topic,
    instantiated_deprel(V,pc,PP),
    instantiated_deprel(PP,vc,VP),
    unify_mods(VP).

er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc],V),
    VP:sel => ~to_topic,
    V:deps <=> [PP,VP].

er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    initialize_dt([su,sup,pc],V),
    unify_except(V0,V,e_deps),
    V:deps <=> [PP],
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

%% hij heeft ons er van overtuigd te komen
%% waar hij ons van heeft overtuigd is dat hij zal komen
np_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc,obj1],V),
    acc_np_arg(ACC),
    V:deps <=> [PP,ACC,VP],
    VP:sel => ~to_topic,
    deprel(V,obj1,ACC).

np_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    unify_except(V0,V,e_deps),
    acc_np_arg(ACC),
    initialize_dt([su,sup,pc,obj1],V),
    V:deps <=> [PP,ACC],
    deprel(V,obj1,ACC),
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

meas_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc,me],V),
    np_me_arg(ACC),
    V:deps <=> [PP,ACC,VP],
    VP:sel => ~to_topic,
    deprel(V,me,ACC).

meas_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    unify_except(V0,V,e_deps),
    np_me_arg(ACC),
    initialize_dt([su,sup,pc,me],V),
    V:deps <=> [PP,ACC],
    deprel(V,me,ACC),
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

adv_meas_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc,me],V),
    me_adv_arg(ACC),
    V:deps <=> [PP,ACC,VP],
    VP:sel => ~to_topic,
    deprel(V,me,ACC).

adv_meas_er_pc_pp(Prep,V,VP,ACC,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    initialize_dt([su,sup,pc,me],V),
    unify_except(V0,V,e_deps),
    me_adv_arg(ACC),
    V:deps <=> [PP,ACC],
    deprel(V,me,ACC),
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

pred_er_pp_sbar(Prep,V,C0,C) :-
    SBAR => sbar,
    SBAR:e_deps => [],
    SBAR:ctype => (c_dat;c_redrel;c_of;c_of_short),
    pred_er_pc_pp(Prep,V,SBAR,C0,C).

pred_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    pred_er_pc_pp(Prep,V,VP,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).

%% ik word er niet goed/een ander mens van dat hij komt
%% waar ik niet goed van word is dat hij komt
pred_er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc,predc],V),
    VP:sel => ~to_topic,
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    (	V:deps <=> [PP,PRED,VP]
    ;	PRED:sel => to_left,
	PP:sel => to_left,
	PP:slash => [],
	V:deps <=> [PRED,PP,VP]
    ),
    instantiated_deprel(V,predc,PRED).

pred_er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    unify_except(V0,V,e_deps),
    initialize_dt([su,sup,pc,predc],V),
    pred_arg(PRED),
    PRED:e_deps => [],
    PRED:slash => [],
    PRED:pcat => ap_pred,
    PRED:sel => to_left,
    PP:sel => to_left,
    PP:slash <=> [_],
    V:deps <=> [PP,PRED],
    instantiated_deprel(V,predc,PRED),
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

refl_er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V,VP,PP,C0,C),
    initialize_dt([su,sup,pc,se],V),
    VP:sel => ~to_topic,
    refl_np_arg(ACC,V),
    V:deps <=> [PP,ACC,VP],
    instantiated_deprel(V,se,ACC).

refl_er_pc_pp(Prep,V,VP,C0,C) :-
    er_pc_pp(Prep,V0,VP,PP,C0,C),
    initialize_dt([su,sup,pc,se],V),
    unify_except(V0,V,e_deps),
    refl_np_arg(ACC,V),
    V:deps <=> [PP,ACC],
    instantiated_deprel(V,se,ACC),
    V:e_deps <=> [VP],
    VP:subj_nform => obl_het.

er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    er_pc_pp(Prep,V,VP,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).

er_pp_vp_no_control(Prep,V,C0,C):-
    no_subj_vp_arg(VP),
    er_pc_pp(Prep,V,VP,C0,C).

np_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    np_er_pc_pp(Prep,V,VP,_,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).

meas_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    meas_er_pc_pp(Prep,V,VP,_,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).

adv_meas_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    adv_meas_er_pc_pp(Prep,V,VP,_,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).

obj_np_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    np_er_pc_pp(Prep,V,VP,OBJ,C0,C),
    VP:control => control_obj,
    control(VP,OBJ).

refl_er_pp_vp(Prep,V,C0,C):-
    vp_arg(VP),
    refl_er_pc_pp(Prep,V,VP,C0,C),
    V:subj <=> Subj,
    VP:control => control_subj,
    control(VP,Subj).      % ?

%% ik reken er op dat hij komt
%% ? ik vroeg er naar wat de gevolgen zijn
er_pp_sbar(Prep,V,C0,C) :-
    SBAR => sbar,
    SBAR:e_deps => [],
    SBAR:ctype => (c_dat;c_redrel;c_of;c_of_short),
    er_pc_pp(Prep,V,SBAR,C0,C).

np_er_pp_sbar(Prep,V,C,C0) :-
    SBAR => sbar,
    SBAR:e_deps => [],
    SBAR:ctype => (c_dat;c_redrel;c_of;c_of_short),
    np_er_pc_pp(Prep,V,SBAR,_,C0,C).

refl_er_pp_sbar(Prep,V,C0,C) :-
    SBAR => sbar,
    SBAR:e_deps => [],
    SBAR:ctype => (c_dat;c_redrel;c_of;c_of_short),
    refl_er_pc_pp(Prep,V,SBAR,C0,C).

%% fixed expressions
fixed(Deps,Passive,V,C,C) :-
    main_v(V0),
    assign_passive(Passive,V0),
    map_deps_list(Deps,Deps2,[],V0,V1),
    v_dependents(V1,V,Deps2).

assign_passive(no_passive,V) :-
    V:passive => no_passive.
assign_passive(norm_passive,V) :-
    V:passive => norm_passive.
assign_passive(imp_passive,V) :-
    V:passive => imp_passive.
assign_passive(none,_).
assign_passive(Val,_) :-
    \+ lists:member(Val,[no_passive,norm_passive,imp_passive,none]),
    format(user_error,"ERROR: wrong value for passive: ~w~n",[Val]),
    fail.

map_deps_list([],L,L,V,V).
map_deps_list([Abb|Abbs],Deps0,Deps,V0,V) :-
    map_deps(Abb,Deps0,Deps1,V0,V1),
    map_deps_list(Abbs,Deps1,Deps,V1,V).

%% prevent spurious ambiguities in case acc is topicalized:
%% dat wij eer aan deze zaak behalen
%% dat wij aan deze zaak eer behalen
map_deps({[acc,pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),acc],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(acc),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),acc]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),acc],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(acc),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),dat]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[dat,pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[er_pp(Prep,VAR),dat]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,VAR),dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),er_pp(Prep,VAR)],Deps0,Deps,V0,V)
    ).

map_deps({[dat,er_pp(Prep,VAR)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,VAR),dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),er_pp(Prep,VAR)],Deps0,Deps,V0,V)
    ).

map_deps({[acc(Acc),pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),acc(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(acc(Acc)),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),acc(Acc)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),acc(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(acc(Acc)),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[ap_pred,pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),ap_pred],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(ap_pred),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),ap_pred]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),ap_pred],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(ap_pred),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[ap_pred,er_pp(Prep,X)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,X),ap_pred],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(ap_pred),er_pp(Prep,X)],Deps0,Deps,V0,V)
    ).

map_deps({[er_pp(Prep,X),ap_pred]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,X),ap_pred],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(ap_pred),er_pp(Prep,X)],Deps0,Deps,V0,V)
    ).

map_deps({[[FH|FT],pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([[FH|FT],inv(pc(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([pc(Prep),[FH|FT]],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),[FH|FT]]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([[FH|FT],inv(pc(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([pc(Prep),[FH|FT]],Deps0,Deps,V0,V)
    ).

map_deps({[svp_pp(In,Conflict),pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),svp_pp(In,Conflict)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(svp_pp(In,Conflict)),inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),svp_pp(In,Conflict)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),svp_pp(In,Conflict)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(svp_pp(In,Conflict)),inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[np_pred(Acc),pc(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),np_pred(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(np_pred(Acc)),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[pc(Prep),np_pred(Acc)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([pc(Prep),np_pred(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(np_pred(Acc)),nsl_inv(pc(Prep))],Deps0,Deps,V0,V)
    ).

map_deps({[np_pred(Acc),er_pp(Prep,X)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,X),np_pred(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(np_pred(Acc)),er_pp(Prep,X)],Deps0,Deps,V0,V)
    ).

map_deps({[er_pp(Prep,X),np_pred(Acc)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([er_pp(Prep,X),np_pred(Acc)],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(np_pred(Acc)),er_pp(Prep,X)],Deps0,Deps,V0,V)
    ).

map_deps({[acc,dat]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([acc,dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),inv_pron_acc],Deps0,Deps,V0,V)
    ).

map_deps({[dat,acc]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([acc,dat],Deps0,Deps,V0,V)
    ;  map_deps_list([inv(dat),inv_pron_acc],Deps0,Deps,V0,V)
    ).

map_deps({[acc,dat_pp(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([inv(acc),nsl_inv(dat_pp(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([dat_pp(Prep),acc],Deps0,Deps,V0,V)
    ).

map_deps({[dat_pp(Prep),acc]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([inv(acc),nsl_inv(dat_pp(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([dat_pp(Prep),acc],Deps0,Deps,V0,V)
    ).

map_deps({[acc(Acc),dat_pp(Prep)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([inv(acc(Acc)),nsl_inv(dat_pp(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([dat_pp(Prep),acc(Acc)],Deps0,Deps,V0,V)
    ).

map_deps({[dat_pp(Prep),acc(Acc)]},Deps0,Deps,V0,V) :-
    !,
    (  map_deps_list([inv(acc(Acc)),nsl_inv(dat_pp(Prep))],Deps0,Deps,V0,V)
    ;  map_deps_list([dat_pp(Prep),acc(Acc)],Deps0,Deps,V0,V)
    ).

map_deps({List},Deps0,Deps,V0,V) :-
    !,
    map_deps_union(List,Deps0,Deps,V0,V).
map_deps(het_pobj1(Dep),Deps0,Deps,V0,V) :-
    !,
    (	map_deps_list([het_pobj1,nt(Dep)],Deps0,Deps,V0,V)
    ;	map_deps(yt(Dep),Deps0,Deps,V0,V)
    ).
map_deps(opt_het_pobj1(Dep),Deps0,Deps,V0,V) :-
    !,
    (	map_deps_list([het_pobj1,nt(Dep)],Deps0,Deps,V0,V)
    ;	map_deps(Dep,Deps0,Deps,V0,V)
    ).
map_deps(Dep,[Role/Cat|Deps],Deps,V0,V) :-
    map_dep(Dep,Role,Cat,V0,V).

map_deps_union([],Deps,Deps,V,V).
map_deps_union([H|T],[Role/Cat|Deps0],Deps,V0,V) :-
    lists:select(Dep,[H|T],Apps),
    map_dep(Dep,Role,Cat,V0,V1),
    map_deps_union(Apps,Deps0,Deps,V1,V).

map_dep(Dep,Role,Cat,V,V) :-
    map_dep(Dep,Role,Cat,V).

% sdat_subj
map_dep(het_subj,het_subj,_,_).  % cf fdependents below
map_dep(no_subj,no_subj,_,_).
map_dep(sbar_subj,sbar_subj(su),Sbar,_V) :-
    sbar_subj_arg(Sbar).
map_dep(naar_sbar_subj,sbar_subj(Role),Sbar,_V) :-
    naar_sbar_subj_arg(Sbar,Role).
map_dep(naar_sbar_subj_no_het,sbar_subj_no_het,Sbar,_V) :-
    naar_sbar_subj_arg(Sbar,none).    
map_dep(vp_subj,sbar_subj(su),Sbar,_V) :-
    no_subj_vp_arg(Sbar),
    Sbar:slash => [].
map_dep(sbar_subj_no_het,sbar_subj_no_het,Sbar,_V) :-
    sbar_subj_arg(Sbar).
map_dep(sbar_subj_opt_het,sbar_subj_opt_het,Sbar,_V) :-
    sbar_subj_arg(Sbar).
map_dep(vp_subj_no_het,sbar_subj_no_het,Sbar,_V) :-
    no_subj_vp_arg(Sbar),
    Sbar:slash => [].
map_dep(refl,se,NP,V) :-
    refl_np_arg(NP,V).
map_dep(pc(Prep),pc,PP,_):-
    pp_arg(PP,Prep),
    PP:ld_pc => (ld_pp;pc_pp),
    PP:nnform => ~refl,
    PP:haspart => no.
map_dep(mod_pp(Prep),mod,PP,_) :-
    pp_pc_arg(PP,Prep),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic.
map_dep(nor_mod_pp(Prep),mod,PP,_) :-
    pp_pc_arg(PP,Prep),
    PP:pp_er => no,
    PP:wh => nwh,
    PP:sel => ~to_topic.
map_dep(pp_refl(Prep),pc,PP,_) :-
    pp_refl_pc_arg(PP,Prep).
map_dep(ld_pp,ld,PP,_):-
    pp_ld_arg(PP).
map_dep(ld_adv,ld,ADV,_):-
    ld_adv_arg(ADV).
map_dep([W|Ws],svp,Fixed,_):-
    fixed_arg(Fixed,pred,[W|Ws]).
map_dep(op_een_v,svp,Fixed,_) :-
    fixed_arg(Fixed,pred,op_een_v).
map_dep(sbar,vc,Sbar,_) :-
    sbar_arg(Sbar).
map_dep(dat_sbar,vc,Sbar,_) :-
    sbar_arg(Sbar),
    Sbar:ctype => c_dat.
map_dep(dip_sbar,vc,Sbar,_) :-
    dip_sbar_arg(Sbar).
map_dep(adv_meas,me,Meas,_) :-
    me_adv_arg(Meas).
map_dep(meas,me,Meas,_) :-
    np_me_arg(Meas).
map_dep(van_sbar,vc,Sbar,_) :-
    van_sbar_arg(Sbar).
map_dep(pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:e_deps => [].
map_dep(nonp_pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:pcat => ~np_pred & ~voor_pred,
    Pred:e_deps => [].
map_dep(np_pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:pcat => np_pred,
    Pred:e_deps => [].
map_dep(als_pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:pcat => als_pred,
    Pred:e_deps => [].
map_dep(ap_pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:pcat => ap_pred,
    Pred:e_deps => [].
map_dep(pp_pred,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:pcat => pp_pred,
    Pred:e_deps => [].
map_dep(pp_pred(IN,AS),predc,Pred,_) :-
    pred_arg(Pred),
    Pred:dt => dt,
    Pred:hstem ==> IN,
    Pred:nhstem ==> AS,
    Pred:slash => [],
    Pred:pcat => pp_pred,
    Pred:e_deps => [].
map_dep(ap_pred(STEM),predc,Pred,_) :-
    pred_arg(Pred),
    Pred:dt => dt,
%    Pred:slash => [],  % ik bracht hem er toen van op de hoogte
    Pred:hstem ==> STEM,
    Pred:pcat => ap_pred,
    Pred:e_deps => [].
map_dep(ap_svp(STEM),svp,Pred,_) :-
    pred_arg(Pred),
    Pred:dt => dt,
    Pred:slash => [],  
    Pred:hstem ==> STEM,
    Pred:pcat => ap_pred,
    Pred:e_deps => [].
map_dep(adv(STEM),predc,Pred,_) :-
    Pred => adv,
    unify_mods(Pred),
    Pred:dt => dt,
    Pred:hstem ==> STEM.
map_dep(np_pred(Stem),predc,NP,_) :-
    acc_np_arg(NP),
    NP:dt => dt,
    NP:subn => sub_noun,
    NP:hstem ==> Stem.
map_dep(compar,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:dt => dt,
    Pred:pcat => ap_pred,
    Pred:cform => compar,
    Pred:e_deps => [].
map_dep(rang,predc,Pred,_) :-
    pred_arg(Pred),
    Pred:slash => [],
    Pred:dt => dt,
    Pred:pcat => ap_pred,
    Pred:cform => rang,
    Pred:e_deps => [].
map_dep(acc,obj1,NP,_) :-
    acc_np_arg(NP).
map_dep(inv_pron_acc,REL,NP,V) :-
    map_dep(inv(acc),REL,NP,V),
    NP:subn => (sub_def_pron;sub_indef_pron;sub_det).
map_dep(inv_pron_acc(ACC),REL,NP,V) :-
    map_dep(inv(acc(ACC)),REL,NP,V),
    NP:subn => (sub_def_pron;sub_indef_pron;sub_det).
map_dep(svp_er,svp,NP,_) :-
    er_np_arg(NP).
map_dep(acc(Stem),obj1,NP,_) :-
    acc_np_arg(NP),
    NP:dt => dt,
    NP:allows_drop => no,
    NP:subn => (sub_noun;sub_def_verb;sub_indef_verb;sub_def_adj),  % meerdere erkennen in
    NP:hstem ==> Stem.
map_dep(svp_dat(Stem),svp,NP,_) :-
    dat_np_arg(NP),
    NP:dt => dt,
    NP:allows_drop => no,
    NP:subn => (sub_noun;sub_def_verb;sub_indef_verb;sub_def_pron;sub_indef_pron),
    NP:hstem ==> Stem.
map_dep(svp_acc(Stem),svp,NP,_) :-
    acc_np_arg(NP),
    NP:allows_drop => no,
    NP:dt => dt,
    NP:subn => (sub_noun;sub_def_verb;sub_indef_verb;sub_def_adj),
    NP:hstem ==> Stem.
map_dep(inv(El),REL,CAT,V) :-
    map_dep(El,REL,CAT,V),
    CAT:sel =?> to_left,
    CAT:passivizes =?> no.
map_dep(nsl_inv(El),REL,CAT,V) :-
    map_dep(El,REL,CAT,V),
    CAT:sel =?> to_left,
    CAT:slash => [],
    CAT:passivizes =?> no.
map_dep(me,me,NP,_) :-
    np_me_arg(NP).
map_dep(dat,obj2,NP,_) :-
    dat_np_arg(NP).
map_dep(dat_pp(Prep),obj2,PP,_) :-
    so_pp_arg(PP,Prep).
map_dep(svp_pp(Voor,Rekening),svp,PP,_) :-
    pp_pc_arg(PP,Voor),
    PP:slash => [],
    PP:nhstem ==> Rekening.
map_dep(vp,vc,VP,V) :-
    subj_control_vp_arg(VP,V).
map_dep(vp_no_control,vc,VP,_V) :-
    no_subj_vp_arg(VP).
map_dep(obj_vp(Obj),vc,VP,_V) :-
    obj_control_vp_arg(VP,Obj).
map_dep(i(Abb,Cat),Rel,Cat,V) :-
    map_dep(Abb,Rel,Cat,V).
map_dep(het_obj1,obj1,Cat,_) :-
    Cat => np,
    unify_mods(Cat),
    Cat:nform => het_nform,
    Cat:e_deps => [],
    Cat:passivizes => no,
    Cat:case => acc,
    Cat:sel => ~to_topic.
%% TODO: if corresponding sbar/vp topicalized, then no 'het'...
%% TODO: passivization is possible??? Het werd mij toegestaan dat/om ...
map_dep(het_pobj1,pobj1,Cat,_) :-
    Cat => np,
    unify_mods(Cat),
    Cat:nform => het_nform,
    Cat:passivizes => no,
    Cat:e_deps => [],
    Cat:case => acc,
    Cat:sel => to_left.
map_dep(extra_vp(Cat),extra,Cat,V):-
    Cat:slash => [],
    Cat:sel => ~to_topic,
    subj_control_vp_arg(Cat,V).
map_dep(extra_obj_vp(Cat,Obj),extra,Cat,_V):-
    Cat:sel => ~to_topic,
    Cat:slash => [],
    obj_control_vp_arg(Cat,Obj).
map_dep(extra_sbar(Cat),extra,Cat,_):-
    sbar_arg(Cat),
    Cat:sel => ~to_topic.
map_dep(er_pp(Prep,VC),pc,PP,_):-
    ( VC => vp ; VC => sbar ),
    pp_pc_arg(PP0,Prep),
    unify_except(PP0,PP,pp_role),
    PP:pp_role => pp_pobj1,
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => to_left,
    PP:cj => ncj, % x heeft scherpe kritiek daarop en daarvan dat ...; problems 2nd phase
    deprel(PP,vc,VC).
map_dep(er_pp(Prep),pc,PP,_):-
    pp_pc_arg(PP,Prep),
    PP:wh => nwh,
    PP:pp_er => yes,
    PP:sel => ~to_topic.
map_dep(svp_er_pp(Prep),svp,PP,_):-
    pp_pc_arg(PP,Prep),
    PP:wh => nwh,
    PP:pp_er => yes,
    PP:sel => ~to_topic.
map_dep(yt(Cat),Role,Sign,V) :-
    map_dep(Cat,Role,Sign,V),
    Sign:sel => to_topic.
map_dep(nt(Cat),Role,Sign,V) :-
    map_dep(Cat,Role,Sign,V),
    Sign:sel => ~to_topic.
map_dep(subj(Stem),none,none,V) :-
    V:subj:dt => dt,
    V:subj:allows_drop => no,
    V:subj:nform => norm,
    V:subj:subn => sub_noun,
    V:cj => ncj,
    V:subj:hstem <=> Stem.
map_dep(vc(Stem,Vform,Frame),svp,VP,V0,V) :-
    unify_except(V0,V,parts),
    VP => vc,
    V:parts <=> VP:parts,
    VP:e_deps => [],
    VP:vslash => [],
    VP:slash => [],
    VP:exs => [],
    VP:mexs => [],
    VP:vframe ==> Frame,
    unify_mods(VP),
    VP:sc => [],
    VP:fixed_dep => yes,
    assign_vform_of_vc(Vform,VP),
    VP:hstem ==> Stem.

%% auxiliary stuff for analysis of fixed phrases
fixed_arg(Sign,Cat,Words) :-
    Sign => fixed_part,
    initialize_dt([],Sign),
    unify_mods(Sign),
    Sign:cat => Cat,
    Sign:words ==> Words.

fixed_part(Ws,Sign) :-
    Sign => fixed_part,
    initialize_dt([],Sign),
    sign(Sign,fixed),
    Sign:words ==> Ws.

a_dependents(V0,V,Dependents) :-
    a_deps(Dependents,V0,V1),
    fdependents(Dependents,Deps,V1,V2),
    unify_except(V2,V,sc),
    V:sc <=> Deps.

a_deps([],V,V).
a_deps([Rel/_|Deps],V0,V) :-
    a_dep(Rel,V0,V1),!,
    a_deps(Deps,V1,V).

a_dep(svp,V,V).
a_dep(extra,V,V).
a_dep(none,V,V).
a_dep(sbar_subj(su),V0,V) :-
    unify_except(V0,V,dt:su).
a_dep(sbar_subj_opt_het,V0,V) :-
    unify_except(V0,V,dt:su).
a_dep(sbar_subj_no_het,V0,V) :-
    unify_except(V0,V,dt:su).
a_dep(het_subj,V0,V) :-
    unify_except(V0,V,dt:su).
a_dep(no_subj,V,V).
a_dep(mod,V,V).
a_dep(REL,V0,V) :-
    unify_except(V0,V,dt:REL).


v_dependents(V0,V,Dependents) :-
    dep_roles(Dependents,Roles),
    initialize_dt([su,sup|Roles],V0),
    fdependents(Dependents,Deps,V0,V),
    V:deps <=> Deps.

fdependents([],[],V,V).
fdependents([DepRel/Dep|Dependents],Deps1,V0,V) :-
    (	DepRel == svp
    ->	add_svp(V0,V1,Dep),
	Deps1=[Dep|Deps]
    ;	DepRel == extra
    ->	(   V0 = V1,
            Deps1=[Dep|Deps]
        ;   unify_except(V0,V1,e_deps),
            V0:e_deps <=> ED,
            V1:e_deps <=> [Dep|ED],
            Dep:subj_nform => obl_het,
            Deps=Deps1
        )
    ;	DepRel == none
    ->	V0 = V1,
	Deps1=Deps
    ;   DepRel == sbar_subj(su)
    ->  unify_except(V0,V1,subj),
	Deps1=[Dep|Deps],
	V1:subj <=> Subj,
	Subj => np,
	Subj:pred => npred,
	deprel(V1,su,Dep),
	het_subj_or_topicalize_or_both(V1,Dep,Subj)
    ;   DepRel == sbar_subj(none)
    ->  unify_except(V0,V1,subj),
	Deps1=[Dep|Deps],
	V1:subj <=> Subj,
	Subj => np,
	Subj:pred => npred,
	het_subj_or_topicalize_or_both(V1,Dep,Subj)
    ;   DepRel == sbar_subj_opt_het
    ->  unify_except(V0,V1,subj),
	Deps1=[Dep|Deps],
	V1:subj <=> Subj,
	Subj => np,
	Subj:pred => npred,
	deprel(V1,su,Dep),
	opt_het_subj_or_topicalize(V1,Dep,Subj)
    ;   DepRel == sbar_subj_no_het
    ->  unify_except(V0,V1,subj),
	Deps1=[Dep|Deps],
	V1:subj <=> Subj,
	Subj => np,
	deprel(V1,su,Dep),
	dummy_subj(Subj)
    ;	DepRel == het_subj
    ->	unify_except(V0,V1,subj),
	V1:subj <=> Subj,
	het_np_subj(Subj),
	deprel(V1,su,Subj),
	Deps1=Deps
    ;	DepRel == no_subj
    ->	unify_except(V0,V1,subj),
	V1:subj <=> Subj,
	Subj => np,
	dummy_subj(Subj),
	Subj:agr => sg,
	Subj:prs => thi,
	Deps1=Deps
    ;   DepRel == mod
    ->  add_mod_dep(V0,V1,Dep),
        Deps1=[Dep|Deps]
    ;	DepRel == pc
    ->  instantiated_deprel(V0,DepRel,Dep),
	Deps1=[Dep|Deps],
	V0 = V1
    ;	DepRel == ld
    ->  instantiated_deprel(V0,DepRel,Dep),
	Deps1=[Dep|Deps],
	V0 = V1
    ;	DepRel == se
    ->  instantiated_deprel(V0,DepRel,Dep),
	Deps1=[Dep|Deps],
	V0 = V1
    ;	deprel(V0,DepRel,Dep),
	Deps1=[Dep|Deps],
	V0 = V1
    ),
    fdependents(Dependents,Deps,V1,V).


%%% auxiliaries/modals/control/aci etc.
%%%
%% there is a distinction between auxiliary verbs and subject control
%% verbs:
%%
%% auxiliaries: no subject of their own, no modifiers of their own,
%%              no complements of their own.
%% subject raising: no subject of their own, no complements of their own,
%%              modifiers CAN attach to embedded verbs
%% subject control: no complements of their own, but they have their
%%              own subject (whose dt is shared with embedded subject)
%%              and modifiers CAN attach to them, but can also attach
%%              to embedded verb
%%
%% viz:
%% het heeft geregend
%% er wordt gedanst
%% dat ik vandaag(i) heb gedanst(i)
%% ??? dat ik vandaag(i) heb(i) gedanst
%%
%% het schijnt te regen
%% er schijnt te worden gedanst
%% dat ik vandaag(i) schijn(i) te dansen
%% dat ik vandaag(i) schijn te dansen(i)
%%
%% * het probeert te regenen
%% * er probeert te worden gedanst
%% dat ik vandaag(i) probeer(i) te dansen
%% dat ik vandaag(i) probeer te dansen(i)

assign_vform_of_vc(te_inf,V) :-
    V => vc,
    V:vform => (te;inf).
assign_vform_of_vc(inf,V) :-
    V => vc,
    V:vform => inf.
assign_vform_of_vc(psp,V) :-
    V => vc,
    V:vform => psp.
assign_vform_of_vc(te,V) :-
    V => vc,
    V:vform => te.
assign_vform_of_vc(wk_te,V) :-
    V => vc,
    V:vform => wk_te.
assign_vform_of_vc(aan_het,V) :-
    V => vc,
%    V:sel => to_left,   % impossible, since 'ik ben aan het slapen'
                         % would not be generated anymore, due to
                         % hack in v_v_pspgap to reduce spurious ambiguities..
    V:vform => aan_het.
assign_vform_of_vc(op,V) :-
    V => vc,
%    V:sel => to_left,   % impossible, since 'ik ben aan het slapen'
                         % would not be generated anymore, due to
                         % hack in v_v_pspgap to reduce spurious ambiguities..
    V:vform => op.
assign_vform_of_vc(uit,V) :-
    V => vc,
%    V:sel => to_left,   % impossible, since 'ik ben aan het slapen'
                         % would not be generated anymore, due to
                         % hack in v_v_pspgap to reduce spurious ambiguities..
    V:vform => uit.
assign_vform_of_vc(pass_te,V) :-
    V => vc,
    V:vform => pass_te,
    V:vtype => vmain.
%%% hij komt aangelopen
%%% toen hij aan kwam gelopen ...
assign_vform_of_vc(psp(Frame),V) :- 
    V => vc,
    V:vform => psp,
    V:vframe ==> Frame.

%% auxiliaries
%% these inherit their complements from, and give away their modifiers
%% to their verbal complement
%% in addition, they are agnostic about nform of subj

aux(Vform,Sign,C0,C) :-
    assign_vform_of_vc(Vform,Arg),
    aux(Arg,_,Sign,C0,C).

%% "wil" and "mocht" allow sv1 modifiers
%% het moet raar lopen wil hij komen
%% these are recognized later using vframe
modifier(aux(Vform),Sign,C0,C) :-
    aux(Vform,Sign0,C0,C),
    overwrite(Sign0,Sign,sv1_mod,yes).

modifier(tr_sbar,Sign,C0,C) :-
    tr_sbar(Sign0,C0,C),
    overwrite(Sign0,Sign,sv1_mod,yes).

%% only select vc headed by main verbs
aux_simple(inf,Sign,C0,C) :-
    aux(inf,Sign,C0,C),
    Sign:deps <=> [VP],
    Sign:subj <=> NP,
    NP:agr => de,  % hack?  * het/dit/dat was oppassen/uitkijken/...
                   %  poor man's version of +human???
                   %        * regeren is keuzes maken (in that reading)
                   %  still, this frame yields many false analyses :-(
    NP:subn => (sub_def_adj;sub_name;sub_noun;sub_def_pron;sub_indef_pron;sub_det),
    VP => vc,
    VP:hebben_zijn => hebben,
    VP:vtype => vmain,
    VP:vframe ==> FRAME,
    when(nonvar(FRAME),
         lists:member(FRAME,[intransitive,   % we zijn fietsen
                             ld_pp,          % we zijn wezen duiken naar...
                             transitive,     % we zijn kersen plukken
                             transitive_ndev % we zijn boodschappen doen
                            ])).

so_aux(Vform,Sign,C0,C) :-
    assign_vform_of_vc(Vform,Arg),
    so_aux(Arg,_,Sign,C0,C).

%% laten we gaan =/= we laten gaan
%% ? laten jullie nou eens ophouden met..
%% laten ze ophouden
inverted_aux(Vform,Sign,C0,C) :-
    aux(Vform,Sign,C0,C),
    Sign:vform => fin,
    Sign:tense => present,
    Sign:slash => [],
%    subject_verb_agreement(Sign,pl),   % laat ik dat maar 'ns doen
    Sign:inv => yes.

aux_psp_hebben(Sign,C0,C) :-
    assign_vform_of_vc(psp,VP),
    HzVal => hebben,
    aux(VP,HzVal,Sign,C0,C),
    Sign:imper => no.

aux_psp_zijn(Sign,C0,C) :-
    assign_vform_of_vc(psp,VP),
    HzVal => (zijn;unacc),
    aux(VP,HzVal,Sign,C0,C),
    Sign:imper => no.

simple_aux_psp_zijn(Sign,C0,C) :-
    assign_vform_of_vc(psp,VP),
    VP:vtype => vmain,
    HzVal => (zijn;unacc),
    aux(VP,HzVal,Sign,C0,C),
    Sign:imper => no.

%% ik heb geslapen
%% ik ben gekomen
%% ik kan/mag/moet/zal/ga/kom slapen
%% ik hoef/dien/kom te slapen
%% auxiliaries with subject raising/modifier raising
aux(VP,HZ,V,C,C) :-
    aux_v(V,VP),
    imper(V),
    V:vtype => vaux,
    V:act => act,
    dependents(V,[vc/VP]),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    VP:subj <=> V:subj,
    VP:hebben_zijn <=> HZ.

so_aux(VP,HZ,V,C,C) :-
    aux_v(V,VP),
    imper(V),
    V:vtype => vaux,
    V:act => act,
    dependents(V,[vc/VP,obj2/DAT]),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    exp_dat_np_arg(DAT),
    VP:subj <=> V:subj,
    VP:hebben_zijn <=> HZ.

imper(Sign) :-
    Sign:hstem <=> Stem,
    no_imper_list(List),
    Sign:imper <=> IMPER,
    NO => no,
    when(nonvar(Stem),
	 (   lists:member(Stem,List)
	 ->  IMPER=NO
	 ;   true
	 )
	).

no_imper_list([kan,wil,zal,blijk,dien,heet,hoef,hoor,lijk,mag,moet,schijn]).

%% subject control verbs.
%% modifier control/raising both possible
%% dreigen, durven, proberen, wensen
subj_control(Vform,Sign,C,C) :-
    assign_vform_of_vc(Vform,Arg),
    subj_control_aux(Arg,Sign).

subj_control_aux(VP,V) :-
    aux_v(V,VP),
    main_v_subj(V),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    V:vtype => vcontrol,
    V:act => act,
    dependents(V,[vc/VP]),
    V:subj <=> Subj,
    control(VP,Subj).

%% de kinderen zijn aan het boeken lezen
%% de kinderen zijn boeken aan het lezen
aan_het(V,C0,C) :-
    aux(VP,_,V0,C0,C),
    overwrite(V0,V,vtype,vaanhet),
    assign_vform_of_vc(aan_het,VP).

%% TODO Inheritance of modifiers
%% uit eten bij X met Y is fijn
%% ??
%% vooral uit eten bij X met Y is fijn...
uit(V,C0,C) :-
    aux(VP,_,V0,C0,C),
%    VP:mods <=> VP:cmods,
    overwrite(V0,V,vtype,vaanhet),
    assign_vform_of_vc(uit,VP).

%% de dijk staat op doorbreken
op_frame(V,C0,C) :-
    aux(VP,_,V0,C0,C),
    VP:mods <=> VP:cmods,
    overwrite(V0,V,vtype,vmain),
    assign_vform_of_vc(op,VP).

%% object control verbs. 
%% ik krijg kinderen te logeren
obj_control(Vform,V,C,C) :-
    assign_vform_of_vc(Vform,VP),
    aux_v(V,VP),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    main_v_subj(V),
    V:vtype => vcontrol,
    V:act => act,
    dependents(V,[vc/VP,obj1/NP]),
    acc_np_arg(NP),
    control(VP,NP).

%% ik krijg de kinderen aan het boeken lezen
%% * ik krijg de kinderen boeken aan het lezen
%% this is not a VP, because
%% --> always preceeds verb-cluster
%% --> would otherwise require new rules in vp
np_aan_het(V,C,C) :-
    aux_v(V0,VP),
    unify_except(V0,V,passive),
    assign_vform_of_vc(aan_het,VP),
    main_v_subj(V),
    V:vtype => vaanhet,   % passive, and get modifiers
    V:act => act,
    dependents(V,[vc/VP,obj1/OBJ]),
    acc_np_arg(OBJ),		
    VP:sc => [],		% !!
    VP:slash => [],		% !!
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    control(VP,OBJ).

np_uit(V,C,C) :-
    aux_v(V0,VP),
    unify_except(V0,V,passive),
    V:passive => norm_passive,
    assign_vform_of_vc(uit,VP),
    main_v_subj(V),
    V:vtype => vaanhet,  % hij werd uit eten gestuurd met het buurmeisje
    V:act => act,
    dependents(V,[vc/VP,obj1/OBJ]),
    acc_np_arg(OBJ),		
    VP:sc => [],		% !!
    VP:slash => [],		% !!
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    control(VP,OBJ).

%% so (obj2) control raising verbs. 
%% similar, but with secondary object
%% "ik gaf hem de boeken te lezen"
%% "ik gaf     de boeken te lezen"
%% In addition, the obj2 is always optional
%% this doesn't allow: "ik gaf de boeken aan hem te lezen" since
%% we can't have control through pp (yet) ...
so_control(Vform,V,C,C) :-
    assign_vform_of_vc(Vform,VP),
    aux_v(V,VP),
    main_v_subj(V),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    V:vtype => vcontrol,
    V:act => act,
    (	dependents(V,[vc/VP,obj2/OBJ]),
        dat_np_arg(OBJ),
	control(VP,OBJ)
    ;	dependents(V,[vc/VP])
    ).

aci(Sign,C,C) :-
    assign_vform_of_vc(inf,VP),
    aci_aux(VP,Sign).

%% vc must be main verb
aci_simple(Sign,C,C) :-
    aci_aux(VP,Sign),
    assign_vform_of_vc(inf,VP),
    VP:vtype => vmain,
    VP:vframe ==> FRAME,
    when(nonvar(FRAME),
         lists:member(FRAME,[intransitive,        % ik heb nog boeken liggen
                             ld_pp,               % ik heb daar paarden lopen
                             part_intransitive(_) % ik heb boeken klaarliggen 
                            ])).

%% the infamous ACI
aci_aux(VP,V) :-
    aux_v(V,VP),
    main_v_subj(V),
    V:vtype => vcontrol,
    V:act => act,
    dependents(V,[vc/VP,obj1/Obj]),
    Obj => np,
    Obj:e_deps => [],
    Obj:pred => npred,
    unify_mods(Obj),
    Obj:case => acc,
    VP:subj <=> Obj,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    ndev(Obj).

%% het boek waarover ik hoor spreken
%% ik help de olifanten voeren
%% *ik help regenen
%% *ik help schurken zijn die dat doen
aci_no_obj(V,C,C) :-
    aux_v(V,VP),
    assign_vform_of_vc(inf,VP),
    VP:cleft => no,
    VP:subj => np,
    VP:subj:nform => norm,
    VP:subj:hstem ==> [],
    main_v_subj(V),
    V:vtype => vcontrol,
    V:act => act,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    dependents(V,[vc/VP]).

passive(V,C0,C) :-
    assign_vform_of_vc(psp,VP),
    passive(V,VP,C0,C).

%% only personal passive?
norm_passive(V,C0,C) :-
    passive_verb(V0,VP,C0,C),
    unify_except(V0,V,subj:nform),    
    assign_vform_of_vc(psp,VP),
    V:act => norm_pas.

sbar_passive(V,C0,C) :-
    passive_verb(V0,VP,C0,C),
    unify_except(V0,V,subj:nform),    
    assign_vform_of_vc(psp,VP),
    V:act => sbar_pas.

te_passive(V,C0,C) :-
    assign_vform_of_vc(pass_te,VP),
    passive(V,VP,C0,C).

%% hij voelt zich in de kou gezet
%% hij heeft zich in de kou gezet gevoeld
refl_passive(V,C,C) :-
    aux_v(V,VP),
    main_v_subj(V),
    assign_vform_of_vc(psp,VP),
    V:vtype => vcontrol,
    V:act => refl_pas,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    refl_np_arg(Refl,V),
    V:dt:se => dt,
    dependents(V,[vc/VP,se/Refl]),
    VP:hebben_zijn => ~unacc,
    VP:passive => norm_passive.

%% hij zag haar voor problemen gesteld
%% %% ik krijg die rommel nooit op tijd opgeruimd
obj1_passive(V,C,C) :-
    aux_v(V,VP),
    main_v_subj(V),
    assign_vform_of_vc(psp,VP),
    V:vtype => vcontrol,
    V:act => obj1_pas,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    acc_np_arg(Obj1),
    dependents(V,[vc/VP,obj1/Obj1]),
    V:dt:obj1 => dt,
    VP:hebben_zijn => ~unacc,
    VP:passive => norm_passive.

%% todo: dat hij komt vind ik te billijken
obj1_te_passive(V,C,C) :-
    aux_v(V,VP),
    main_v_subj(V),
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    assign_vform_of_vc(pass_te,VP),
    V:vtype => vcontrol,
    Obj1 => np,
    dependents(V,[vc/VP,obj1/Obj1]),
    V:act => obj1_pas,
    VP:hebben_zijn => ~unacc,
    VP:passive => norm_passive.

sbar_subj_te_passive(V,C0,C) :-
    te_passive(V0,C0,C),
    unify_except_l(V0,V,[subj,act]),  
    V:act => sbar_subj_te_pas.

passive(V,VP,C0,C) :-
    passive_verb(V0,VP,C0,C),
    unify_except(V0,V,subj:nform),    
    V:act => pas.

so_passive(V,C0,C) :-
    assign_vform_of_vc(psp,VP),
    so_passive(V,VP,C0,C).

so_passive(V,VP,C0,C):-
    passive_verb(V,VP,C0,C),
    V:act => so_pas.

passive_verb(V,VP,C,C) :-
    aux_v(V,VP),
    main_v_subj(V),
    V:imper => no,
    V:vtype => vaux,
    dependents(V,[vc/VP]),
    VP:dt => dt,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    VP:hebben_zijn => ~unacc,
    VP:vtype => (vmain;vaanhet).

passive_verb(V,VP,[er_word,tag(preposition(door,[heen]))|C],C) :-
    aux_v(V0,VP),
    main_v_subj(V0),
    pp_pc_arg(PP,door),
    PP:pp_er => yes,
    PP:wh => nwh,
    PP:sel => ~to_topic,
    V0:imper => no,
    V0:vtype => vaux,
    dependents(V0,V,[vc/VP,mod/PP]),
    VP:dt => dt,
    VP:predms <=> VP:cpredms,
    VP:dets <=> VP:cdets,
    VP:apps <=> VP:capps,
    VP:hebben_zijn => ~unacc,
    VP:vtype => (vmain;vaanhet).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% Argument Realization %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

argument_realization(Sign,Cs0,Cs) :-
    Sign => v,
    Sign:deps <=> Deps,
    Sign:sc <=> Sc,
    Sign:slash <=> Slash,
    Sign:subj <=> Subj,
    Sign:pro_deps <=> Edeps,
    realize_args(Deps,Sc0,Slash0,Sign,_Er,Cs0,Cs),
    Mod => modifier,
    unify_mods(Mod),
    Mod:dt <=> ModDt,
    add_modifier_to_dt(SlashMods,Sign),
    add_subj(Sign,Subj,SubjList,Edeps),
    realize_subj(SubjList,Sc0,Sc,Slash0,Slash1,Sign),
    realize_mod_slash(Slash1,Slash,Mod,ModDt,SlashMods).

realize_mod_slash(Sl,Sl,_,_,[]).
realize_mod_slash([],[Mod],Mod,ModDt,[ModDt]).

%% extractable complements (in addition modifiers can be extracted)
extractable(Dep) :-
    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (	Dep => np
    ;	Dep => pp
    ;	Dep => pred
    ;	Dep => sbar
    ;	Dep => adv
    ;	Dep => vp
    ;	PG==parse, Dep => vc
    ).

%% non-extractable complements (all others, but specified using delayed
%% inequality)
complement_extractable(Dep) :-
    hdrug_util:hdrug_flag(parse_or_generate,PG),
    (	Dep /=> np,
	Dep /=> pp,
    	Dep /=> pred,
    	Dep /=> sbar,
    	Dep /=> adv,
    	Dep /=> vp,
    	(  PG == parse, Dep /=> vc
        ;  PG == generate
        )
    ).


%% what to do with your modifiers?
%% keep: keep them yourself
%% raise: give them back to embedded verb
%% both: ambiguous
%% in addition, if a modifier is put on slash, that modifier
%% must be kept, always (so if you're of type raise, then you can't
%% put a modifier on slash
add_modifier_to_dt([],Sign) :-
    Sign => v,
    Sign:vtype => vaux,
    Sign:dt:mod => [],
    Sign:mods <=> GiveMods,
    Sign:deps <=> [VC|_],
    VC => vc,
    VC:mods <=> VCMods,
    VC:cmods <=> VCCMods,
    alpino_wappend:wappend(GiveMods,VCCMods,VCMods).

add_modifier_to_dt(Slashed,Sign) :-
    Sign => v,
    Sign:vtype => vmain,
    alpino_wappend:wappend(Slashed,Mods,Mod),
    Sign:mods <=> Mods,
    Sign:dt:mod <=> Mod.

add_modifier_to_dt(Slashed,Sign) :-
    Sign => v,
    Sign:vtype => (vcontrol;vaanhet),
    Sign:dt:mod <=> Mod,
    alpino_wappend:wappend(Slashed,MoreMods,Mod),
    %% part of my mods are going to be appended to embedded verb's cmods
    %% the remainder will end up in my own mod
    Sign:mods <=> Mods,
    alpino_wappend:wappend(MoreMods,GiveMods,Mods),
    Sign:deps <=> [VC|_],
    VC => vc,
    VC:mods <=> VCMods,
    VC:cmods <=> VCCMods,
    alpino_wappend:wappend(GiveMods,VCCMods,VCMods).

add_subj(Sign,Subj,[Subj],[]) :-
    Sign => v,
    Sign:vform => fin,
    Subj => np,
    Subj:bmeas => no,
    Subj:e_deps => [],
    Subj:pred => npred,
    Subj:nform => ~none,
    Subj:case => nom.

add_subj(Sign,Subj,[],[]) :-
    Sign => v,
    Sign:vform => fin,
    Subj => np,
    Subj:e_deps => [],
    Subj:agr <=> Subj:e_agr,
    Subj:pred => npred,
    Subj:nform => none.

add_subj(Sign,Subj,[],[Subj]) :-
    Sign => v,
    Sign:vform => ~fin.

%% realize_args(Deps,Subjs,Sc,Slash,Sign)
%% deps are finished, now continue with subjs
realize_args([],[],[],_Sign,_,Cs,Cs).
realize_args([Dep|Deps],Sc,Slash,Sign,Ers0,Cs0,Cs):-
    realize_arg(Dep,Deps,DepsTail,Sc,Sc1,Slash,Slash1,Sign,Ers0,Ers,Cs0,Cs1),
    realize_args(DepsTail,Sc1,Slash1,Sign,Ers,Cs1,Cs).

realize_subj([],Sc,Sc,Sl,Sl,_).
realize_subj([Dep],Sc0,Sc,Slash0,Slash,Sign):-
    realize_arg_subj(Dep,Sc0,Sc,Slash0,Slash,Sign).

%% similar to case 1 of realize arg. In addition, subj can
%% 'skip' reflexives on sc.
realize_arg_subj(Dep,Sc0,Sc,Slash0,Slash,Sign) :-
    Dep => np,
    slash_or_subcat_subj(_,Dep,Sc,Sc0,Slash1,Slash0,Sign),
    inherit_slash_normal(Dep,[],[],Slash,Slash1).

slash_or_subcat_subj(not_extracted,Dep,Sc,Sc0,Sl,Sl,Sign) :-
    %% ok, the subject is not extracted. That means that *if* we
    %% take part in an inverted sentence, then we can't have
    %% ninvje agreement
    Sign => v,
    Sign:inv_agr => ~ninvje,
    Dep => np,
    Dep:sel =?> ~to_topic,
    alpino_wappend:add_at_end(Dep,Sc0,Sc).

slash_or_subcat_subj(extracted,Dep,Sc,Sc,[Dep],[],Sign) :-
    Dep => np,
    Dep:tags =?> [],
    Dep:wkpro =?> ~ntopicpro,
    Dep:sel =?> to_topic,
    Sign => v,                  % subject is extracted, so 
    Sign:inv_agr => ~invje.     % we can't have inv agr

inherit_slash(_,Dep,Deps0,Deps,Slash0,Slash,Ers,Ers,Cs,Cs) :-
    inherit_slash_normal(Dep,Deps0,Deps,Slash0,Slash).

inherit_slash(not_extracted,Dep,Deps0,Deps,Slash,Slash,0,1,[er_word|Cs],Cs) :-
    inherit_slash_er(Dep,Deps0,Deps).

%% normal case
inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1) :-
    if_defined(Dep:slash,DepSlash,[]),
    alpino_wappend:wappend_atmost1(DepSlash,Slash,Slash1).

%% special case
%% this is for cases such as:
%% dat ik daar[i] niet aan t[i] heb gedacht
%% dat ik daar[i] niet aan t[i] heb willen denken
%%
%% this now depends on the presence of an r-pronoun in
%% the actual string
%%
%% nb: actually there is no reason to do this for raised categories?
%% yes there is for "ik laat er geen misverstand over bestaan"
%%
%% nb: the np should not be moved to slash again later...
%%     since that would give rise to spurious ambiguities
inherit_slash_er(Dep,Deps0,Deps) :-
    Dep /=> sbar, % ! *omdat hij daar zegt dat hij op rekent
    Dep /=> vp,   % ! *omdat hij daar probeert om op te rekenen
    Dep:slash <=> [NP],
    r_np_arg(NP),
    unify_except(NP,NP1,sel),
    NP1:sel => to_left,   % otherwise we could add it to slash, again
    insert(Deps0,NP1,Deps).

% insert(List,El,[El|List]).
% insert([H|T],El,[H|T2]) :-
%     insert(T,El,T2).

insert([],El,[El]).
insert([H|T],El,[El,H|T]) :-
    H:sel =?> to_left,
    ( H /=> sbar
    , H /=> vp
    , H /=> vc
    ).
insert([H|T],El,[H|T2]) :-
    insert(T,El,T2).

%% case 1: extractable, non-raising category
%%         either move to slash, or move to subcat
realize_arg(Dep,Deps0,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers0,Ers,Cs0,Cs) :-
    extractable(Dep),
    Dep /=> vc,
    slash_or_subcat(E,Dep,Sc0,Sc,Slash0,Slash1,Sign),
    inherit_slash(E,Dep,Deps0,Deps,Slash,Slash1,Ers0,Ers,Cs0,Cs).

%% case 2: non-extractable, non-raising category
%%         always move to subcat
realize_arg(Dep,Deps0,Deps,[Dep|Sc],Sc,Slash0,Slash,_Sign,Ers0,Ers,Cs0,Cs):-
    complement_extractable(Dep),
    Dep /=> vc,
    inherit_slash(not_extracted,Dep,Deps0,Deps,Slash,Slash0,Ers0,Ers,Cs0,Cs).

%% case 3: raising category: active
realize_arg(Dep,Deps0,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => act,
    Dep:sc <=> Inh,
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps0,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% case 4a: raising category: passive
%% ignore the NP object, if available (unify parts of object with subject). 
%% if no NP object, inherit everything (for impersonal passives),
%%    but assign Subject special `none' feature, so realize_arg above
%%    knows there is no subject
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => pas,
    Sign:subj <=> Subj,
    Dep:sc <=> Inh0,
    passive_object(Inh0,Dep,Subj,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% 4b passive, but not impersonal. For "staan, lijken, blijken,liggen..."
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => norm_pas,
    Sign:subj <=> Subj,
    Dep:sc <=> Inh0,
    normal_passive_object(Inh0,Dep,Subj,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% 4c impersonal passive in presence of sbar complement
%% er staat geschreven dat ..
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => sbar_pas,
    Sign:subj <=> Subj,
    Dep:sc <=> Inh0,
    normal_sbar_passive_object(Inh0,Dep,Subj,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% case 5: "krijgen" passive
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => so_pas,
    Sign:subj <=> Subj,
    Dep:sc <=> Inh0,
    Dep:passive => norm_passive,
    so_passive_object(Inh0,Dep,Subj,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash2,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash2),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% case 6 'het valt niet te ontkennen dat'
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => sbar_subj_te_pas,
    Sign:subj <=> Subj,
    Subj => np,
    Dep:sc <=> Inh0,
    sbar_passive_object(Inh0,Dep,Sbar,Inh),
    maybe_het_subj(Sign,Subj,Sbar),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% case 7 'zien' passive
realize_arg(Dep,[Obj1|Deps],[Obj1|Deps],Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => obj1_pas,
    Dep:sc <=> Inh0,
    passive_object(Inh0,Dep,Obj1,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

%% case 8 'voel' passive, like personal passive, but no IPP
realize_arg(Dep,Deps,Deps,Sc0,Sc,Slash0,Slash,Sign,Ers,Ers,Cs,Cs) :-
    Dep => vc,
    Sign:act => refl_pas,
    Sign:subj <=> Subj,
    Dep:sc <=> Inh0,
    Dep:passive => norm_passive,
    normal_passive_object(Inh0,Dep,Subj,Inh),
    slash_or_subcat(_E,Dep,Sc0,Sc1,Slash0,Slash1,Sign),
    inherit_slash_normal(Dep,Deps,Deps,Slash,Slash1),
    alpino_wappend:add_at_end_list(Sc,Inh,Sc1).

so_passive_object(DepSc,_,NP,Inh) :-
    NP => np,
    dat_np_arg(NP0),
    NP0:passivizes => yes,
    unify_except_l(NP0,NP,[case,sel]),
    alpino_wappend:wselect(NP0,DepSc,Inh).

slash_or_subcat(not_extracted,Dep,[Dep|Sc],Sc,Sl,Sl,_) :-
    Dep:sel =?> ~to_topic.
slash_or_subcat(extracted,Dep,Sc,Sc,[Dep],[],_) :-
    extractable(Dep),
    Dep:sel =?> to_topic,
    Dep:tags =?> [],
    Dep:wkpro =?> ~weakpro & ~ntopicpro.

%% normal passive: select appropriate NP object
passive_object(DepSc,Dep,Subj,Inh) :-
    Dep:passive => norm_passive,
    personal_passive_object(DepSc,Subj,Inh).

%% impersonal passive: no subject
passive_object(Inh,Dep,Subj,Inh) :-
    Dep:passive => imp_passive,
    dummy_subj(Subj).

%% * er staat geschreven
%%   er staat geschreven dat ...
normal_passive_object(DepSc,Dep,Subj,Inh) :-
    Dep:passive => norm_passive,
    personal_passive_object(DepSc,Subj,Inh).

normal_sbar_passive_object(Inh,Dep,Subj,Inh) :-
    Dep:passive => imp_passive,
    sbar_arg(Sbar),
    alpino_wappend:wselect(Sbar,Inh,_),
    dummy_subj(Subj).

personal_passive_object(DepSc,Subj,Inh) :-    
    Subj => np,
    Subj:passivizes => yes,
    unify_except_l(Subj,Obj,[case,sel]),
    Obj:case => acc,
    alpino_wappend:wselect(Obj,DepSc,Inh).

sbar_passive_object(DepSc,_Dep,Sbar,DepSc) :-
    sbar_arg(Sbar),
    alpino_wappend:wselect(Sbar,DepSc,_).

%% used in lex_conv.gram
%% IPP: auxiliaries use their infinitive form instead of
%%      participle form.
%%   .. dat ik an heb willen kussen
%% * .. dat ik an heb gewild kussen
%%
%% analysis: * infinitivals get two translations for verbs with
%%             vc dependent (either psp or inf)
%%           * participles are disallowed for verbs with vc
%%             dependent
%%
%% further complication: if the Verbal argument required a te-complement
%% then in ipp a inf variant suddenly is possible too:
%% hij loopt TE vervelen
%% hij heeft lopen (te) vervelen
%%

ipp_assign_inf(Sign,Sign) :-
    (	Sign:deps <=> [Verbal|_],
	Sign:act => act,
	Verbal => vc,
	Verbal:vform => (~aan_het & ~pass_te & ~op & ~uit),
        Sign:vform => (inf;psp)  % !!!
    ;   Sign:deps => [],
	Sign:vform => inf
    ;   Sign:deps <=> [NonV|_],
	NonV /=> vc,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Sign:act => act,
	Verbal => vc,
	Verbal:vform => (aan_het;pass_te;op;uit),
        Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => so_pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => obj1_pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => refl_pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => sbar_subj_te_pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => sbar_pas,
	Sign:vform => inf
    ;	Sign:deps <=> [Verbal|_],
	Verbal => vc,
	Sign:act => norm_pas,
	Sign:vform => inf
    ).

ipp_assign_inf(Sign0,Sign) :-
    Sign0:sc <=> [Verbal|_],
    Sign0:act => act,
    Verbal => vc,
    Verbal:vform => wk_te,
    Sign0:vform => (psp;inf),   % hij gaat lopen klieren
				% hij kan! lopen klieren
                                % hij heeft lopen klieren
    % this is perhaps too liberal:
    % *hij wil proberen slapen
    hdrug_feature:overwrite(Sign0,Sign,sc:h:vform,inf).

%% participles *never* have vc complement (ipp), unless it's
%% aan_het or passive-te or so-passive
%% in the latter case, the vc complement must go to the left!
%% ("aan het" always goes to the left anyways)
%% 
%% hij zou zijn te vertrouwen / hij zou te vertrouwen zijn
%% hij is te vertrouwen geweest
%% * hij is geweest te vertrouwen
%% hij zou dit toegewezen krijgen / hij zou dit krijgen toegewezen
%% hij heeft dit toegewezen gekregen
%% * hij heeft dit krijgen toegewezen
ipp_assign_psp(Sign) :-
    (   Sign:deps => []
    ;   Sign:deps <=> [NonV|_],
	NonV /=> vc
    ;	Sign:deps <=> [V|_],
	V => vc,
	Sign:act => act,
	V:sel => to_left,
	V:vform => (aan_het;pass_te;op;uit)
    ;	Sign:deps <=> [V|_],
	V => vc,
	Sign:act => so_pas,
	V:sel => to_left
    ;	Sign:deps <=> [V|_],
	V => vc,
	Sign:act => obj1_pas,
	V:sel => to_left
    ;	Sign:deps <=> [V|_],
	V => vc,
	Sign:act => refl_pas,
	V:sel => to_left
    ;	Sign:deps <=> [V|_],
	V => vc,
	Sign:act => norm_pas,
	V:sel => to_left
    ;	Sign:deps <=> [V|_],
	V => vc,
	V:sel => to_left,
	V:vform => pass_te,
	Sign:act => pas
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% add to extraposition %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

add_als_to_exs(A0,A) :-
    add_comparative_to_exs(A0,A,als).

add_e_als_to_exs(A0,A) :-
    add_comparative_to_exs(A0,A,e_als).

add_comparative_to_exs(A0,A,ComparForm) :-
    unify_except_l(A0,A,[exs,dt:obcomp]),
    A0:exs <=> Exs0,
    ComparativeP => comparativep,
    unify_mods(ComparativeP),
    compar_form(ComparForm,ComparVal),
    ComparativeP:compar_form <=> ComparVal,
    A:dt:obcomp <=> ComparativeP:dt,
    A:exs <=> [ComparativeP|Exs0].

opt_add_comparative_to_exs(A,A,_).
opt_add_comparative_to_exs(A0,A,Compar) :-
    add_comparative_to_exs(A0,A,Compar).

add_dat_to_exs(A0,A) :-
    unify_except_l(A0,A,[exs,dt:obcomp]),
    A0:exs <=> Exs0,
    Sbar => sbar,
    Sbar:slash => [],
    Sbar:ctype => c_dat,
    Sbar:e_deps => [],
    A:dt:obcomp <=> Sbar:dt,
    A:exs <=> [Sbar|Exs0].

add_omte_to_exs(A0,A) :-
    unify_except(A0,A1,exs),
    unify_except(A1,A,dt:obcomp),
    A0:exs <=> Exs0,
    no_subj_vp_arg(Sbar),
    Sbar:slash => [],
    A:dt:obcomp <=> Sbar:dt,
    A:exs <=> [Sbar|Exs0].

add_om_to_exs(A0,A) :-
    unify_except_l(A0,A,[exs,dt:obcomp]),
    A0:exs <=> Exs0,
    (   no_subj_vp_arg(Sbar),
	Sbar:vform => om,
	Sbar:slash => []
    ;   Sbar => rel,
	Sbar:relform => relform_inf,
	Sbar:tmploc => non_adv
    ),
    A:dt:obcomp <=> Sbar:dt,
    A:exs <=> [Sbar|Exs0].

opt_add_compar_to_exs_if_cform(A,A) :-
    A:dt:obcomp => [].

opt_add_compar_to_exs_if_cform(A0,A) :-
    unify_except(A0,A,exs),
    A:cform => compar,
    ComparativeP => comparativep,
    compar_form(dan,Form),
    ComparativeP:compar_form <=> Form,
    A:dt:obcomp <=> ComparativeP:dt,
    A:exs <=> [ComparativeP].

opt_add_compar_to_obj_if_cform(A) :-
    A:me_adj => no,
    A:sc => [],
    A:dt:me => [].
opt_add_compar_to_obj_if_cform(A) :-
    A:sc <=> [NP],
    A:me_adj => yes,
%%    A:cform =?> compar,
    A:dt:fwrd:lexical <=> zoveel,
    adj_np_me_arg(NP),
    NP:subn => ~sub_def_verb,
    NP:subn => ~sub_def_adj & ~sub_indef_adj & ~sub_rang,
    NP:subn => ~sub_def_pron & ~sub_indef_pron & ~sub_det & ~sub_veel,
                                % veel mooier ==> only mod
    deprel(A,me,NP).
opt_add_compar_to_obj_if_cform(A) :-
    A:sc <=> [NP],
    A:me_adj => yes,
    A:cform =?> compar,
    adj_np_me_arg(NP),
    NP:subn => ~sub_def_verb,
    NP:subn => ~sub_def_adj & ~sub_indef_adj & ~sub_rang,
    NP:subn => ~sub_def_pron & ~sub_indef_pron & ~sub_det & ~sub_veel,
                                % veel mooier ==> only mod
    deprel(A,me,NP).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% CONSTRUCT-DT %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% in order to assign complex dt's to lexical entries (mwu's typically)

%% there are several problems with this code...

construct_dt(Deriv,Sign,Word,F,Dt0) :-
    if(construct_dt_(Deriv,Sign,Word,F,Dt0),
       true,
       format(user_error,"error: cannot construct ~w~n",[Deriv])
      ).

construct_dt_(Deriv,Sign,Word,F,Dt0) :-
    Word:beginpos <=> P0,
%    Word:his <=> His,
    Sign:dt <=> DtF,
    Dt => dt,
    Dt:app <=> Apps,
    Dt:mod <=> Mods,
    Dt:det <=> Dets,
    Dt:predm <=> Pms,
    what_with_rest(Deriv,Sign,Dt,AppRest,ModRest,DetRest,PmRest,Dp),
    Dt:svp <=> Svp,
    Dt:cnj <=> Cn,
    Dt:crd <=> Cr,
    Dt:mwp <=> Mwp,
    construct_dt_node(Deriv,Dt,DtF,P0,Dets,DetRest,Apps,AppRest,Mods,
                      ModRest,Svp,[],
                      Pms,PmRest,Cn,[],Cr,[],Mwp,[],F,Dp,[],Dt0,
                      InitList,[]),
    initialize_dt(InitList,Sign).

/* percolation features: should go somewhere, perhaps allow for cat=du
   nodes that these become all dp daughters;
   not used now, because we don't do this for dp_dp_struct in grammar rules
   either...
   
what_with_rest(dt(du,_),Sign,Dt,[],[],[],[],Dp0) :-
    !,
    Sign:apps <=> AppRest,
    Sign:mods <=> ModRest,
    Sign:dets <=> DetRest,
    Sign:predms <=> PmRest,
    Dt:dp <=> Dp,
    alpino_wappend:wappend(Dp0,AppRest,Dp1),
    alpino_wappend:wappend(Dp1,ModRest,Dp2),
    alpino_wappend:wappend(Dp2,DetRest,Dp3),
    alpino_wappend:wappend(Dp3,PmRest,Dp).
*/

what_with_rest(_Deriv,Sign,Dt,AppRest,ModRest,DetRest,PmRest,Dp) :-
    Dt:dp <=> Dp,
    Sign:apps <=> AppRest,
    Sign:mods <=> ModRest,
    Sign:dets <=> DetRest,
    Sign:predms <=> PmRest.

construct_dt_node(dt(InCat,List),Dt,Dt,P0,D0,D,A0,A,M0,M,Sv0,Sv,Pm0,Pm,
		  Cn0,Cn,Cr0,Cr,Mwp0,Mwp,F,Dp0,Dp,Dt0,Init0,Init) :-
    construct_dt_cat(InCat,Dt,Dt0),
    construct_dt_list(List,Dt,P0,D0,D,A0,A,M0,M,Sv0,Sv,Pm0,Pm,
		      Cn0,Cn,Cr0,Cr,Mwp0,Mwp,F,Dp0,Dp,Dt0,Init0,Init).
construct_dt_node(orig(Path),_,Dt,_,D,D,A,A,M,M,S,S,P,P,
		  Cn,Cn,Cr,Cr,Mwp,Mwp,_,Dp,Dp,Orig,[First|Init],Init) :-
    Dt <=> Orig:Path,
    first_att(Path,First).

construct_dt_node(l(W,T,R0,R),Dt,Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,
		  Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Orig,Init,Init) :-
    construct_lexical_node(l(W,T,R0,R),Dt,P0,F,Orig).

construct_dt_node(l(W,T,CAT,R0,R),Dt,Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,
		  Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Orig,Init,Init) :-
    construct_lexical_node(l(W,T,CAT,R0,R),Dt,P0,F,Orig).

construct_dt_node(ix(Dt,Node),Dt0,Dt,P0,D0,D,A0,A,M0,M,Sv0,Sv,Pm0,Pm,
		  Cn0,Cn,Cr0,Cr,Mwp0,Mwp,F,Dp0,Dp,Orig,Init0,Init) :-
    construct_dt_node(Node,Dt0,Dt,P0,D0,D,A0,A,M0,M,Sv0,Sv,Pm0,Pm,
		  Cn0,Cn,Cr0,Cr,Mwp0,Mwp,F,Dp0,Dp,Orig,Init0,Init).
construct_dt_node(ix(Dt),_,Dt,_,D,D,A,A,M,M,S,S,P,P,
		  Cn,Cn,Cr,Cr,Mwp,Mwp,_,Dp,Dp,_,Init,Init).

first_att(Path,First) :-
    (   atomic(Path)
    ->  Path = First
    ;   Path = (First:_Rest)
    ).

construct_dt_cat(orig(Path),Dt,Dt0) :-
    !,
    Dt:cat <=> Dt0:Path.
construct_dt_cat(Val,DT,_) :-
    DT:cat ==> Val.

construct_lexical_node(ix(Dt,Node),Dt,P0,F,Orig) :-
    construct_lexical_node(Node,Dt,P0,F,Orig).
construct_lexical_node(ix(Dt0),Dt,_,_,_) :-
    Dt0:hwrd <=> Dt:hwrd,
    Dt0:fwrd <=> Dt:fwrd,
    Dt0:frame <=> Dt:frame,
    Dt0:cat <=> Dt:cat,
    Dt0:lix <=> Dt:lix.


construct_lexical_node(l(Word0,Pos,R0,R),Dt,P0,_F,_Orig) :-
    (  Word0 = v_root(Root,Lemma)
    ;  atomic(Word0), Root=Word0, Lemma=Word0
    ),
%    when(nonvar(P0),( S0 is P0 + R0, S is P0 + R )),
    when(nonvar(P0), construct_pos(P0,R0,S0)),
    when(nonvar(P0), construct_pos(P0,R ,S )),
    Dt:frame ==> Pos,
    Dt:hwrd:beginpos <=> S0,
    Dt:hwrd:endpos <=> S,
    Dt:hwrd:lexical ==> Root,
    Dt:hwrd:lemma ==> Lemma,
    Dt:hwrd:surface ==> Root,  % ?
    Dt:hwrd:his ==> with_dt.

construct_lexical_node(l(Word0,Pos,Cat,R0,R),Dt,P0,_F,Orig) :-
    (  Word0 = v_root(Root,Lemma)
    ;  atomic(Word0), Root=Word0, Lemma=Word0
    ),
%    when(nonvar(P0),( S0 is P0 + R0, S is P0 + R )),
    when(nonvar(P0), construct_pos(P0,R0,S0)),
    when(nonvar(P0), construct_pos(P0,R, S )),
    construct_dt_cat(Cat,Dt,Orig),
    Dt:frame ==> Pos,
    Dt:hwrd:beginpos <=> S0,
    Dt:hwrd:endpos <=> S,
    Dt:hwrd:lexical ==> Root,
    Dt:hwrd:lemma ==> Lemma,
    Dt:hwrd:surface ==> Root,  % ?
    Dt:hwrd:his ==> with_dt.

construct_pos(P0,R,S) :-
    integer(R),
    S  is P0 + R.

construct_pos(P0,[Rh|Rt],[Sh|St]) :-
    construct_pos_list([Rh|Rt],[Sh|St],P0).

construct_pos_list([],[],_).
construct_pos_list([Rh|Rt],[Sh|St],P0) :-
    Sh is P0 + Rh,
    construct_pos_list(Rt,St,P0).

construct_dt_list([],_,_,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,_F,
                  Dp,Dp,_,Init,Init).
construct_dt_list([Rel=Patt|Tail],Dt,P0,D0,D,A0,A,M0,M,Sv0,Sv,Pm0,Pm,
		  Cn0,Cn,Cr0,Cr,Mwp0,Mwp,F,Dp0,Dp,Dt0,Init0,Init) :-
    construct_dt_rel(Rel,Patt,Dt,P0,D0,D1,A0,A1,M0,M1,Sv0,Sv1,Pm0,Pm1,
		     Cn0,Cn1,Cr0,Cr1,Mwp0,Mwp1,F,Dp0,Dp1,Dt0,Init0,Init1),
    construct_dt_list(Tail,Dt,P0,D1,D,A1,A,M1,M,Sv1,Sv,Pm1,Pm,
		      Cn1,Cn,Cr1,Cr,Mwp1,Mwp,F,Dp1,Dp,Dt0,Init1,Init).

construct_dt_rel(hd,Lex,Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Orig,Init,Init):-
    !,
    construct_lexical_node(Lex,Dt,P0,F,Orig).

construct_dt_rel(det,Patt,_Dt,P0,D0,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,Init,Init) :-
    !,
    D0 = [RelF|D],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(app,Patt,_Dt,P0,D,D,A0,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,Init,Init) :-
    !,
    A0 = [RelF|A],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(mod,Patt,_Dt,P0,D,D,A,A,M0,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,Init,Init) :-
    !,
    M0 = [RelF|M],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(svp,Patt,_Dt,P0,D,D,A,A,M,M,Sv0,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,Init,Init) :-
    !,
    Sv0 = [RelF|Sv],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(cnj,Patt,_Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn0,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,[cnj|Init],Init) :-
    !,
    Cn0 = [RelF|Cn],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(crd,Patt,_Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr0,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,[crd|Init],Init) :-
    !,
    Cr0 = [RelF|Cr],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(dp,Patt,_Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp0,Dp,Dt0,[dp|Init],Init) :-
    !,
    Dp0 = [RelF|Dp],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(mwp,Patt,_Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp0,Mwp,F,Dp,Dp,Dt0,[mwp|Init],Init) :-
    !,
    Mwp0 = [RelF|Mwp],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(predm,Patt,_Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm0,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,Init,Init) :-
    !,
    Pm0 = [RelF|Pm],
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

construct_dt_rel(RelName,Patt,Dt,P0,D,D,A,A,M,M,Sv,Sv,Pm,Pm,Cn,Cn,Cr,Cr,Mwp,Mwp,F,Dp,Dp,Dt0,[RelName|Init],Init) :-
    Dt:RelName <=> RelF,
    Rel => dt,
    Rel:app <=> MA,
    Rel:mod <=> MM,
    Rel:svp <=> MSv,
    Rel:det <=> MD,
    Rel:predm <=> MPm,
    Rel:cnj <=> MCn,
    Rel:crd <=> MCr,
    Rel:dp <=> Mdp,
    Rel:mwp <=> MMwp,
    construct_dt_node(Patt,Rel,RelF,P0,MD,[],MA,[],MM,[],MSv,[],MPm,[],
		      MCn,[],MCr,[],MMwp,[],F,Mdp,[],Dt0,InitX,[]),
    initialize_dt_dt(InitX,Rel).

%%%%%%%%%%%%%%%
%%%% UTILS %%%%
%%%%%%%%%%%%%%%

deprel(Head,Att,Dep) :-
    Head:dt => dt,
    Head:dt:Att <=> Dep:dt.

%% ensure that the DT of the ATT cannot be the empty DT
%% useful for generation
instantiated_deprel(Head,Att,Dep) :-
    Head:dt => dt,
    Head:dt:Att => dt,
    Head:dt:Att <=> Dep:dt.

add_svp(V0,V,Cat) :-
    ( V0 => v ; V0 => a ),
    V0:dt => dt,
    unify_except(V0,V,dt:svp),
    V0:dt <=> Dt0,
    V:dt <=> Dt,
    Dt0:svp <=> Tail,
    Dt:svp <=> [CatDt|Tail],
    Cat:dt <=> CatDt.

%% all dt labels *not* in Atts are initialized
%% as the empty dt: []

%% app mod det predm svp are already initialized
initializable_dt_attributes([body,cmp,cnj,crd,dlink,dp,hdf,ld,me,mwp,
                             nucl,obcomp,obj1,obj2,pc,pobj1,predc,
                             rhd,sat,se,su,sup,tag,vc,whd]).
                            
initialize_dt(AttsIn,Sign) :-
    Sign:dt => dt,
    Sign:dt <=> DT,
    initialize_dt_dt(AttsIn,DT).

initialize_dt_dt(AttsIn,DT) :-
    sort(AttsIn,Atts),
    initializable_dt_attributes(Atts0),
    select_all(Atts,Atts0,AttsEmpty),
    empty_dts(AttsEmpty,DT).

empty_dts([],_).
empty_dts([H|T],DT) :-
    DT:H => [],
    empty_dts(T,DT).

select_all([],L,L).
select_all([H|T],L0,L):-
    (   lists:select(H,L0,L1)
    ->  true
    ;   L0 = L1
    ),
    select_all(T,L1,L).

